<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>第 50 页 &#8211; 酷 壳 &#8211; CoolShell</title>
	<atom:link href="https://coolshell.cn/feed?paged=50" rel="self" type="application/rss+xml" />
	<link>https://coolshell.cn</link>
	<description>享受编程和技术所带来的快乐 - Coding Your Ambition</description>
	<lastBuildDate>Wed, 01 Apr 2015 12:45:26 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2</generator>
	<item>
		<title>50套Web开发图标</title>
		<link>https://coolshell.cn/articles/3.html</link>
					<comments>https://coolshell.cn/articles/3.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Mon, 02 Mar 2009 05:31:43 +0000</pubDate>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[icons]]></category>
		<category><![CDATA[Web]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=3</guid>

					<description><![CDATA[<p>下面是号称最好的50套WEB开发的图标。来源：链接 其它相关的一些文章 30 Amazingly Creative Social Bookmarks Icon ...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/3.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/3.html">50套Web开发图标</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>下面是号称最好的50套WEB开发的图标。来源：<a href="http://speckyboy.com/2009/02/02/50-of-the-best-ever-web-development-design-and-application-icon-sets" target="_blank">链接</a></p>
<p>其它相关的一些文章</p>
<ul>
<li><a href="http://speckyboy.com/2009/01/26/30-amazingly-creative-social-bookmarks-icon-sets" target="_blank">30 Amazingly Creative Social Bookmarks Icon Sets ?</a></li>
<li><a href="http://speckyboy.com/2009/01/22/42-amazing-photoshop-and-illustrator-icon-design-tutorials" target="_blank">42 Amazing Photoshop and Illustrator Icon Design Tutorials ?</a></li>
<li><a href="http://speckyboy.com/2008/07/18/35-free-icon-sets-for-your-iphone-pimp-it-up" target="_blank">35 Free Icon Sets for your iPhone &#8211; Pimp it Up! ?</a></li>
<li><a href="http://speckyboy.com/2008/05/03/top-12-icon-design-video-tutorials" target="_blank">Top 12 Icon Design Video Tutorials ?</a></li>
<li><a href="http://speckyboy.com/2008/05/03/top-5-free-icon-editors-for-the-pro-designer" target="_blank">Top 5 Free Icon Editors for the Pro Designer ?</a></li>
<li><a href="http://speckyboy.com/2008/02/05/the-best-icon-search-engines-and-features-for-designers" target="_blank">The Best Icon Search Engines and Features for Designers ?</a></li>
</ul>
<p><span id="more-3"></span></p>
<p><a  href="http://sweetie.sublink.ca" target="_blank">Sweetie &#8211; Cute and clear icons</a></p>
<p><a href="http://sweetie.sublink.ca" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon3.png" alt="Development Icons" /></a></p>
<p><a href="http://www.famfamfam.com/lab/icons/mini" target="_blank">famfamfam &#8211; Mini Icons</a></p>
<p><a href="http://www.famfamfam.com/lab/icons/mini" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon4.png" alt="Development Icons" /></a></p>
<p><a href="http://www.monofactor.com/free-vector-icon-set-1-25-icons" target="_blank">Vector Icon Set</a></p>
<p><a href="http://www.monofactor.com/free-vector-icon-set-1-25-icons" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon5.png" alt="Development Icons" /></a></p>
<p><a href="http://lopagof.deviantart.com/art/facebook-ui-icons-vector-90099876" target="_blank">Facebook UI Icon Set</a></p>
<p><a href="http://lopagof.deviantart.com/art/facebook-ui-icons-vector-90099876" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon6.png" alt="Development Icons" /></a></p>
<p><a href="http://www.pinvoke.com" target="_blank">Fugue Icons</a></p>
<p><a href="http://www.pinvoke.com" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon7.png" alt="Development Icons" /></a></p>
<h3><a href="http://paularmstrongdesigns.com/projects/bwpx-icns" target="_blank">bwpx Icons</a></h3>
<p><a href="http://paularmstrongdesigns.com/projects/bwpx-icns" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon1.png" alt="Development Icons" /></a></p>
<p><a href="http://somerandomdude.com/projects/sanscons" target="_blank">Sanscons Icon Set</a></p>
<p><a href="http://somerandomdude.com/projects/sanscons" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon2.png" alt="Development Icons" /></a></p>
<p><a href="http://www.pinvoke.com" target="_blank">Diagona Icons</a></p>
<p><a href="http://www.pinvoke.com" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon7a.png" alt="Development Icons" /></a></p>
<p><a href="http://min.frexy.com/articles/category/milky" target="_blank">Milky Icon Set</a></p>
<p><a href="http://min.frexy.com/articles/category/milky" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon8.png" alt="Development Icons" /></a></p>
<p><a href="http://pixelresort.com/icon" target="_blank">Pixelicious Icon Set</a></p>
<p><a href="http://pixelresort.com/icon" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon9.png" alt="Development Icons" /></a></p>
<p><a href="http://www.ineversay.com/my-works/xiao-icon.html" target="_blank">Xiao Icon Set</a></p>
<p><a href="http://www.ineversay.com/my-works/xiao-icon.html" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon10.png" alt="Development Icons" /></a></p>
<p><a href="http://www.ndesign-studio.com/resources/mini-pixel-icons" target="_blank">Mini Pixel Icons</a></p>
<p><a href="http://www.ndesign-studio.com/resources/mini-pixel-icons" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon11.png" alt="Development Icons" /></a></p>
<p><a href="http://wefunction.com/2008/07/function-free-icon-set" target="_blank">Function Icon Set</a></p>
<p><a href="http://wefunction.com/2008/07/function-free-icon-set" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon12.png" alt="Development Icons" /></a></p>
<p><a href="http://www.aspneticons.com" target="_blank">ASP.NET Icon Set</a></p>
<p><a href="http://www.aspneticons.com" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon13.png" alt="Development Icons" /></a></p>
<p><a href="http://sone-pl.deviantart.com/art/Light-Icons-74036005" target="_blank">Light Icon Set</a></p>
<p><a href="http://sone-pl.deviantart.com/art/Light-Icons-74036005" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon14.png" alt="Development Icons" /></a></p>
<p><a href="http://www.gosquared.com/liquidicity/archives/122" target="_blank">Liquidicity Icon Set</a></p>
<p><a href="http://www.gosquared.com/liquidicity/archives/122" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon15.png" alt="Development Icons" /></a></p>
<p><a href="http://www.behance.net/Gallery/iconset-sketchd-up/158535" target="_blank">“sketch’d up!” Icon Set</a></p>
<p><a href="http://www.behance.net/Gallery/iconset-sketchd-up/158535" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon16.png" alt="Development Icons" /></a></p>
<p><a href="http://www.ganato.com/free_icons/free_icons.php" target="_blank">Ganato &#8211; Psd Icons</a></p>
<p><a href="http://www.ganato.com/free_icons/free_icons.php" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon17.png" alt="Development Icons" /></a></p>
<p><a href="http://code.google.com/p/twotiny" target="_blank">Two Tone Icon Set</a></p>
<p><a href="http://code.google.com/p/twotiny" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon18.png" alt="Development Icons" /></a></p>
<p><a href="http://code.google.com/p/twotiny" target="_blank">TwoTiny Icon Set</a></p>
<p><a href="http://code.google.com/p/twotiny" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon19.png" alt="Development Icons" /></a></p>
<p><a href="http://www.oweb2.com/free-web20-icons-pack" target="_blank">Web2.0 Icons Pack</a></p>
<p><a href="http://www.oweb2.com/free-web20-icons-pack" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon20.png" alt="Development Icons" /></a></p>
<p><a href="http://valkyre.deviantart.com/art/Proxal-Icon-Set-v2-17102198" target="_blank">Proxal Icon Set v2</a></p>
<p><a href="http://valkyre.deviantart.com/art/Proxal-Icon-Set-v2-17102198" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon21.png" alt="Development Icons" /></a></p>
<p><a href="http://www.brandspankingnew.net/archive/2006/12/hohoho.html" target="_blank">Brand Spanking New Icon Set</a></p>
<p><a href="http://www.brandspankingnew.net/archive/2006/12/hohoho.html" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon22.png" alt="Development Icons" /></a></p>
<p><a href="http://www.perfect-icons.com/stock-icons/perfect-blog-icons.htm" target="_blank">Perfect Blog Icons</a></p>
<p><a href="http://www.perfect-icons.com/stock-icons/perfect-blog-icons.htm" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon23.png" alt="Development Icons" /></a></p>
<p><a href="http://yingjunjiu.deviantart.com/art/Web-Application-Icons-Set-77183527" target="_blank">Web Application Icons</a></p>
<p><a href="http://yingjunjiu.deviantart.com/art/Web-Application-Icons-Set-77183527" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon24.png" alt="Development Icons" /></a></p>
<p><a href="http://kurumizawa.deviantart.com/art/Irokez-cms-icon-set-79949798" target="_blank">Irokez CMS Icon Set</a></p>
<p><a href="http://kurumizawa.deviantart.com/art/Irokez-cms-icon-set-79949798" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon25.png" alt="Development Icons" /></a></p>
<p><a href="http://icojoy.com/articles/28" target="_blank">BacktoPixel Icon Set</a></p>
<p><a href="http://icojoy.com/articles/28" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon26.png" alt="Development Icons" /></a></p>
<p><a href="http://www.randomjabber.com/static/sizcons" target="_blank">Sizcons &#8211; Random Jabber</a></p>
<p><a href="http://www.randomjabber.com/static/sizcons" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon27.png" alt="Development Icons" /></a></p>
<p><a href="http://www.famfamfam.com/lab/icons/silk" target="_blank">famfamfam &#8211; Silk Icons</a></p>
<p><a href="http://www.famfamfam.com/lab/icons/silk" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon28.png" alt="Development Icons" /></a></p>
<p><a href="http://www.exploding-boy.com/2005/09/13/explodingboy-pixel-icons" target="_blank">ExplodingBoy Pixel Icons</a></p>
<p><a href="http://www.exploding-boy.com/2005/09/13/explodingboy-pixel-icons" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon29.png" alt="Development Icons" /></a></p>
<p><a href="http://e-lusion.com/design/greyscale" target="_blank">Greyscale Icon Development</a></p>
<p><a href="http://e-lusion.com/design/greyscale" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon30.png" alt="Development Icons" /></a></p>
<p><a href="http://www.freeiconsweb.com/16x16_Computer_File_icons.htm" target="_blank">File icons and Computer Icon Set</a></p>
<p><a href="http://www.freeiconsweb.com/16x16_Computer_File_icons.htm" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon31.png" alt="Development Icons" /></a></p>
<p><a href="http://www.freeiconsweb.com/16x16_arrow_icons.htm" target="_blank">Small Arrow Icon Set</a></p>
<p><a href="http://www.freeiconsweb.com/16x16_arrow_icons.htm" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon32.png" alt="Development Icons" /></a></p>
<p><a href="http://sryo.deviantart.com/art/minimal-icons-1-8-6-18808605" target="_blank">Minimal Icons</a></p>
<p><a href="http://sryo.deviantart.com/art/minimal-icons-1-8-6-18808605" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon33.png" alt="Development Icons" /></a></p>
<p><a href="http://bs-markup.de/iconsets" target="_blank">Markup Iconsets</a></p>
<p><a href="http://bs-markup.de/iconsets" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon34.png" alt="Development Icons" /></a></p>
<p><a href="http://www.websiteicons.net/index.php?p=icons&amp;id=1" target="_blank">GraphicPUSH Blog Icons</a></p>
<p><a href="http://www.websiteicons.net/index.php?p=icons&amp;id=1" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon35.png" alt="Development Icons" /></a></p>
<p><a href="http://www.websiteicons.net/index.php?p=icons&amp;id=1" target="_blank">Pixeley Icon Set</a></p>
<p><a href="http://www.websiteicons.net/index.php?p=icons&amp;id=1" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon36.png" alt="Development Icons" /></a></p>
<p><a href="http://www.websiteicons.net/index.php?p=icons&amp;id=1" target="_blank">Drunkey Love</a></p>
<p><a href="http://www.websiteicons.net/index.php?p=icons&amp;id=1" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon37.png" alt="Development Icons" /></a></p>
<p><a href="http://plainbeta.com/downloads/pixelated-a-lightweight-iconkit" target="_blank">PIXELATED Icon Set</a></p>
<p><a href="http://plainbeta.com/downloads/pixelated-a-lightweight-iconkit" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon38.png" alt="Development Icons" /></a></p>
<p><a href="http://kyo-tux.deviantart.com/art/Weby-Icons-111008305" target="_blank">Weby Icons</a></p>
<p><a href="http://kyo-tux.deviantart.com/art/Weby-Icons-111008305" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon39.png" alt="Development Icons" /></a></p>
<p><a href="http://indiandevs.com/devs/webdev-icon-pack-released" target="_blank">WebDev Icon Pack</a></p>
<p><a href="http://indiandevs.com/devs/webdev-icon-pack-released" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon40.png" alt="Development Icons" /></a></p>
<p><a href="http://dryicons.com/free-icons/preview/stickers-icon-set" target="_blank">Stickers Icon Set</a></p>
<p><a href="http://dryicons.com/free-icons/preview/stickers-icon-set" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon41.png" alt="Development Icons" /></a></p>
<p><a href="http://dryicons.com/free-icons/preview/wysiwyg-classic" target="_blank">WYSIWYG Classic Icon Set</a></p>
<p><a href="http://dryicons.com/free-icons/preview/wysiwyg-classic" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon42.png" alt="Development Icons" /></a></p>
<p><a href="http://www.tenbytwenty.com/products/icon-sets/vaga" target="_blank">Vaga Icon Set</a></p>
<p><a href="http://www.tenbytwenty.com/products/icon-sets/vaga" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon43.png" alt="Development Icons" /></a></p>
<p><a href="http://xlphs.deviantart.com/art/WIP-Web-Iconset-68480659" target="_blank">WIP &#8211; Web Iconset</a></p>
<p><a href="http://xlphs.deviantart.com/art/WIP-Web-Iconset-68480659" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon44.png" alt="Development Icons" /></a></p>
<p><a href="http://icojoy.com/articles/19" target="_blank">Free web development icons #1</a></p>
<p><a href="http://icojoy.com/articles/19" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon45.png" alt="Development Icons" /></a></p>
<p><a href="http://icojoy.com/articles/24" target="_blank">Free web development icons #2</a></p>
<p><a href="http://icojoy.com/articles/24" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon46.png" alt="Development Icons" /></a></p>
<p><a href="http://icojoy.com/articles/25" target="_blank">Free web development icons #3</a></p>
<p><a href="http://icojoy.com/articles/25" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon47.png" alt="Development Icons" /></a></p>
<p><a href="http://www.freeiconsweb.com/16x16_black_icons.htm" target="_blank">Black Icon Set</a></p>
<p><a href="http://www.freeiconsweb.com/16x16_black_icons.htm" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon48.png" alt="Development Icons" /></a></p>
<p><a href="http://openclipart.org" target="_blank">Open Clip Art Library</a></p>
<p><a href="http://openclipart.org" target="_blank"><img decoding="async" src="http://speckyboy.com/wp-content/uploads/2009/02/webicon49.png" alt="Development Icons" /></a><!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" id="wp_rp_first"><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/08/enable-https-banner-150x150.png" alt="如何免费的让网站启用HTTPS" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_title">如何免费的让网站启用HTTPS</a></li><li ><a href="https://coolshell.cn/articles/12225.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH-150x150.jpg" alt="DHH 谈混合移动应用开发" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12225.html" class="wp_rp_title">DHH 谈混合移动应用开发</a></li><li ><a href="https://coolshell.cn/articles/12206.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/12/html6-150x150.jpeg" alt="HTML6 展望" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12206.html" class="wp_rp_title">HTML6 展望</a></li><li ><a href="https://coolshell.cn/articles/12136.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/11/inbox2-640x264-150x150.jpg" alt="Google Inbox如何跨平台重用代码？" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12136.html" class="wp_rp_title">Google Inbox如何跨平台重用代码？</a></li><li ><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif" alt="State Threads 回调终结者" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_title">State Threads 回调终结者</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/3.html">50套Web开发图标</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/3.html/feed</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>C++ 对象的内存布局</title>
		<link>https://coolshell.cn/articles/12176.html</link>
					<comments>https://coolshell.cn/articles/12176.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Wed, 15 Oct 2008 01:32:16 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=12176</guid>

					<description><![CDATA[<p>07年12月，我写了一篇《C++虚函数表解析》的文章，引起了大家的兴趣。有很多朋友对我的文章留了言，有鼓励我的，有批评我的，还有很多问问题的。我在这里一并对大家...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/12176.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/12176.html">C++ 对象的内存布局</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>07年12月，我写了一篇《<a title="C++ 虚函数表解析" href="https://coolshell.cn/articles/12165.html" target="_blank">C++虚函数表解析</a>》的文章，引起了大家的兴趣。有很多朋友对我的文章留了言，有鼓励我的，有批评我的，还有很多问问题的。我在这里一并对大家的留言表示感谢。这也是我为什么再写一篇续言的原因。因为，在上一篇文章中，我用了的示例都是非常简单的，主要是为了说明一些机理上的问题，也是为了图一些表达上方便和简单。不想，这篇文章成为了打开C++对象模型内存布局的一个引子，引发了大家对C++对象的更深层次的讨论。当然，我之前的文章还有很多方面没有涉及，从我个人感觉下来，在谈论虚函数表里，至少有以下这些内容没有涉及：</p>
<p style="padding-left: 30px;">1）有成员变量的情况。</p>
<p style="padding-left: 30px;">2）有重复继承的情况。</p>
<p style="padding-left: 30px;">3）有虚拟继承的情况。</p>
<p style="padding-left: 30px;">4）有钻石型虚拟继承的情况。</p>
<p> 这些都是我本篇文章需要向大家说明的东西。所以，这篇文章将会是《<a href="https://coolshell.cn/articles/12165.html" target="_blank">C++虚函数表解析</a>》的一个续篇，也是一篇高级进阶的文章。我希望大家在读这篇文章之前对C++有一定的基础和了解，并能先读我的上一篇文章。因为这篇文章的深度可能会比较深，而且会比较杂乱，我希望你在读本篇文章时不会有大脑思维紊乱导致大脑死机的情况。;-)</p>
<h4>对象的影响因素</h4>
<p>简而言之，我们一个类可能会有如下的影响因素：</p>
<p style="padding-left: 30px;">1）成员变量</p>
<p style="padding-left: 30px;">2）虚函数（产生虚函数表）</p>
<p style="padding-left: 30px;">3）单一继承（只继承于一个类）</p>
<p style="padding-left: 30px;">4）多重继承（继承多个类）</p>
<p style="padding-left: 30px;">5）重复继承（继承的多个父类中其父类有相同的超类）</p>
<p style="padding-left: 30px;">6）虚拟继承（使用virtual方式继承，为了保证继承后父类的内存布局只会存在一份）</p>
<p>上述的东西通常是C++这门语言在语义方面对对象内部的影响因素，当然，还会有编译器的影响（比如优化），还有字节对齐的影响。在这里我们都不讨论，我们只讨论C++语言上的影响。</p>
<p>本篇文章着重讨论下述几个情况下的C++对象的内存布局情况。</p>
<p><span id="more-12176"></span></p>
<p style="padding-left: 30px;">1）<strong>单一的一般继承</strong>（带成员变量、虚函数、虚函数覆盖）</p>
<p style="padding-left: 30px;">2）<strong>单一的虚拟继承</strong>（带成员变量、虚函数、虚函数覆盖）</p>
<p style="padding-left: 30px;">3）<strong>多重继承</strong>（带成员变量、虚函数、虚函数覆盖）</p>
<p style="padding-left: 30px;">4）<strong>重复多重继承</strong>（带成员变量、虚函数、虚函数覆盖）</p>
<p style="padding-left: 30px;">5）<strong>钻石型的虚拟多重继承</strong>（带成员变量、虚函数、虚函数覆盖）</p>
<p>我们的目标就是，让事情越来越复杂。</p>
<h4>知识复习</h4>
<p>我们简单地复习一下，我们可以通过对象的地址来取得虚函数表的地址，如：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">typedef void(*Fun)(void);

Base b;

Fun pFun = NULL;

cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;
cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;

// Invoke the first virtual function
pFun = (Fun)*((int*)*(int*)(&amp;b));
pFun();</pre>
<p>我们同样可以用这种方式来取得整个对象实例的内存布局。因为这些东西在内存中都是连续分布的，我们只需要使用适当的地址偏移量，我们就可以获得整个内存对象的布局。</p>
<p>本篇文章中的例程或内存布局主要使用如下编译器和系统：</p>
<p style="padding-left: 30px;"><strong>1）Windows XP 和 VC++ 2003</strong><br />
<strong> 2）Cygwin 和 G++ 3.4.4</strong></p>
<h4>单一的一般继承</h4>
<p>下面，我们假设有如下所示的一个继承关系：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12178" src="https://coolshell.cn/wp-content/uploads/2014/12/011.jpg" alt="01" width="177" height="366" srcset="https://coolshell.cn/wp-content/uploads/2014/12/011.jpg 177w, https://coolshell.cn/wp-content/uploads/2014/12/011-145x300.jpg 145w, https://coolshell.cn/wp-content/uploads/2014/12/011-131x270.jpg 131w" sizes="(max-width: 177px) 100vw, 177px" /></p>
<p>请注意，在这个继承关系中，父类，子类，孙子类都有自己的一个成员变量。而了类覆盖了父类的f()方法，孙子类覆盖了子类的g_child()及其超类的f()。</p>
<p>我们的源程序如下所示：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class Parent {
public:
    int iparent;
    Parent ():iparent (10) {}
    virtual void f() { cout &lt;&lt; &quot; Parent::f()&quot; &lt;&lt; endl; }
    virtual void g() { cout &lt;&lt; &quot; Parent::g()&quot; &lt;&lt; endl; }
    virtual void h() { cout &lt;&lt; &quot; Parent::h()&quot; &lt;&lt; endl; }

};

class Child : public Parent {
public:
    int ichild;
    Child():ichild(100) {}
    virtual void f() { cout &lt;&lt; &quot;Child::f()&quot; &lt;&lt; endl; }
    virtual void g_child() { cout &lt;&lt; &quot;Child::g_child()&quot; &lt;&lt; endl; }
    virtual void h_child() { cout &lt;&lt; &quot;Child::h_child()&quot; &lt;&lt; endl; }
};

class GrandChild : public Child{
public:
    int igrandchild;
    GrandChild():igrandchild(1000) {}
    virtual void f() { cout &lt;&lt; &quot;GrandChild::f()&quot; &lt;&lt; endl; }
    virtual void g_child() { cout &lt;&lt; &quot;GrandChild::g_child()&quot; &lt;&lt; endl; }
    virtual void h_grandchild() { cout &lt;&lt; &quot;GrandChild::h_grandchild()&quot; &lt;&lt; endl; }
};</pre>
<p>我们使用以下程序作为测试程序：（下面程序中，我使用了一个int** pVtab 来作为遍历对象内存布局的指针，这样，我就可以方便地像使用数组一样来遍历所有的成员包括其虚函数表了，在后面的程序中，我也是用这样的方法的，请不必感到奇怪，）</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">typedef void(*Fun)(void);

GrandChild gc;

int** pVtab = (int**)&amp;gc;

cout &lt;&lt; &quot;[0] GrandChild::_vptr-&gt;&quot; &lt;&lt; endl;
for (int i=0; (Fun)pVtab[0][i]!=NULL; i++){
    pFun = (Fun)pVtab[0][i];
    cout &lt;&lt; &quot;    [&quot;&lt;&lt;i&lt;&lt;&quot;] &quot;;
    pFun();
}
cout &lt;&lt; &quot;[1] Parent.iparent = &quot; &lt;&lt; (int)pVtab[1] &lt;&lt; endl;
cout &lt;&lt; &quot;[2] Child.ichild = &quot; &lt;&lt; (int)pVtab[2] &lt;&lt; endl;
cout &lt;&lt; &quot;[3] GrandChild.igrandchild = &quot; &lt;&lt; (int)pVtab[3] &lt;&lt; endl;</pre>
<p>其运行结果如下所示：（在VC++ 2003和G++ 3.4.4下）</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">[0] GrandChild::_vptr-&gt;
&lt;pre&gt;    [0] GrandChild::f()
    [1] Parent::g()
    [2] Parent::h()
    [3] GrandChild::g_child()
    [4] Child::h1()
    [5] GrandChild::h_grandchild()
[1] Parent.iparent = 10
[2] Child.ichild = 100
[3] GrandChild.igrandchild = 1000</pre>
<p>使用图片表示如下：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12180" src="https://coolshell.cn/wp-content/uploads/2014/12/021.jpg" alt="02" width="500" height="237" srcset="https://coolshell.cn/wp-content/uploads/2014/12/021.jpg 500w, https://coolshell.cn/wp-content/uploads/2014/12/021-300x142.jpg 300w" sizes="(max-width: 500px) 100vw, 500px" /></p>
<p>可见以下几个方面：</p>
<p style="padding-left: 30px;">1）虚函数表在最前面的位置。</p>
<p style="padding-left: 30px;">2）成员变量根据其继承和声明顺序依次放在后面。</p>
<p style="padding-left: 30px;">3）在单一的继承中，被overwrite的虚函数在虚函数表中得到了更新。</p>
<h4>多重继承</h4>
<p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类只overwrite了父类的f()函数，而还有一个是自己的函数（我们这样做的目的是为了用g1()作为一个标记来标明子类的虚函数表）。而且每个类中都有一个自己的成员变量：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12181" src="https://coolshell.cn/wp-content/uploads/2014/12/031.jpg" alt="03" width="328" height="265" srcset="https://coolshell.cn/wp-content/uploads/2014/12/031.jpg 328w, https://coolshell.cn/wp-content/uploads/2014/12/031-300x242.jpg 300w" sizes="(max-width: 328px) 100vw, 328px" /></p>
<p>我们的类继承的源代码如下所示：父类的成员初始为10，20，30，子类的为100</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class Base1 {
public:
    int ibase1;
    Base1():ibase1(10) {}
    virtual void f() { cout &lt;&lt; &quot;Base1::f()&quot; &lt;&lt; endl; }
    virtual void g() { cout &lt;&lt; &quot;Base1::g()&quot; &lt;&lt; endl; }
    virtual void h() { cout &lt;&lt; &quot;Base1::h()&quot; &lt;&lt; endl; }

};

class Base2 {
public:
    int ibase2;
    Base2():ibase2(20) {}
    virtual void f() { cout &lt;&lt; &quot;Base2::f()&quot; &lt;&lt; endl; }
    virtual void g() { cout &lt;&lt; &quot;Base2::g()&quot; &lt;&lt; endl; }
    virtual void h() { cout &lt;&lt; &quot;Base2::h()&quot; &lt;&lt; endl; }
};

class Base3 {
public:
    int ibase3;
    Base3():ibase3(30) {}
    virtual void f() { cout &lt;&lt; &quot;Base3::f()&quot; &lt;&lt; endl; }
    virtual void g() { cout &lt;&lt; &quot;Base3::g()&quot; &lt;&lt; endl; }
    virtual void h() { cout &lt;&lt; &quot;Base3::h()&quot; &lt;&lt; endl; }
};

class Derive : public Base1, public Base2, public Base3 {
public:
    int iderive;
    Derive():iderive(100) {}
    virtual void f() { cout &lt;&lt; &quot;Derive::f()&quot; &lt;&lt; endl; }
    virtual void g1() { cout &lt;&lt; &quot;Derive::g1()&quot; &lt;&lt; endl; }
};</pre>
<p>我们通过下面的程序来查看子类实例的内存布局：下面程序中，注意我使用了一个s变量，其中用到了sizof(Base)来找下一个类的偏移量。（因为我声明的是int成员，所以是4个字节，所以没有对齐问题。关于内存的对齐问题，大家可以自行试验，我在这里就不多说了）</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW" data-enlighter-highlight="27,45">typedef void(*Fun)(void);

Derive d;

int** pVtab = (int**)&amp;d;

cout &lt;&lt; &quot;[0] Base1::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[0][0];
cout &lt;&lt; &quot;     [0] &quot;;
pFun();

pFun = (Fun)pVtab[0][1];
cout &lt;&lt; &quot;     [1] &quot;;pFun();

pFun = (Fun)pVtab[0][2];
cout &lt;&lt; &quot;     [2] &quot;;pFun();

pFun = (Fun)pVtab[0][3];
cout &lt;&lt; &quot;     [3] &quot;; pFun();

pFun = (Fun)pVtab[0][4];
cout &lt;&lt; &quot;     [4] &quot;; cout&lt;&lt;pFun&lt;&lt;endl;

cout &lt;&lt; &quot;[1] Base1.ibase1 = &quot; &lt;&lt; (int)pVtab[1] &lt;&lt; endl;

int s = sizeof(Base1)/4;

cout &lt;&lt; &quot;[&quot; &lt;&lt; s &lt;&lt; &quot;] Base2::_vptr-&gt;&quot;&lt;&lt;endl;
pFun = (Fun)pVtab[s][0];
cout &lt;&lt; &quot;     [0] &quot;; pFun();

Fun = (Fun)pVtab[s][1];
cout &lt;&lt; &quot;     [1] &quot;; pFun();

pFun = (Fun)pVtab[s][2];
cout &lt;&lt; &quot;     [2] &quot;; pFun();

pFun = (Fun)pVtab[s][3];
out &lt;&lt; &quot;     [3] &quot;;
cout&lt;&lt;pFun&lt;&lt;endl;

cout &lt;&lt; &quot;[&quot;&lt;&lt; s+1 &lt;&lt;&quot;] Base2.ibase2 = &quot; &lt;&lt; (int)pVtab[s+1] &lt;&lt; endl;

s = s + sizeof(Base2)/4;

cout &lt;&lt; &quot;[&quot; &lt;&lt; s &lt;&lt; &quot;] Base3::_vptr-&gt;&quot;&lt;&lt;endl;
pFun = (Fun)pVtab[s][0];
cout &lt;&lt; &quot;     [0] &quot;; pFun();

pFun = (Fun)pVtab[s][1];
cout &lt;&lt; &quot;     [1] &quot;; pFun();

pFun = (Fun)pVtab[s][2];
cout &lt;&lt; &quot;     [2] &quot;; pFun();

pFun = (Fun)pVtab[s][3];
cout &lt;&lt; &quot;     [3] &quot;;
cout&lt;&lt;pFun&lt;&lt;endl;

s++;
cout &lt;&lt; &quot;[&quot;&lt;&lt; s &lt;&lt;&quot;] Base3.ibase3 = &quot; &lt;&lt; (int)pVtab[s] &lt;&lt; endl;
s++;
cout &lt;&lt; &quot;[&quot;&lt;&lt; s &lt;&lt;&quot;] Derive.iderive = &quot; &lt;&lt; (int)pVtab[s] &lt;&lt; endl;</pre>
<p>其运行结果如下所示：（在VC++ 2003和G++ 3.4.4下）</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">[0] Base1::_vptr-&gt;
     [0] Derive::f()
     [1] Base1::g()
     [2] Base1::h()
     [3] Driver::g1()
     [4] 00000000      &lt;== 注意：在GCC下，这里是1
[1] Base1.ibase1 = 10
[2] Base2::_vptr-&gt;
     [0] Derive::f()
     [1] Base2::g()
     [2] Base2::h()
     [3] 00000000      &lt;== 注意：在GCC下，这里是1
[3] Base2.ibase2 = 20
[4] Base3::_vptr-&gt;
     [0] Derive::f()
     [1] Base3::g()
     [2] Base3::h()
     [3] 00000000
[5] Base3.ibase3 = 30
[6] Derive.iderive = 100</pre>
<p>使用图片表示是下面这个样子：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12182" src="https://coolshell.cn/wp-content/uploads/2014/12/041.jpg" alt="04" width="500" height="287" srcset="https://coolshell.cn/wp-content/uploads/2014/12/041.jpg 500w, https://coolshell.cn/wp-content/uploads/2014/12/041-300x172.jpg 300w" sizes="(max-width: 500px) 100vw, 500px" /></p>
<p>我们可以看到：</p>
<p style="padding-left: 30px;">1）  每个父类都有自己的虚表。</p>
<p style="padding-left: 30px;">2）  子类的成员函数被放到了第一个父类的表中。</p>
<p style="padding-left: 30px;">3）  内存布局中，其父类布局依次按声明顺序排列。</p>
<p style="padding-left: 30px;">4）  每个父类的虚表中的f()函数都被overwrite成了子类的f()。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<h4>重复继承</h4>
<p>下面我们再来看看，发生重复继承的情况。所谓重复继承，也就是某个基类被间接地重复继承了多次。</p>
<p>下图是一个继承图，我们重载了父类的f()函数。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12188" src="https://coolshell.cn/wp-content/uploads/2014/12/051.jpg" alt="05" width="253" height="393" srcset="https://coolshell.cn/wp-content/uploads/2014/12/051.jpg 253w, https://coolshell.cn/wp-content/uploads/2014/12/051-193x300.jpg 193w" sizes="(max-width: 253px) 100vw, 253px" /></p>
<p>其类继承的源代码如下所示。其中，每个类都有两个变量，一个是整形（4字节），一个是字符（1字节），而且还有自己的虚函数，自己overwrite父类的虚函数。如子类D中，f()覆盖了超类的函数， f1() 和f2() 覆盖了其父类的虚函数，Df()为自己的虚函数。</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class B
{
    public:
        int ib;
        char cb;
    public:
        B():ib(0),cb(&#039;B&#039;) {}

        virtual void f() { cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; endl;}
        virtual void Bf() { cout &lt;&lt; &quot;B::Bf()&quot; &lt;&lt; endl;}
};
class B1 :  public B
{
    public:
        int ib1;
        char cb1;
    public:
        B1():ib1(11),cb1(&#039;1&#039;) {}

        virtual void f() { cout &lt;&lt; &quot;B1::f()&quot; &lt;&lt; endl;}
        virtual void f1() { cout &lt;&lt; &quot;B1::f1()&quot; &lt;&lt; endl;}
        virtual void Bf1() { cout &lt;&lt; &quot;B1::Bf1()&quot; &lt;&lt; endl;}

};
class B2:  public B
{
    public:
        int ib2;
        char cb2;
    public:
        B2():ib2(12),cb2(&#039;2&#039;) {}

        virtual void f() { cout &lt;&lt; &quot;B2::f()&quot; &lt;&lt; endl;}
        virtual void f2() { cout &lt;&lt; &quot;B2::f2()&quot; &lt;&lt; endl;}
        virtual void Bf2() { cout &lt;&lt; &quot;B2::Bf2()&quot; &lt;&lt; endl;}

};

class D : public B1, public B2
{
    public:
        int id;
        char cd;
    public:
        D():id(100),cd(&#039;D&#039;) {}

        virtual void f() { cout &lt;&lt; &quot;D::f()&quot; &lt;&lt; endl;}
        virtual void f1() { cout &lt;&lt; &quot;D::f1()&quot; &lt;&lt; endl;}
        virtual void f2() { cout &lt;&lt; &quot;D::f2()&quot; &lt;&lt; endl;}
        virtual void Df() { cout &lt;&lt; &quot;D::Df()&quot; &lt;&lt; endl;}

};</pre>
<p>我们用来存取子类内存布局的代码如下所示：（在VC++ 2003和G++ 3.4.4下）</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">typedef void(*Fun)(void);
int** pVtab = NULL;
Fun pFun = NULL;

D d;
pVtab = (int**)&amp;d;
cout &lt;&lt; &quot;[0] D::B1::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[0][0];
cout &lt;&lt; &quot;     [0] &quot;;    pFun();
pFun = (Fun)pVtab[0][1];
cout &lt;&lt; &quot;     [1] &quot;;    pFun();
pFun = (Fun)pVtab[0][2];
cout &lt;&lt; &quot;     [2] &quot;;    pFun();
pFun = (Fun)pVtab[0][3];
cout &lt;&lt; &quot;     [3] &quot;;    pFun();
pFun = (Fun)pVtab[0][4];
cout &lt;&lt; &quot;     [4] &quot;;    pFun();
pFun = (Fun)pVtab[0][5];
cout &lt;&lt; &quot;     [5] 0x&quot; &lt;&lt; pFun &lt;&lt; endl;

cout &lt;&lt; &quot;[1] B::ib = &quot; &lt;&lt; (int)pVtab[1] &lt;&lt; endl;
cout &lt;&lt; &quot;[2] B::cb = &quot; &lt;&lt; (char)pVtab[2] &lt;&lt; endl;
cout &lt;&lt; &quot;[3] B1::ib1 = &quot; &lt;&lt; (int)pVtab[3] &lt;&lt; endl;
cout &lt;&lt; &quot;[4] B1::cb1 = &quot; &lt;&lt; (char)pVtab[4] &lt;&lt; endl;

cout &lt;&lt; &quot;[5] D::B2::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[5][0];
cout &lt;&lt; &quot;     [0] &quot;;    pFun();
pFun = (Fun)pVtab[5][1];
cout &lt;&lt; &quot;     [1] &quot;;    pFun();
pFun = (Fun)pVtab[5][2];
cout &lt;&lt; &quot;     [2] &quot;;    pFun();
pFun = (Fun)pVtab[5][3];
cout &lt;&lt; &quot;     [3] &quot;;    pFun();
pFun = (Fun)pVtab[5][4];
cout &lt;&lt; &quot;     [4] 0x&quot; &lt;&lt; pFun &lt;&lt; endl;

cout &lt;&lt; &quot;[6] B::ib = &quot; &lt;&lt; (int)pVtab[6] &lt;&lt; endl;
cout &lt;&lt; &quot;[7] B::cb = &quot; &lt;&lt; (char)pVtab[7] &lt;&lt; endl;
cout &lt;&lt; &quot;[8] B2::ib2 = &quot; &lt;&lt; (int)pVtab[8] &lt;&lt; endl;
cout &lt;&lt; &quot;[9] B2::cb2 = &quot; &lt;&lt; (char)pVtab[9] &lt;&lt; endl;

cout &lt;&lt; &quot;[10] D::id = &quot; &lt;&lt; (int)pVtab[10] &lt;&lt; endl;
cout &lt;&lt; &quot;[11] D::cd = &quot; &lt;&lt; (char)pVtab[11] &lt;&lt; endl;</pre>
<p>程序运行结果如下：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12187" src="https://coolshell.cn/wp-content/uploads/2014/12/06.png" alt="06" width="573" height="499" srcset="https://coolshell.cn/wp-content/uploads/2014/12/06.png 573w, https://coolshell.cn/wp-content/uploads/2014/12/06-300x261.png 300w" sizes="(max-width: 573px) 100vw, 573px" /></p>
<p>下面是对于子类实例中的虚函数表的图：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12186" src="https://coolshell.cn/wp-content/uploads/2014/12/061.jpg" alt="06" width="400" height="305" srcset="https://coolshell.cn/wp-content/uploads/2014/12/061.jpg 400w, https://coolshell.cn/wp-content/uploads/2014/12/061-300x228.jpg 300w" sizes="(max-width: 400px) 100vw, 400px" /></p>
<p>我们可以看见，最顶端的父类B其成员变量存在于B1和B2中，并被D给继承下去了。而在D中，其有B1和B2的实例，于是B的成员在D的实例中存在两份，一份是B1继承而来的，另一份是B2继承而来的。所以，如果我们使用以下语句，则会产生二义性编译错误：</p>
<p>D d;<br />
d.ib = 0; //二义性错误<br />
d.B1::ib = 1; //正确<br />
d.B2::ib = 2; //正确</p>
<p>注意，上面例程中的最后两条语句存取的是两个变量。虽然我们消除了二义性的编译错误，但B类在D中还是有两个实例，这种继承造成了数据的重复，我们叫这种继承为重复继承。重复的基类数据成员可能并不是我们想要的。所以，C++引入了虚基类的概念。</p>
<h4>钻石型多重虚拟继承</h4>
<p>虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的。钻石型的结构是其最经典的结构。也是我们在这里要讨论的结构：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12185" src="https://coolshell.cn/wp-content/uploads/2014/12/071.jpg" alt="07" width="253" height="404" srcset="https://coolshell.cn/wp-content/uploads/2014/12/071.jpg 253w, https://coolshell.cn/wp-content/uploads/2014/12/071-187x300.jpg 187w" sizes="(max-width: 253px) 100vw, 253px" /></p>
<p>上述的“重复继承”只需要把B1和B2继承B的语法中加上virtual 关键，就成了虚拟继承，其继承图如下所示：</p>
<p>上图和前面的“重复继承”中的类的内部数据和接口都是完全一样的，只是我们采用了虚拟继承：其省略后的源码如下所示：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class B {……};
class B1 : virtual public B{……};
class B2: virtual public B{……};
class D : public B1, public B2{ …… };</pre>
<p>在查看D之前，我们先看一看单一虚拟继承的情况。下面是一段在VC++2003下的测试程序：（因为VC++和GCC的内存而局上有一些细节上的不同，所以这里只给出VC++的程序，GCC下的程序大家可以根据我给出的程序自己仿照着写一个去试一试）：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int** pVtab = NULL;
Fun pFun = NULL;

B1 bb1;

pVtab = (int**)&amp;bb1;
cout &lt;&lt; &quot;[0] B1::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[0][0];
cout &lt;&lt; &quot;     [0] &quot;;
pFun(); //B1::f1();
cout &lt;&lt; &quot;     [1] &quot;;
pFun = (Fun)pVtab[0][1];
pFun(); //B1::bf1();
cout &lt;&lt; &quot;     [2] &quot;;
cout &lt;&lt; pVtab[0][2] &lt;&lt; endl;

cout &lt;&lt; &quot;[1] = 0x&quot;;
cout &lt;&lt; (int*)*((int*)(&amp;bb1)+1) &lt;&lt;endl; //B1::ib1
cout &lt;&lt; &quot;[2] B1::ib1 = &quot;;
cout &lt;&lt; (int)*((int*)(&amp;bb1)+2) &lt;&lt;endl; //B1::ib1
cout &lt;&lt; &quot;[3] B1::cb1 = &quot;;
cout &lt;&lt; (char)*((int*)(&amp;bb1)+3) &lt;&lt; endl; //B1::cb1

cout &lt;&lt; &quot;[4] = 0x&quot;;
cout &lt;&lt; (int*)*((int*)(&amp;bb1)+4) &lt;&lt; endl; //NULL

cout &lt;&lt; &quot;[5] B::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[5][0];
cout &lt;&lt; &quot;     [0] &quot;;
pFun(); //B1::f();
pFun = (Fun)pVtab[5][1];
cout &lt;&lt; &quot;     [1] &quot;;
pFun(); //B::Bf();
cout &lt;&lt; &quot;     [2] &quot;;
cout &lt;&lt; &quot;0x&quot; &lt;&lt; (Fun)pVtab[5][2] &lt;&lt; endl;

cout &lt;&lt; &quot;[6] B::ib = &quot;;
cout &lt;&lt; (int)*((int*)(&amp;bb1)+6) &lt;&lt;endl; //B::ib
cout &lt;&lt; &quot;[7] B::cb = &quot;;
</pre>
<p>其运行结果如下（我结出了GCC的和VC++2003的对比）：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12184" src="https://coolshell.cn/wp-content/uploads/2014/12/070.png" alt="070" width="627" height="308" srcset="https://coolshell.cn/wp-content/uploads/2014/12/070.png 627w, https://coolshell.cn/wp-content/uploads/2014/12/070-300x147.png 300w" sizes="(max-width: 627px) 100vw, 627px" /></p>
<p>这里，大家可以自己对比一下。关于细节上，我会在后面一并再说。</p>
<p>下面的测试程序是看子类D的内存布局，同样是VC++ 2003的（因为VC++和GCC的内存布局上有一些细节上的不同，而VC++的相对要清楚很多，所以这里只给出VC++的程序，GCC下的程序大家可以根据我给出的程序自己仿照着写一个去试一试）：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
D d;

pVtab = (int**)&amp;d;
cout &lt;&lt; &quot;[0] D::B1::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[0][0];
cout &lt;&lt; &quot;     [0] &quot;;    pFun(); //D::f1();
pFun = (Fun)pVtab[0][1];
cout &lt;&lt; &quot;     [1] &quot;;    pFun(); //B1::Bf1();
pFun = (Fun)pVtab[0][2];
cout &lt;&lt; &quot;     [2] &quot;;    pFun(); //D::Df();
pFun = (Fun)pVtab[0][3];
cout &lt;&lt; &quot;     [3] &quot;;
cout &lt;&lt; pFun &lt;&lt; endl;

//cout &lt;&lt; pVtab[4][2] &lt;&lt; endl;
cout &lt;&lt; &quot;[1] = 0x&quot;;
cout &lt;&lt;  (int*)((&amp;dd)+1) &lt;&lt;endl; //????

cout &lt;&lt; &quot;[2] B1::ib1 = &quot;;
cout &lt;&lt; *((int*)(&amp;dd)+2) &lt;&lt;endl; //B1::ib1
cout &lt;&lt; &quot;[3] B1::cb1 = &quot;;
cout &lt;&lt; (char)*((int*)(&amp;dd)+3) &lt;&lt; endl; //B1::cb1

//---------------------
cout &lt;&lt; &quot;[4] D::B2::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[4][0];
cout &lt;&lt; &quot;     [0] &quot;;    pFun(); //D::f2();
pFun = (Fun)pVtab[4][1];
cout &lt;&lt; &quot;     [1] &quot;;    pFun(); //B2::Bf2();
pFun = (Fun)pVtab[4][2];
cout &lt;&lt; &quot;     [2] &quot;;
cout &lt;&lt; pFun &lt;&lt; endl;

cout &lt;&lt; &quot;[5] = 0x&quot;;
cout &lt;&lt; *((int*)(&amp;dd)+5) &lt;&lt; endl; // ???

cout &lt;&lt; &quot;[6] B2::ib2 = &quot;;
cout &lt;&lt; (int)*((int*)(&amp;dd)+6) &lt;&lt;endl; //B2::ib2
cout &lt;&lt; &quot;[7] B2::cb2 = &quot;;
cout &lt;&lt; (char)*((int*)(&amp;dd)+7) &lt;&lt; endl; //B2::cb2

cout &lt;&lt; &quot;[8] D::id = &quot;;
cout &lt;&lt; *((int*)(&amp;dd)+8) &lt;&lt; endl; //D::id
cout &lt;&lt; &quot;[9] D::cd = &quot;;
cout &lt;&lt; (char)*((int*)(&amp;dd)+9) &lt;&lt; endl;//D::cd

cout &lt;&lt; &quot;[10]  = 0x&quot;;
cout &lt;&lt; (int*)*((int*)(&amp;dd)+10) &lt;&lt; endl;
//---------------------
cout &lt;&lt; &quot;[11] D::B::_vptr-&gt;&quot; &lt;&lt; endl;
pFun = (Fun)pVtab[11][0];
cout &lt;&lt; &quot;     [0] &quot;;    pFun(); //D::f();
pFun = (Fun)pVtab[11][1];
cout &lt;&lt; &quot;     [1] &quot;;    pFun(); //B::Bf();
pFun = (Fun)pVtab[11][2];
cout &lt;&lt; &quot;     [2] &quot;;
cout &lt;&lt; pFun &lt;&lt; endl;

cout &lt;&lt; &quot;[12] B::ib = &quot;;
cout &lt;&lt; *((int*)(&amp;dd)+12) &lt;&lt; endl; //B::ib
cout &lt;&lt; &quot;[13] B::cb = &quot;;
cout &lt;&lt; (char)*((int*)(&amp;dd)+13) &lt;&lt;endl;//B::cb</pre>
<p>下面给出运行后的结果（分VC++和GCC两部份）</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12183" src="https://coolshell.cn/wp-content/uploads/2014/12/07.png" alt="07" width="630" height="530" srcset="https://coolshell.cn/wp-content/uploads/2014/12/07.png 630w, https://coolshell.cn/wp-content/uploads/2014/12/07-300x252.png 300w" sizes="(max-width: 630px) 100vw, 630px" /></p>
<p>关于虚拟继承的运行结果我就不画图了（前面的作图已经让我产生了很严重的厌倦感，所以就偷个懒了，大家见谅了）</p>
<p>在上面的输出结果中，我用不同的颜色做了一些标明。我们可以看到如下的几点：</p>
<p style="padding-left: 30px;">1）无论是GCC还是VC++，除了一些细节上的不同，其大体上的对象布局是一样的。也就是说，先是B1（黄色），然后是B2（绿色），接着是D（灰色），而B这个超类（青蓝色）的实例都放在最后的位置。</p>
<p style="padding-left: 30px;">2）关于虚函数表，尤其是第一个虚表，GCC和VC++有很重大的不一样。但仔细看下来，还是VC++的虚表比较清晰和有逻辑性。</p>
<p style="padding-left: 30px;">3）VC++和GCC都把B这个超类放到了最后，而VC++有一个NULL分隔符把B和B1和B2的布局分开。GCC则没有。</p>
<p style="padding-left: 30px;">4）VC++中的内存布局有两个地址我有些不是很明白，在其中我用红色标出了。取其内容是-4。接道理来说，这个指针应该是指向B类实例的内存地址（这个做法就是为了保证重复的父类只有一个实例的技术）。但取值后却不是。这点我目前还并不太清楚，还向大家请教。</p>
<p style="padding-left: 30px;">5）GCC的内存布局中在B1和B2中则没有指向B的指针。这点可以理解，编译器可以通过计算B1和B2的size而得出B的偏移量。</p>
<h4>结束语</h4>
<p>C++这门语言是一门比较复杂的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要我们去了解他后面的内存对象。这样我们才能真正的了解C++，从而能够更好的使用C++这门最难的编程语言。</p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg" alt="Rust语言的编程范式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_title">Rust语言的编程范式</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg" alt="API设计原则 &#8211; Qt官网的设计实践总结" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_title">API设计原则 &#8211; Qt官网的设计实践总结</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif" alt="State Threads 回调终结者" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_title">State Threads 回调终结者</a></li><li ><a href="https://coolshell.cn/articles/11466.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/04/c99-150x150.jpg" alt="C语言的整型溢出问题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11466.html" class="wp_rp_title">C语言的整型溢出问题</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/12176.html">C++ 对象的内存布局</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/12176.html/feed</wfw:commentRss>
			<slash:comments>18</slash:comments>
		
		
			</item>
		<item>
		<title>C++ 虚函数表解析</title>
		<link>https://coolshell.cn/articles/12165.html</link>
					<comments>https://coolshell.cn/articles/12165.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 18 Dec 2007 01:08:02 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=12165</guid>

					<description><![CDATA[<p>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/12165.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/12165.html">C++ 虚函数表解析</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>
<p>关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。</p>
<p>当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。</p>
<p>言归正传，让我们一起进入虚函数的世界。</p>
<h4>虚函数表</h4>
<p>对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<p>这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p>
<p>听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。</p>
<p><span id="more-12165"></span></p>
<p>假设我们有这样的一个类：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class Base {
     public:
            virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; }
            virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; }
            virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; }

};</pre>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">typedef void(*Fun)(void);

Base b;

Fun pFun = NULL;

cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;
cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;

// Invoke the first virtual function
pFun = (Fun)*((int*)*(int*)(&amp;b));
pFun();</pre>
<p>实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3)</p>
<p style="padding-left: 30px;">虚函数表地址：0012FED4<br />
虚函数表 — 第一个函数地址：0044F148<br />
Base::f</p>
<p>通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">(Fun)*((int*)*(int*)(&amp;b)+0);  // Base::f()
(Fun)*((int*)*(int*)(&amp;b)+1);  // Base::g()
(Fun)*((int*)*(int*)(&amp;b)+2);  // Base::h()</pre>
<p>这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12166" src="https://coolshell.cn/wp-content/uploads/2014/12/01.jpg" alt="01" width="331" height="129" srcset="https://coolshell.cn/wp-content/uploads/2014/12/01.jpg 331w, https://coolshell.cn/wp-content/uploads/2014/12/01-300x117.jpg 300w" sizes="(max-width: 331px) 100vw, 331px" /></p>
<p>注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。</p>
<p>下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p>
<h4>一般继承（无虚函数覆盖）</h4>
<p>下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12167" src="https://coolshell.cn/wp-content/uploads/2014/12/02.jpg" alt="02" width="78" height="194" /></p>
<p>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：</p>
<p>对于实例：Derive d; 的虚函数表如下：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12168" src="https://coolshell.cn/wp-content/uploads/2014/12/03.jpg" alt="03" width="551" height="124" srcset="https://coolshell.cn/wp-content/uploads/2014/12/03.jpg 551w, https://coolshell.cn/wp-content/uploads/2014/12/03-300x67.jpg 300w" sizes="(max-width: 551px) 100vw, 551px" /></p>
<p>我们可以看到下面几点：<br />
1）虚函数按照其声明顺序放于表中。<br />
2）父类的虚函数在子类的虚函数前面。</p>
<p>我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。</p>
<h4>一般继承（有虚函数覆盖）</h4>
<p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12169" src="https://coolshell.cn/wp-content/uploads/2014/12/04.jpg" alt="04" width="78" height="194" /></p>
<p>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12170" src="https://coolshell.cn/wp-content/uploads/2014/12/05.jpg" alt="05" width="500" height="124" srcset="https://coolshell.cn/wp-content/uploads/2014/12/05.jpg 500w, https://coolshell.cn/wp-content/uploads/2014/12/05-300x74.jpg 300w" sizes="(max-width: 500px) 100vw, 500px" /></p>
<p>我们从表中可以看到下面几点，<br />
1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。<br />
2）没有被覆盖的函数依旧。</p>
<p>这样，我们就可以看到对于下面这样的程序，</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Base *b = new Derive();

b-&gt;f();</pre>
<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>
<h4>多重继承（无虚函数覆盖）</h4>
<p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12171" src="https://coolshell.cn/wp-content/uploads/2014/12/06.jpg" alt="06" width="282" height="192" /></p>
<p>对于子类实例中的虚函数表，是下面这个样子：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12172" src="https://coolshell.cn/wp-content/uploads/2014/12/07.jpg" alt="07" width="493" height="173" srcset="https://coolshell.cn/wp-content/uploads/2014/12/07.jpg 493w, https://coolshell.cn/wp-content/uploads/2014/12/07-300x105.jpg 300w" sizes="(max-width: 493px) 100vw, 493px" /></p>
<p>我们可以看到：<br />
1） 每个父类都有自己的虚表。<br />
2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</p>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<h4>多重继承（有虚函数覆盖）</h4>
<p>下面我们再来看看，如果发生虚函数覆盖的情况。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12173" src="https://coolshell.cn/wp-content/uploads/2014/12/08.jpg" alt="08" width="282" height="192" /></p>
<p>下图中，我们在子类中覆盖了父类的f()函数。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12174" src="https://coolshell.cn/wp-content/uploads/2014/12/09.jpg" alt="09" width="420" height="173" srcset="https://coolshell.cn/wp-content/uploads/2014/12/09.jpg 420w, https://coolshell.cn/wp-content/uploads/2014/12/09-300x123.jpg 300w" sizes="(max-width: 420px) 100vw, 420px" /></p>
<p>下面是对于子类实例中的虚函数表的图：</p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Derive d;
Base1 *b1 = &amp;d;
Base2 *b2 = &amp;d;
Base3 *b3 = &amp;d;
b1-&gt;f(); //Derive::f()
b2-&gt;f(); //Derive::f()
b3-&gt;f(); //Derive::f()

b1-&gt;g(); //Base1::g()
b2-&gt;g(); //Base2::g()
b3-&gt;g(); //Base3::g()</pre>
<h4>安全性</h4>
<p>每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。</p>
<h5>一、通过父类型的指针访问子类自己的虚函数</h5>
<p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Base1 *b1 = new Derive();
b1-&gt;f1();  //编译出错</pre>
<p>任何妄图使用父类指针想调用子类中的<strong>未覆盖父类的成员函数</strong>的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）</p>
<h5>二、访问non-public的虚函数</h5>
<p>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。</p>
<p>如：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class Base {
    private:
            virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; }

};

class Derive : public Base{

};

typedef void(*Fun)(void);

void main() {
    Derive d;
    Fun  pFun = (Fun)*((int*)*(int*)(&amp;d)+0);
    pFun();
}</pre>
<h4>结束语</h4>
<p>C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。</p>
<h5>附录一：VC中查看虚函数表</h5>
<p>我们可以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的）</p>
<h5>附录 二：例程</h5>
<p>下面是一个关于多重继承的虚函数表访问的例程：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;iostream&gt;
using namespace std;

class Base1 {
public:
            virtual void f() { cout &lt;&lt; &quot;Base1::f&quot; &lt;&lt; endl; }
            virtual void g() { cout &lt;&lt; &quot;Base1::g&quot; &lt;&lt; endl; }
            virtual void h() { cout &lt;&lt; &quot;Base1::h&quot; &lt;&lt; endl; }

};

class Base2 {
public:
            virtual void f() { cout &lt;&lt; &quot;Base2::f&quot; &lt;&lt; endl; }
            virtual void g() { cout &lt;&lt; &quot;Base2::g&quot; &lt;&lt; endl; }
            virtual void h() { cout &lt;&lt; &quot;Base2::h&quot; &lt;&lt; endl; }
};

class Base3 {
public:
            virtual void f() { cout &lt;&lt; &quot;Base3::f&quot; &lt;&lt; endl; }
            virtual void g() { cout &lt;&lt; &quot;Base3::g&quot; &lt;&lt; endl; }
            virtual void h() { cout &lt;&lt; &quot;Base3::h&quot; &lt;&lt; endl; }
};

class Derive : public Base1, public Base2, public Base3 {
public:
            virtual void f() { cout &lt;&lt; &quot;Derive::f&quot; &lt;&lt; endl; }
            virtual void g1() { cout &lt;&lt; &quot;Derive::g1&quot; &lt;&lt; endl; }
};

typedef void(*Fun)(void);

int main()
{
            Fun pFun = NULL;

            Derive d;
            int** pVtab = (int**)&amp;d;

            //Base1&#039;s vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0);
            pFun = (Fun)pVtab[0][0];
            pFun();

            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1);
            pFun = (Fun)pVtab[0][1];
            pFun();

            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2);
            pFun = (Fun)pVtab[0][2];
            pFun();

            //Derive&#039;s vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3);
            pFun = (Fun)pVtab[0][3];
            pFun();

            //The tail of the vtable
            pFun = (Fun)pVtab[0][4];
            cout&lt;&lt;pFun&lt;&lt;endl;

            //Base2&#039;s vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);
            pFun = (Fun)pVtab[1][0];
            pFun();

            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);
            pFun = (Fun)pVtab[1][1];
            pFun();

            pFun = (Fun)pVtab[1][2];
            pFun();

            //The tail of the vtable
            pFun = (Fun)pVtab[1][3];
            cout&lt;&lt;pFun&lt;&lt;endl;

            //Base3&#039;s vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);
            pFun = (Fun)pVtab[2][0];
            pFun();

            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);
            pFun = (Fun)pVtab[2][1];
            pFun();

            pFun = (Fun)pVtab[2][2];
            pFun();

            //The tail of the vtable
            pFun = (Fun)pVtab[2][3];
            cout&lt;&lt;pFun&lt;&lt;endl;

            return 0;
}</pre>
<p><strong>注：本文年代久远，所有的示例都是在32位机上跑的。</strong></p>
<p>(全文完)<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg" alt="Rust语言的编程范式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_title">Rust语言的编程范式</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg" alt="API设计原则 &#8211; Qt官网的设计实践总结" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_title">API设计原则 &#8211; Qt官网的设计实践总结</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif" alt="State Threads 回调终结者" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_title">State Threads 回调终结者</a></li><li ><a href="https://coolshell.cn/articles/11466.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/04/c99-150x150.jpg" alt="C语言的整型溢出问题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11466.html" class="wp_rp_title">C语言的整型溢出问题</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/12165.html">C++ 虚函数表解析</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/12165.html/feed</wfw:commentRss>
			<slash:comments>39</slash:comments>
		
		
			</item>
		<item>
		<title>C/C++返回内部静态成员的陷阱</title>
		<link>https://coolshell.cn/articles/12192.html</link>
					<comments>https://coolshell.cn/articles/12192.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Thu, 16 Nov 2006 02:12:11 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=12192</guid>

					<description><![CDATA[<p>在我们用C/C++开发的过程中，总是有一个问题会给我们带来苦恼。这个问题就是函数内和函数外代码需要通过一块内存来交互（比如，函数返回字符串），这个问题困扰和很多...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/12192.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/12192.html">C/C++返回内部静态成员的陷阱</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script></p>
<p align="left">在我们用C/C++开发的过程中，总是有一个问题会给我们带来苦恼。这个问题就是函数内和函数外代码需要通过一块内存来交互（比如，函数返回字符串），这个问题困扰和很多开发人员。如果你的内存是在函数内栈上分配的，那么这个内存会随着函数的返回而被弹栈释放，所以，你一定要返回一块函数外部还有效的内存。</p>
<p>这是一个让无数人困扰的问题。如果你一不小心，你就很有可能在这个上面犯错误。当然目前有很多解决方法，如果你熟悉一些标准库的话，你可以看到许多各式各样的解决方法。大体来说有下面几种：</p>
<p>1）在函数内部通过malloc或new在堆上分配内存，然后把这块内存返回（因为在堆上分配的内存是全局可见的）。这样带来的问题就是潜在的内存问题。因为，如果返回出去的内存不释放，那么就是memory Leak。或者是被多次释放，从而造成程序的crash。这两个问题都相当的严重，所以这种设计方法并不推荐。（在一些Windows API中，当你调用了一些API后，你必需也要调用他的某些API来释放这块内存）</p>
<p>2）让用户传入一块他自己的内存地址，而在函数中把要返回的内存放到这块内存中。这是一个目前普遍使用的方式。很多Windows API函数或是标准C函数都需要你传入一个buffer和这个buffer的长度。这种方式对我们来说应该是屡见不鲜了。这种方式的好处就是由函数外部的程序来维护这块内存，比较简显直观。但问题就是在使用上稍许有些麻烦。不过这种方式把犯错误的机率减到了最低。</p>
<p>3）第三种方式显得比较另类，他利用了static的特性，static的栈内存一旦分配，那这块内存不会随着函数的返回而释放，而且，它是全局可见的（只要你有这块内存的地址）。所以，有一些函数使用了static的这个特性，即不用使用堆上的内存，也不需要用户传入一个buffer和其长度。从而，使用得自己的函数长得很漂亮，也很容易使用。</p>
<p>这里，我想对第三个方法进行一些讨论。使用static内存这个方法看似不错，但是它有让你想象不到的陷阱。让我们来用一个实际发生的案例来举一个例子吧。</p>
<p><span id="more-12192"></span></p>
<h4><strong>示例</strong></h4>
<p>有过socket编程经验的人一定知道一个函数叫：inet_ntoa，这个函数主要的功能是把一个数字型的IP地址转成字符串，这个函数的定义是这样的（注意它的返回值）：</p>
<p align="center"><strong><span style="font-size: medium;">char *inet_ntoa(struct in_addr in);</span></strong></p>
<p align="left">显然，这个函数不会分配堆上的内存，而他又没有让你传一下字符串的buffer进入，那么他一定使用“返回static char[]”这种方法。在我们继续我们的讨论之前，让我们先了解一下IP地址相关的知识，下面是inet_ntoa这个函数需要传入的参数：（也许你会很奇怪，只有一个member的struct还要放在struct中干什么？这应该是为了程序日后的扩展性的考虑）</p>
<p><span style="font-size: medium;"><strong>struct in_addr {<br />
unsigned long int s_addr;<br />
}<br />
</strong><br />
</span>对于IPV4来说，一个IP地址由四个8位的bit组成，其放在s_addr中，高位在后，这是为了方便网络传输。如果你得到的一个s_addr的整型值是：3776385196。那么，打开你的Windows计算器吧，看看它的二进制是什么？让我们从右到左，8位为一组（如下所示）。</p>
<p align="center"><span style="font-size: medium;">11100001   00010111    00010000    10101100</span></p>
<p align="left">再把每一组转成十进制，于是我们就得到：225   23   16   172， 于是IP地址就是 172.16.23.225。</p>
<p>好了，言归正传。我们有这样一个程序，想记录网络包的源地址和目地地址，于是，我们有如下的代码：</p>
<p align="left">
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct in_addr src, des;
........
........
fprintf(fp, &quot;源IP地址&lt;%s&gt;/t目的IP地址&lt;%s&gt;/n&quot;, inet_ntoa(src),   inet_ntoa(des));</pre>
</p>
<p>会发生什么样的结果呢？你会发现记录到文件中的源IP地址和目的IP地址完全一样。这是什么问题呢？于是你开始调试你的程序，你发现src.s_addr和des.s_addr根本不一样（如下所示）。可为什么输出到文件的源和目的都是一样的？难道说是inet_ntoa的bug？</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">src.s_addr = 3776385196;    //对应于172.16.23.225
des.s_addr = 1678184620;  //对应于172.16.7.100</pre>
<p>原因就是inet_ntoa()“自作聪明”地把内部的static char[]返回了，而我们的程序正是踩中了这个陷阱。让我们来分析一下fprintf代码。在我们fprintf时，编译器先计算inet_ntoa(des)，于是其返回一个字符串的地址，然后程序再去求inet_ntoa(src)表达式，又得到一个字符串的地址。这两个字符串的地址都是inet_ntoa()中那个static char[]，显然是同一个地址，而第二次求src的IP时，这个值的des的IP地址内容必将被src的IP覆盖。所以，这两个表达式的字符串内存都是一样的了，此时，程序会调用fprintf把这两个字符串（其实是一个）输出到文件。所以，得到相同的结果也就不奇怪。</p>
<p>仔细看一下inet_ntoa的man，我们可以看到这句话：<strong>The string is returned in a statically allocated buffer,  which  subsequent calls will overwrite.</strong> 证实了我们的分析。</p>
<h4><strong>小结</strong></h4>
<p>让我们大家都扪心自问一下，我们在写程序的过程当中是否使用了这种方法？这是一个比较危险，容易出错的方法。这种陷阱让人防不胜防。想想，如果你有这样的程序：</p>
<p>if ( strcmp( inet_ntoa(ip1), inet_ntoa(ip2) )==0 ) {<br />
&#8230;. &#8230;.<br />
}</p>
<p>本想判断一下两个IP地址是否一样，却不料掉入了那个陷阱——让这个条件表达式永真。</p>
<p>这个事情告诉我们下面几个道理：</p>
<p>1）慎用这种方式的设计。返回函数内部的static内存有很大的陷阱。<br />
2）如果一定要使用这种方式的话。你就必须严肃地告诉所有使用这个函数的人，千万不要在一个表达式中多次使用这个函数。而且，还要告诉他们，不copy函数返回的内存的内容，而只是保存返回的内存地址或是引用是没用的。不然的话，后果概不负责。<br />
3）C/C++是很危险的世界，如果你不清楚他的话。还是回火星去吧。</p>
<p>附：看过Efftive C++的朋友一定知道其中有一个条款（item 23）：不要试图返回对象的引用。这个条款中也对是否返回函数内部的static变量进行了讨论。结果也是持否定态度的。</p>
<p>(全文完)<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg" alt="Rust语言的编程范式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_title">Rust语言的编程范式</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg" alt="API设计原则 &#8211; Qt官网的设计实践总结" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_title">API设计原则 &#8211; Qt官网的设计实践总结</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif" alt="State Threads 回调终结者" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_title">State Threads 回调终结者</a></li><li ><a href="https://coolshell.cn/articles/11466.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/04/c99-150x150.jpg" alt="C语言的整型溢出问题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11466.html" class="wp_rp_title">C语言的整型溢出问题</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/12192.html">C/C++返回内部静态成员的陷阱</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/12192.html/feed</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
		<item>
		<title>C++ STL string的Copy-On-Write技术</title>
		<link>https://coolshell.cn/articles/12199.html</link>
					<comments>https://coolshell.cn/articles/12199.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Wed, 23 Jun 2004 02:36:50 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[STL]]></category>
		<category><![CDATA[String]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=12199</guid>

					<description><![CDATA[<p>Scott Meyers在《More Effective C++》中举了个例子，不知你是否还记得？在你还在上学的时候，你的父母要你不要看电视，而去复习功课，于是...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/12199.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/12199.html">C++ STL string的Copy-On-Write技术</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>Scott Meyers在《More Effective C++》中举了个例子，不知你是否还记得？在你还在上学的时候，你的父母要你不要看电视，而去复习功课，于是你把自己关在房间里，做出一副正在复习功课的样子，其实你在干着别的诸如给班上的某位女生写情书之类的事，而一旦你的父母出来在你房间要检查你是否在复习时，你才真正捡起课本看书。这就是“拖延战术”，直到你非要做的时候才去做。</p>
<p>当然，这种事情在现实生活中时往往会出事，但其在编程世界中摇身一变，就成为了最有用的技术，正如C++中的可以随处声明变量的特点一样，Scott Meyers推荐我们，在真正需要一个存储空间时才去声明变量（分配内存），这样会得到程序在运行时最小的内存花销。执行到那才会去做分配内存这种比较耗时的工作，这会给我们的程序在运行时有比较好的性能。必竟，20%的程序运行了80%的时间。</p>
<p>当然，拖延战术还并不只是这样一种类型，这种技术被我们广泛地应用着，特别是在操作系统当中，当一个程序运行结束时，操作系统并不会急着把其清除出内存，原因是有可能程序还会马上再运行一次（从磁盘把程序装入到内存是个很慢的过程），而只有当内存不够用了，才会把这些还驻留内存的程序清出。</p>
<p>写时才拷贝（Copy-On-Write）技术，就是编程界“懒惰行为”——拖延战术的产物。举个例子，比如我们有个程序要写文件，不断地根据网络传来的数据写，如果每一次fwrite或是fprintf都要进行一个磁盘的I/O操作的话，都简直就是性能上巨大的损失，因此通常的做法是，每次写文件操作都写在特定大小的一块内存中（磁盘缓存），只有当我们关闭文件时，才写到磁盘上（这就是为什么如果文件不关闭，所写的东西会丢失的原因）。更有甚者是文件关闭时都不写磁盘，而一直等到关机或是内存不够时才写磁盘，Unix就是这样一个系统，如果非正常退出，那么数据就会丢失，文件就会损坏。</p>
<p>呵呵，为了性能我们需要冒这样大的风险，还好我们的程序是不会忙得忘了还有一块数据需要写到磁盘上的，所以这种做法，还是很有必要的。</p>
<p><span id="more-12199"></span></p>
<h4>STL类std::string的Copy-On-Write</h4>
<p>在我们经常使用的STL标准模板库中的string类，也是一个具有写时才拷贝技术的类。C++曾在性能问题上被广泛地质疑和指责过，为了提高性能，STL中的许多类都采用了Copy-On-Write技术。这种偷懒的行为的确使使用STL的程序有着比较高要性能。</p>
<p>这里，我想从C++类或是设计模式的角度为各位揭开Copy-On-Write技术在string中实现的面纱，以供各位在用C++进行类库设计时做一点参考。</p>
<p>在讲述这项技术之前，我想简单地说明一下string类内存分配的概念。通过常，string类中必有一个私有成员，其是一个char*，用户记录从堆上分配内存的地址，其在构造时分配内存，在析构时释放内存。因为是从堆上分配内存，所以string类在维护这块内存上是格外小心的，string类在返回这块内存地址时，只返回const char*，也就是只读的，如果你要写，你只能通过string提供的方法进行数据的改写。</p>
<h4>特性</h4>
<p>由表及里，由感性到理性，我们先来看一看string类的Copy-On-Write的表面特征。让我们写下下面的一段程序：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
#include &lt;string&gt;
using namespace std;
 
main()
{
    string str1 = &quot;hello world&quot;;
    string str2 = str1;

    printf (&quot;Sharing the memory:/n&quot;);
    printf (&quot;/tstr1&#039;s address: %x/n&quot;, str1.c_str() );
    printf (&quot;/tstr2&#039;s address: %x/n&quot;, str2.c_str() );

    str1[1]=&#039;q&#039;;
    str2[1]=&#039;w&#039;;

    printf (&quot;After Copy-On-Write:/n&quot;);
    printf (&quot;/tstr1&#039;s address: %x/n&quot;, str1.c_str() );
    printf (&quot;/tstr2&#039;s address: %x/n&quot;, str2.c_str() );

    return 0;
}</pre>
<p>这个程序的意图就是让第二个<span lang="EN">string</span>通过第一个<span lang="EN">string</span>构造，然后打印出其存放数据的内存地址，然后分别修改<span lang="EN">str1</span>和<span lang="EN">str2</span>的内容，再查一下其存放内存的地址。程序的输出是这样的（我在<span lang="EN">VC6.0</span>和<span lang="EN">g++ 2.95</span>都得到了同样的结果）：</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">&gt; g++ -o stringTest stringTest.cpp
&gt; ./stringTest
Sharing the memory:
        str1&#039;s address: 343be9
        str2&#039;s address: 343be9
After Copy-On-Write:
        str1&#039;s address: 3407a9
        str2&#039;s address: 343be9</pre>
<p>从结果中我们可以看到，在开始的两个语句后，<span lang="EN">str1</span>和<span lang="EN">str2</span>存放数据的地址是一样的，而在修改内容后，<span lang="EN">str1</span>的地址发生了变化，而<span lang="EN">str2</span>的地址还是原来的。从这个例子，我们可以看到<span lang="EN">string</span>类的<span lang="EN">Copy-On-Write</span>技术。</p>
<h4> 深入</h4>
<p>在深入这前，通过上述的演示，我们应该知道在string类中，要实现写时才拷贝，需要解决两个问题，一个是内存共享，一个是Copy-On-Wirte，这两个主题会让我们产生许多疑问，还是让我们带着这样几个问题来学习吧：</p>
<p style="padding-left: 30px;">1、  Copy-On-Write的原理是什么？</p>
<p style="padding-left: 30px;">2、  string类在什么情况下才共享内存的？</p>
<p style="padding-left: 30px;">3、  string类在什么情况下触发写时才拷贝（Copy-On-Write）?</p>
<p style="padding-left: 30px;">4、  Copy-On-Write时，发生了什么？</p>
<p style="padding-left: 30px;">5、  Copy-On-Write的具体实现是怎么样的？</p>
<p>喔，你说只要看一看STL中stirng的源码你就可以找到答案了。当然，当然，我也是参考了string的父模板类basic_string的源码。但是，如果你感到看STL的源码就好像看机器码，并严重打击你对C++自信心，乃至产生了自己是否懂C++的疑问，如果你有这样的感觉，那么还是继续往下看我的这篇文章吧。</p>
<p>OK，让我们一个问题一个问题地探讨吧，慢慢地所有的技术细节都会浮出水面的。</p>
<p>&nbsp;</p>
<h4>Copy-On-Write的原理是什么？</h4>
<p>有一定经验的程序员一定知道，Copy-On-Write一定使用了“引用计数”，是的，必然有一个变量类似于RefCnt。当第一个类构造时，string的构造函数会根据传入的参数从堆上分配内存，当有其它类需要这块内存时，这个计数为自动累加，当有类析构时，这个计数会减一，直到最后一个类析构时，此时的RefCnt为1或是0，此时，程序才会真正的Free这块从堆上分配的内存。</p>
<p>是的，<strong>引用计数就是string类中写时才拷贝的原理</strong>！</p>
<p>不过，问题又来了，这个RefCnt该存在在哪里呢？如果存放在string类中，那么每个string的实例都有各自的一套，根本不能共有一个RefCnt，如果是声明成全局变量，或是静态成员，那就是所有的string类共享一个了，这也不行，我们需要的是一个“民主和集中”的一个解决方法。这是如何做到的呢？呵呵，人生就是一个糊涂后去探知，知道后和又糊涂的循环过程。别急别急，在后面我会给你一一道来的。</p>
<p>&nbsp;</p>
<h4>string类在什么情况下才共享内存的？</h4>
<p>&nbsp;</p>
<p>这个问题的答案应该是明显的，根据常理和逻辑，如果一个类要用另一个类的数据，那就可以共享被使用类的内存了。这是很合理的，如果你不用我的，那就不用共享，只有你使用我的，才发生共享。</p>
<p>&nbsp;</p>
<p>使用别的类的数据时，无非有两种情况，1）以别的类构造自己，2）以别的类赋值。第一种情况时会触发拷贝构造函数，第二种情况会触发赋值操作符。这两种情况我们都可以在类中实现其对应的方法。对于第一种情况，只需要在string类的拷贝构造函数中做点处理，让其引用计数累加；同样，对于第二种情况，只需要重载string类的赋值操作符，同样在其中加上一点处理。</p>
<p>唠叨几句：</p>
<p><strong>1）构造和赋值的差别</strong></p>
<p>对于前面那个例程中的这两句：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">string str1 = &quot;hello world&quot;;

string str2 = str1;</pre>
<p>不要以为有“=”就是赋值操作，其实，这两条语句等价于：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">string str1 (&quot;hello world&quot;);   //调用的是构造函数

string str2 (str1);            //调用的是拷贝构造函数</pre>
<p>如果str2是下面的这样情况：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">string str2;      //调用参数默认为空串的构造函数：string str2(“”);

str2 = str1;     //调用str2的赋值操作：str2.operator=(str1);</pre>
<p><strong>2) 另一种情况</strong></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">char tmp[]=”hello world”;

string str1 = tmp;

string str2 = tmp;</pre>
<p>这种情况下会触发内存的共享吗？想当然的，应该要共享。可是根据我们前面所说的共享内存的情况，两个string类的声明和初始语句并不符合我前述的两种情况，所以其并不发生内存共享。而且，C++现有特性也无法让我们做到对这种情况进行类的内存共享。</p>
<h4>string类在什么情况下触发写时才拷贝（Copy-On-Write）?</h4>
<p>哦，什么时候会发现写时才拷贝？很显然，当然是在共享同一块内存的类发生内容改变时，才会发生Copy-On-Write。比如string类的[]、=、+=、+、操作符赋值，还有一些string类中诸如insert、replace、append等成员函数,包括类的析构时。</p>
<p>修改数据才会触发Copy-On-Write，不修改当然就不会改啦。这就是托延战术的真谛，非到要做的时候才去做。</p>
<h4>Copy-On-Write时，发生了什么？</h4>
<p>我们可能根据那个访问计数来决定是否需要拷贝，参看下面的代码：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">If  ( RefCnt&gt;0 ) {
    char* tmp =  (char*) malloc(strlen(_Ptr)+1);
    strcpy(tmp, _Ptr);
    _Ptr = tmp;
}</pre>
<p>&nbsp;</p>
<p>上面的代码是一个假想的拷贝方法，如果有别的类在引用（检查引用计数来获知）这块内存，那么就需要把更改类进行“拷贝”这个动作。</p>
<p>我们可以把这个拷的运行封装成一个函数，供那些改变内容的成员函数使用。</p>
<h4>Copy-On-Write的具体实现是怎么样的？</h4>
<p>最后的这个问题，我们主要解决的是那个“民主集中”的难题。请先看下面的代码：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">string h1 = “hello”;
string h2= h1;
string h3;
h3 = h2;
 
string w1 = “world”;
string w2(“”);
w2=w1;</pre>
<p>很明显，我们要让h1、h2、h3共享同一块内存，让w1、w2共享同一块内存。因为，在h1、h2、h3中，我们要维护一个引用计数，在w1、w2中我们又要维护一个引用计数。</p>
<p>如何使用一个巧妙的方法产生这两个引用计数呢？我们想到了string类的内存是在堆上动态分配的，既然共享内存的各个类指向的是同一个内存区，我们为什么不在这块区上多分配一点空间来存放这个引用计数呢？这样一来，所有共享一块内存区的类都有同样的一个引用计数，而这个变量的地址既然是在共享区上的，那么所有共享这块内存的类都可以访问到，也就知道这块内存的引用者有多少了。</p>
<p>请看下图：</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-12200" src="https://coolshell.cn/wp-content/uploads/2014/12/o_string.jpg" alt="o_string" width="409" height="138" srcset="https://coolshell.cn/wp-content/uploads/2014/12/o_string.jpg 409w, https://coolshell.cn/wp-content/uploads/2014/12/o_string-300x101.jpg 300w" sizes="(max-width: 409px) 100vw, 409px" /></p>
<p>于是，有了这样一个机制，每当我们为<span lang="EN">string</span>分配内存时，我们总是要多分配一个空间用来存放这个引用计数的值，只要发生拷贝构造可是赋值时，这个内存的值就会加一。而在内容修改时，<span lang="EN">string</span>类为查看这个引用计数是否为<span lang="EN">0</span>，如果不为零，表示有人在共享这块内存，那么自己需要先做一份拷贝，然后把引用计数减去一，再把数据拷贝过来。下面的几个程序片段说明了这两个动作：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//构造函数（分存内存）
    string::string(const char* tmp)
{
    _Len = strlen(tmp);
    _Ptr = new char[_Len+1+1];
    strcpy( _Ptr, tmp );
    _Ptr[_Len+1]=0;  // 设置引用计数  
}
 
//拷贝构造（共享内存）
    string::string(const string&amp; str)
    {
         if (*this != str){
              this-&gt;_Ptr = str.c_str();   //共享内存
              this-&gt;_Len = str.szie();
              this-&gt;_Ptr[_Len+1] ++;  //引用计数加一
         }
}
 
//写时才拷贝Copy-On-Write
char&amp; string::operator[](unsigned int idx)
{
    if (idx &gt; _Len || _Ptr == 0 ) {
         static char nullchar = 0;
return nullchar;
          }
   
_Ptr[_Len+1]--;   //引用计数减一
    char* tmp = new char[_Len+1+1];
    strncpy( tmp, _Ptr, _Len+1);
    _Ptr = tmp;
    _Ptr[_Len+1]=0; // 设置新的共享内存的引用计数
   
    return _Ptr[idx];
}

//析构函数的一些处理
~string()
{ 
_Ptr[_Len+1]--;   //引用计数减一
   
         // 引用计数为0时，释放内存 
    if (_Ptr[_Len+1]==0) {
        delete[] _Ptr;
         }
 
}</pre>
<p>哈哈，整个技术细节完全浮出水面。</p>
<p>&nbsp;</p>
<p>不过，这和STL中basic_string的实现细节还有一点点差别，在你打开STL的源码时，你会发现其取引用计数是通过这样的访问：_Ptr[-1]，标准库中，把这个引用计数的内存分配在了前面（我给出来的代码是把引用计数分配以了后面，这很不好），分配在前的好处是当string的长度扩展时，只需要在后面扩展其内存，而不需要移动引用计数的内存存放位置，这又节省了一点时间。</p>
<p>STL中的string的内存结构就像我前面画的那个图一样，_Ptr指着是数据区，而RefCnt则在_Ptr-1 或是_Ptr[-1]处。</p>
<h4>副作用</h4>
<p>是谁说的“有太阳的地方就会有黑暗”？或许我们中的许多人都很迷信标准的东西，认为其是久经考验，不可能出错的。呵呵，千万不要有这种迷信，因为任何设计再好，编码再好的代码在某一特定的情况下都会有Bug，STL同样如此，string类的这个共享内存/写时才拷贝技术也不例外，而且这个Bug或许还会让你的整个程序crash掉！</p>
<p>不信？！那么让我们来看一个测试案例。假设有一个动态链接库（叫myNet.dll或myNet.so）中有这样一个函数返回的是string类：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">string GetIPAddress(string hostname)
{
    static string ip;
    ……
    ……
    return ip;
}</pre>
<p>而你的主程序中动态地载入这个动态链接库，并调用其中的这个函数：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">main()
{
    //载入动态链接库中的函数
    hDll = LoadLibraray(…..);
    pFun =  GetModule(hDll, “GetIPAddress”);
     
    //调用动态链接库中的函数
    string ip = (*pFun)(“host1”);
    ……
    ……
    //释放动态链接库
    FreeLibrary(hDll);
    ……
    cout &lt;&lt; ip &lt;&lt; endl;
}</pre>
<p>让我们来看看这段代码，程序以动态方式载入动态链接库中的函数，然后以函数指针的方式调用动态链接库中的函数，并把返回值放在一个string类中，然后释放了这个动态链接库。释放后，输入ip的内容。</p>
<p>根据函数的定义，我们知道函数是“值返回”的，所以，函数返回时，一定会调用拷贝构造函数，又根据string类的内存共享机制，在主程序中变量ip是和函数内部的那个静态string变量共享内存（这块内存区是在动态链接库的地址空间的）。而我们假设在整个主程序中都没有对ip的值进行修改过。那么在当主程序释放了动态链接库后，那个共享的内存区也随之释放。所以，以后对ip的访问，必然做造成内存地址访问非法，造成程序crash。即使你在以后没有使用到ip这个变量，那么在主程序退出时也会发生内存访问异常，因为程序退出时，ip会析构，在析构时就会发生内存访问异常。</p>
<p>内存访问异常，意味着两件事：1）无论你的程序再漂亮，都会因为这个错误变得暗淡无光，你的声誉也会因为这个错误受到损失。2）未来的一段时间，你会被这个系统级错误所煎熬（在C++世界中，找到并排除这种内存错误并不是一件容易的事情）。这是C/C++程序员永远的心头之痛，千里之堤，溃于蚁穴。而如果你不清楚string类的这种特征，在成千上万行代码中找这样一个内存异常，简直就是一场噩梦。</p>
<p>备注：要改正上述的Bug，有很多种方法，这里提供一种仅供参考：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">string ip = (*pFun)(“host1”).cstr();</code></p>
<h4>后记</h4>
<p>&nbsp;</p>
<p>文章到这里也应该结束了，这篇文章的主要有以下几个目的：</p>
<p>1）向大家介绍一下写时才拷贝/内存共享这种技术。<br />
2）以STL中的string类为例，向大家介绍了一种设计模式。<br />
3）在C++世界中，无论你的设计怎么精巧，代码怎么稳固，都难以照顾到所有的情况。智能指针更是一个典型的例子，无论你怎么设计，都会有非常严重的BUG。<br />
4）C++是一把双刃剑，只有了解了原理，你才能更好的使用C++。否则，必将引火烧身。如果你在设计和使用类库时有一种“玩C++就像玩火，必须千万小心”的感觉，那么你就入门了，等你能把这股“火”控制的得心应手时，那才是学成了。</p>
<p><strong>更新：在最新的STL中，这个特性已经被去掉了。有一个原因是线程不安全！COW其实还是比较危险的。</strong></p>
<p>（全文完）</p>
<p>&nbsp;<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/3806.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/02/C_String-150x150.jpg" alt="Google图片搜索下的的C String" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3806.html" class="wp_rp_title">Google图片搜索下的的C String</a></li><li ><a href="https://coolshell.cn/articles/3036.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/19.jpg" alt="面向对象是个骗局？！" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3036.html" class="wp_rp_title">面向对象是个骗局？！</a></li><li ><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg" alt="Rust语言的编程范式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_title">Rust语言的编程范式</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg" alt="API设计原则 &#8211; Qt官网的设计实践总结" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_title">API设计原则 &#8211; Qt官网的设计实践总结</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/12199.html">C++ STL string的Copy-On-Write技术</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/12199.html/feed</wfw:commentRss>
			<slash:comments>16</slash:comments>
		
		
			</item>
	</channel>
</rss>
