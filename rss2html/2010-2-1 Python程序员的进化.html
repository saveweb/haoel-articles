<html><body><p>以前本站发布过一篇《<a href="https://coolshell.cn/articles/172.html" target="_blank">程序员的进化</a>》，以一种幽默的代码展现方式调侃了程序。下面这篇是关于Python程序员的。以阶乘为例，很有意思。</p>
<h4>新手程序员</h4>
<pre class="EnlighterJSRAW">def factorial(x):
    if x == 0:
        return 1
    else:
        return x * factorial(x - 1)
print factorial(6)</pre>
<h4>
第一年的刚学完Pascal的新手</h4>
<pre class="EnlighterJSRAW">def factorial(x):
    result = 1
    i = 2
    while i &lt;= x:
        result = result * i
        i = i + 1
    return result
print factorial(6)</pre>
<h4><span id="more-2082"></span></h4>
<h4>
第一年的刚学完C语言的新手</h4>
<pre class="EnlighterJSRAW">def fact(x): #{
    result = i = 1;
    while (i &lt;= x): #{
        result *= i;
        i += 1;
    #}
    return result;
#}
print(fact(6))</pre>
<h4>
第一年刚学完SICP的新手</h4>
<pre class="EnlighterJSRAW">@tailcall
def fact(x, acc=1):
    if (x &gt; 1): return (fact((x - 1), (acc * x)))
    else:       return acc
print(fact(6))</pre>
<h4>
第一年刚学完Python的新手</h4>
<pre class="EnlighterJSRAW">def Factorial(x):
    res = 1
    for i in xrange(2, x + 1):
        res *= i
    return res
print Factorial(6)</pre>
<h4>
爱偷懒的程序员</h4>
<pre class="EnlighterJSRAW">def fact(x):
    return x &gt; 1 and x * fact(x - 1) or 1
print fact(6)</pre>
<h4>
更懒的 Python 程序员</h4>
<pre class="EnlighterJSRAW">f = lambda x: x and x * f(x - 1) or 1
print f(6)</pre>
<h4>
Python 专家</h4>
<pre class="EnlighterJSRAW">import operator as op
import functional as f
fact = lambda x: f.foldl(op.mul, 1, xrange(2, x + 1))
print fact(6)</pre>
<h4>Python 黑客</h4>
<pre class="EnlighterJSRAW">import sys
@tailcall
def fact(x, acc=1):
    if x: return fact(x.__sub__(1), acc.__mul__(x))
    return acc
sys.stdout.write(str(fact(6)) + '\n')</pre>
<h4>
专家级程序员</h4>
<pre class="EnlighterJSRAW">import c_math
fact = c_math.fact
print fact(6)</pre>
<h4>
英语系的专家级程序员</h4>
<pre class="EnlighterJSRAW">import c_maths
fact = c_maths.fact
print fact(6)</pre>
<h4>
Web 设计者</h4>
<pre class="EnlighterJSRAW">def factorial(x):
    #-------------------------------------------------
    #--- Code snippet from The Math Vault          ---
    #--- Calculate factorial (C) Arthur Smith 1999 ---
    #-------------------------------------------------
    result = str(1)
    i = 1 #Thanks Adam
    while i &lt;= x:
        #result = result * i  #It's faster to use *=
        #result = str(result * result + i)
           #result = int(result *= i) #??????
        result str(int(result) * i)
        #result = int(str(result) * i)
        i = i + 1
    return result
print factorial(6)</pre>
<h4>
Unix 程序员</h4>
<pre class="EnlighterJSRAW">import os
def fact(x):
    os.system('factorial ' + str(x))
fact(6)</pre>
<h4>
Windows 程序员</h4>
<pre class="EnlighterJSRAW">NULL = None
def CalculateAndPrintFactorialEx(dwNumber,
                                 hOutputDevice,
                                 lpLparam,
                                 lpWparam,
                                 lpsscSecurity,
                                 *dwReserved):
    if lpsscSecurity != NULL:
        return NULL #Not implemented
    dwResult = dwCounter = 1
    while dwCounter &lt;= dwNumber:
        dwResult *= dwCounter
        dwCounter += 1
    hOutputDevice.write(str(dwResult))
    hOutputDevice.write('\n')
    return 1
import sys
CalculateAndPrintFactorialEx(6, sys.stdout, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)</pre>
<h4>
公司里的程序员</h4>
<pre class="EnlighterJSRAW">def new(cls, *args, **kwargs):
    return cls(*args, **kwargs)

class Number(object):
    pass

class IntegralNumber(int, Number):
    def toInt(self):
        return new (int, self)

class InternalBase(object):
    def __init__(self, base):
        self.base = base.toInt()

    def getBase(self):
        return new (IntegralNumber, self.base)

class MathematicsSystem(object):
    def __init__(self, ibase):
        Abstract

    @classmethod
    def getInstance(cls, ibase):
        try:
            cls.__instance
        except AttributeError:
            cls.__instance = new (cls, ibase)
        return cls.__instance

class StandardMathematicsSystem(MathematicsSystem):
    def __init__(self, ibase):
        if ibase.getBase() != new (IntegralNumber, 2):
            raise NotImplementedError
        self.base = ibase.getBase()

    def calculateFactorial(self, target):
        result = new (IntegralNumber, 1)
        i = new (IntegralNumber, 2)
        while i &lt;= target:
            result = result * i
            i = i + new (IntegralNumber, 1)
        return result

print StandardMathematicsSystem.getInstance(new (InternalBase, new (IntegralNumber, 2))).calculateFactorial(new (IntegralNumber, 6))</pre>
<p>摘自：<a href="http://gist.github.com/289467" target="_blank">来源</a><!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px; color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
<div class="wp_rp_wrap wp_rp_vertical_m"><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li><a class="wp_rp_thumbnail" href="https://coolshell.cn/articles/18360.html"><img alt="程序员练级攻略（2018)  与我的专栏" height="150" src="../wp-content/uploads/2018/05/300x262-150x150.jpg" width="150"/></a><a class="wp_rp_title" href="https://coolshell.cn/articles/18360.html">程序员练级攻略（2018)  与我的专栏</a></li><li><a class="wp_rp_thumbnail" href="https://coolshell.cn/articles/11265.html"><img alt="Python修饰器的函数式编程" height="150" src="../wp-content/uploads/2014/03/snake-hat-new-year-schedule-800x960-150x150.jpg" width="150"/></a><a class="wp_rp_title" href="https://coolshell.cn/articles/11265.html">Python修饰器的函数式编程</a></li><li><a class="wp_rp_thumbnail" href="https://coolshell.cn/articles/10822.html"><img alt="函数式编程" height="150" src="../wp-content/uploads/2013/12/yoda-lambda-150x150.png" width="150"/></a><a class="wp_rp_title" href="https://coolshell.cn/articles/10822.html">函数式编程</a></li><li><a class="wp_rp_thumbnail" href="https://coolshell.cn/articles/10169.html"><img alt="类型的本质和函数式实现" height="150" src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/5.jpg" width="150"/></a><a class="wp_rp_title" href="https://coolshell.cn/articles/10169.html">类型的本质和函数式实现</a></li><li><a class="wp_rp_thumbnail" href="https://coolshell.cn/articles/7886.html"><img alt="代码执行的效率" height="150" src="../wp-content/uploads/2012/07/muxnt-150x150.jpg" width="150"/></a><a class="wp_rp_title" href="https://coolshell.cn/articles/7886.html">代码执行的效率</a></li><li><a class="wp_rp_thumbnail" href="https://coolshell.cn/articles/4939.html"><img alt="Quora使用到的技术" height="150" src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" width="150"/></a><a class="wp_rp_title" href="https://coolshell.cn/articles/4939.html">Quora使用到的技术</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/2082.html">Python程序员的进化</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.</body></html>